/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app-client-internals"],{

/***/ "(app-client)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fandrew%2FDesktop%2Fdevelopment%2Fbucketlist%2Ffrontend%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fapp-router.js&modules=%2FUsers%2Fandrew%2FDesktop%2Fdevelopment%2Fbucketlist%2Ffrontend%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Flayout-router.js&modules=%2FUsers%2Fandrew%2FDesktop%2Fdevelopment%2Fbucketlist%2Ffrontend%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context.js&modules=%2FUsers%2Fandrew%2FDesktop%2Fdevelopment%2Fbucketlist%2Ffrontend%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Ferror-boundary.js&server=false!":
/*!********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fandrew%2FDesktop%2Fdevelopment%2Fbucketlist%2Ffrontend%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fapp-router.js&modules=%2FUsers%2Fandrew%2FDesktop%2Fdevelopment%2Fbucketlist%2Ffrontend%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Flayout-router.js&modules=%2FUsers%2Fandrew%2FDesktop%2Fdevelopment%2Fbucketlist%2Ffrontend%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context.js&modules=%2FUsers%2Fandrew%2FDesktop%2Fdevelopment%2Fbucketlist%2Ffrontend%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Ferror-boundary.js&server=false! ***!
  \********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/app-router.js */ \"(app-client)/./node_modules/next/dist/client/components/app-router.js\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/layout-router.js */ \"(app-client)/./node_modules/next/dist/client/components/layout-router.js\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/render-from-template-context.js */ \"(app-client)/./node_modules/next/dist/client/components/render-from-template-context.js\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/error-boundary.js */ \"(app-client)/./node_modules/next/dist/client/components/error-boundary.js\", 23))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1mbGlnaHQtY2xpZW50LWVudHJ5LWxvYWRlci5qcz9tb2R1bGVzPSUyRlVzZXJzJTJGYW5kcmV3JTJGRGVza3RvcCUyRmRldmVsb3BtZW50JTJGYnVja2V0bGlzdCUyRmZyb250ZW5kJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmRpc3QlMkZjbGllbnQlMkZjb21wb25lbnRzJTJGYXBwLXJvdXRlci5qcyZtb2R1bGVzPSUyRlVzZXJzJTJGYW5kcmV3JTJGRGVza3RvcCUyRmRldmVsb3BtZW50JTJGYnVja2V0bGlzdCUyRmZyb250ZW5kJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmRpc3QlMkZjbGllbnQlMkZjb21wb25lbnRzJTJGbGF5b3V0LXJvdXRlci5qcyZtb2R1bGVzPSUyRlVzZXJzJTJGYW5kcmV3JTJGRGVza3RvcCUyRmRldmVsb3BtZW50JTJGYnVja2V0bGlzdCUyRmZyb250ZW5kJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmRpc3QlMkZjbGllbnQlMkZjb21wb25lbnRzJTJGcmVuZGVyLWZyb20tdGVtcGxhdGUtY29udGV4dC5qcyZtb2R1bGVzPSUyRlVzZXJzJTJGYW5kcmV3JTJGRGVza3RvcCUyRmRldmVsb3BtZW50JTJGYnVja2V0bGlzdCUyRmZyb250ZW5kJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmRpc3QlMkZjbGllbnQlMkZjb21wb25lbnRzJTJGZXJyb3ItYm91bmRhcnkuanMmc2VydmVyPWZhbHNlIS5qcyIsIm1hcHBpbmdzIjoiQUFBQSx5T0FBaUo7QUFDakosK09BQW9KO0FBQ3BKLDZRQUFtSztBQUNuSyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzViMWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvYW5kcmV3L0Rlc2t0b3AvZGV2ZWxvcG1lbnQvYnVja2V0bGlzdC9mcm9udGVuZC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2FwcC1yb3V0ZXIuanNcIik7XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9hbmRyZXcvRGVza3RvcC9kZXZlbG9wbWVudC9idWNrZXRsaXN0L2Zyb250ZW5kL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvbGF5b3V0LXJvdXRlci5qc1wiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL2FuZHJldy9EZXNrdG9wL2RldmVsb3BtZW50L2J1Y2tldGxpc3QvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZW5kZXItZnJvbS10ZW1wbGF0ZS1jb250ZXh0LmpzXCIpO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvYW5kcmV3L0Rlc2t0b3AvZGV2ZWxvcG1lbnQvYnVja2V0bGlzdC9mcm9udGVuZC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2Vycm9yLWJvdW5kYXJ5LmpzXCIpIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fandrew%2FDesktop%2Fdevelopment%2Fbucketlist%2Ffrontend%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fapp-router.js&modules=%2FUsers%2Fandrew%2FDesktop%2Fdevelopment%2Fbucketlist%2Ffrontend%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Flayout-router.js&modules=%2FUsers%2Fandrew%2FDesktop%2Fdevelopment%2Fbucketlist%2Ffrontend%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context.js&modules=%2FUsers%2Fandrew%2FDesktop%2Fdevelopment%2Fbucketlist%2Ffrontend%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Ferror-boundary.js&server=false!\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/app-router-headers.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/app-router-headers.js ***!
  \************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.FLIGHT_PARAMETERS = exports.RSC_VARY_HEADER = exports.FETCH_CACHE_HEADER = exports.NEXT_ROUTER_PREFETCH = exports.NEXT_ROUTER_STATE_TREE = exports.RSC = void 0;\nvar RSC = 'RSC';\nexports.RSC = RSC;\nvar NEXT_ROUTER_STATE_TREE = 'Next-Router-State-Tree';\nexports.NEXT_ROUTER_STATE_TREE = NEXT_ROUTER_STATE_TREE;\nvar NEXT_ROUTER_PREFETCH = 'Next-Router-Prefetch';\nexports.NEXT_ROUTER_PREFETCH = NEXT_ROUTER_PREFETCH;\nvar FETCH_CACHE_HEADER = 'x-vercel-sc-headers';\nexports.FETCH_CACHE_HEADER = FETCH_CACHE_HEADER;\nvar RSC_VARY_HEADER = \"\".concat(RSC, \", \").concat(NEXT_ROUTER_STATE_TREE, \", \").concat(NEXT_ROUTER_PREFETCH);\nexports.RSC_VARY_HEADER = RSC_VARY_HEADER;\nvar FLIGHT_PARAMETERS = [[RSC], [NEXT_ROUTER_STATE_TREE], [NEXT_ROUTER_PREFETCH]];\nexports.FLIGHT_PARAMETERS = FLIGHT_PARAMETERS;\n\nif ((typeof exports[\"default\"] === 'function' || typeof exports[\"default\"] === 'object' && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === 'undefined') {\n  Object.defineProperty(exports[\"default\"], '__esModule', {\n    value: true\n  });\n  Object.assign(exports[\"default\"], exports);\n  module.exports = exports[\"default\"];\n}\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9hcHAtcm91dGVyLWhlYWRlcnMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBQ2JBLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBRGtDLENBQTdDO0FBR0FELHlCQUFBLEdBQTRCQSx1QkFBQSxHQUEwQkEsMEJBQUEsR0FBNkJBLDRCQUFBLEdBQStCQSw4QkFBQSxHQUFpQ0EsV0FBQSxHQUFjLEtBQUssQ0FBdEs7QUFDQSxJQUFNTyxHQUFHLEdBQUcsS0FBWjtBQUNBUCxXQUFBLEdBQWNPLEdBQWQ7QUFDQSxJQUFNRCxzQkFBc0IsR0FBRyx3QkFBL0I7QUFDQU4sOEJBQUEsR0FBaUNNLHNCQUFqQztBQUNBLElBQU1ELG9CQUFvQixHQUFHLHNCQUE3QjtBQUNBTCw0QkFBQSxHQUErQkssb0JBQS9CO0FBQ0EsSUFBTUQsa0JBQWtCLEdBQUcscUJBQTNCO0FBQ0FKLDBCQUFBLEdBQTZCSSxrQkFBN0I7QUFDQSxJQUFNRCxlQUFlLGFBQU1JLEdBQU4sZUFBY0Qsc0JBQWQsZUFBeUNELG9CQUF6QyxDQUFyQjtBQUNBTCx1QkFBQSxHQUEwQkcsZUFBMUI7QUFDQSxJQUFNRCxpQkFBaUIsR0FBRyxDQUN0QixDQUNJSyxHQURKLENBRHNCLEVBSXRCLENBQ0lELHNCQURKLENBSnNCLEVBT3RCLENBQ0lELG9CQURKLENBUHNCLENBQTFCO0FBV0FMLHlCQUFBLEdBQTRCRSxpQkFBNUI7O0FBRUEsSUFBSSxDQUFDLE9BQU9GLE9BQU8sV0FBZCxLQUEyQixVQUEzQixJQUEwQyxPQUFPQSxPQUFPLFdBQWQsS0FBMkIsUUFBM0IsSUFBdUNBLE9BQU8sV0FBUCxLQUFvQixJQUF0RyxLQUFnSCxPQUFPQSxPQUFPLFdBQVAsQ0FBZ0JRLFVBQXZCLEtBQXNDLFdBQTFKLEVBQXVLO0VBQ3JLVixNQUFNLENBQUNDLGNBQVAsQ0FBc0JDLE9BQU8sV0FBN0IsRUFBdUMsWUFBdkMsRUFBcUQ7SUFBRUMsS0FBSyxFQUFFO0VBQVQsQ0FBckQ7RUFDQUgsTUFBTSxDQUFDVyxNQUFQLENBQWNULE9BQU8sV0FBckIsRUFBK0JBLE9BQS9CO0VBQ0FVLE1BQU0sQ0FBQ1YsT0FBUCxHQUFpQkEsT0FBTyxXQUF4QjtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci1oZWFkZXJzLmpzPzM1NmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkZMSUdIVF9QQVJBTUVURVJTID0gZXhwb3J0cy5SU0NfVkFSWV9IRUFERVIgPSBleHBvcnRzLkZFVENIX0NBQ0hFX0hFQURFUiA9IGV4cG9ydHMuTkVYVF9ST1VURVJfUFJFRkVUQ0ggPSBleHBvcnRzLk5FWFRfUk9VVEVSX1NUQVRFX1RSRUUgPSBleHBvcnRzLlJTQyA9IHZvaWQgMDtcbmNvbnN0IFJTQyA9ICdSU0MnO1xuZXhwb3J0cy5SU0MgPSBSU0M7XG5jb25zdCBORVhUX1JPVVRFUl9TVEFURV9UUkVFID0gJ05leHQtUm91dGVyLVN0YXRlLVRyZWUnO1xuZXhwb3J0cy5ORVhUX1JPVVRFUl9TVEFURV9UUkVFID0gTkVYVF9ST1VURVJfU1RBVEVfVFJFRTtcbmNvbnN0IE5FWFRfUk9VVEVSX1BSRUZFVENIID0gJ05leHQtUm91dGVyLVByZWZldGNoJztcbmV4cG9ydHMuTkVYVF9ST1VURVJfUFJFRkVUQ0ggPSBORVhUX1JPVVRFUl9QUkVGRVRDSDtcbmNvbnN0IEZFVENIX0NBQ0hFX0hFQURFUiA9ICd4LXZlcmNlbC1zYy1oZWFkZXJzJztcbmV4cG9ydHMuRkVUQ0hfQ0FDSEVfSEVBREVSID0gRkVUQ0hfQ0FDSEVfSEVBREVSO1xuY29uc3QgUlNDX1ZBUllfSEVBREVSID0gYCR7UlNDfSwgJHtORVhUX1JPVVRFUl9TVEFURV9UUkVFfSwgJHtORVhUX1JPVVRFUl9QUkVGRVRDSH1gO1xuZXhwb3J0cy5SU0NfVkFSWV9IRUFERVIgPSBSU0NfVkFSWV9IRUFERVI7XG5jb25zdCBGTElHSFRfUEFSQU1FVEVSUyA9IFtcbiAgICBbXG4gICAgICAgIFJTQ1xuICAgIF0sXG4gICAgW1xuICAgICAgICBORVhUX1JPVVRFUl9TVEFURV9UUkVFXG4gICAgXSxcbiAgICBbXG4gICAgICAgIE5FWFRfUk9VVEVSX1BSRUZFVENIXG4gICAgXSwgXG5dO1xuZXhwb3J0cy5GTElHSFRfUEFSQU1FVEVSUyA9IEZMSUdIVF9QQVJBTUVURVJTO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAtcm91dGVyLWhlYWRlcnMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiRkxJR0hUX1BBUkFNRVRFUlMiLCJSU0NfVkFSWV9IRUFERVIiLCJGRVRDSF9DQUNIRV9IRUFERVIiLCJORVhUX1JPVVRFUl9QUkVGRVRDSCIsIk5FWFRfUk9VVEVSX1NUQVRFX1RSRUUiLCJSU0MiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/app-router-headers.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/app-router.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/components/app-router.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\"use client\";\n\"use strict\";\n\nvar _slicedToArray = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/slicedToArray.js */ \"(app-client)/./node_modules/next/dist/compiled/@babel/runtime/helpers/slicedToArray.js\");\n\nvar _regeneratorRuntime = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/regenerator/index.js */ \"(app-client)/./node_modules/next/dist/compiled/@babel/runtime/regenerator/index.js\");\n\nvar _defineProperty = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/defineProperty.js */ \"(app-client)/./node_modules/next/dist/compiled/@babel/runtime/helpers/defineProperty.js\");\n\nvar _s = $RefreshSig$();\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = AppRouter;\nexports.fetchServerResponse = fetchServerResponse;\n\nvar _async_to_generator = (__webpack_require__(/*! @swc/helpers/lib/_async_to_generator.js */ \"(app-client)/./node_modules/@swc/helpers/lib/_async_to_generator.js\")[\"default\"]);\n\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(app-client)/./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\n\nvar _object_without_properties_loose = (__webpack_require__(/*! @swc/helpers/lib/_object_without_properties_loose.js */ \"(app-client)/./node_modules/@swc/helpers/lib/_object_without_properties_loose.js\")[\"default\"]);\n\nvar _react = _interop_require_wildcard(__webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\"));\n\nvar _client = __webpack_require__(/*! next/dist/compiled/react-server-dom-webpack/client */ \"(app-client)/./node_modules/next/dist/compiled/react-server-dom-webpack/client.js\");\n\nvar _appRouterContext = __webpack_require__(/*! ../../shared/lib/app-router-context */ \"(app-client)/./node_modules/next/dist/shared/lib/app-router-context.js\");\n\nvar _reducer = __webpack_require__(/*! ./reducer */ \"(app-client)/./node_modules/next/dist/client/components/reducer.js\");\n\nvar _hooksClientContext = __webpack_require__(/*! ../../shared/lib/hooks-client-context */ \"(app-client)/./node_modules/next/dist/shared/lib/hooks-client-context.js\");\n\nvar _useReducerWithDevtools = __webpack_require__(/*! ./use-reducer-with-devtools */ \"(app-client)/./node_modules/next/dist/client/components/use-reducer-with-devtools.js\");\n\nvar _errorBoundary = __webpack_require__(/*! ./error-boundary */ \"(app-client)/./node_modules/next/dist/client/components/error-boundary.js\");\n\nvar _appRouterHeaders = __webpack_require__(/*! ./app-router-headers */ \"(app-client)/./node_modules/next/dist/client/components/app-router-headers.js\");\n\nfunction AppRouter(props) {\n  var globalErrorComponent = props.globalErrorComponent,\n      rest = _object_without_properties_loose(props, [\"globalErrorComponent\"]);\n\n  return /*#__PURE__*/_react[\"default\"].createElement(_errorBoundary.ErrorBoundary, {\n    errorComponent: globalErrorComponent\n  }, /*#__PURE__*/_react[\"default\"].createElement(Router, Object.assign({}, rest)));\n}\n\n_c = AppRouter;\n\nfunction urlToUrlWithoutFlightMarker(url) {\n  var urlWithoutFlightParameters = new URL(url, location.origin); // TODO-APP: handle .rsc for static export case\n\n  return urlWithoutFlightParameters;\n}\n\nvar HotReloader =  false ? 0 : (__webpack_require__(/*! ./react-dev-overlay/hot-reloader-client */ \"(app-client)/./node_modules/next/dist/client/components/react-dev-overlay/hot-reloader-client.js\")[\"default\"]);\n\nfunction fetchServerResponse(url, flightRouterState, prefetch) {\n  return _fetchServerResponse.apply(this, arguments);\n}\n\nfunction _fetchServerResponse() {\n  _fetchServerResponse = _async_to_generator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(url, flightRouterState, prefetch) {\n    var _headers;\n\n    var headers, res, canonicalUrl, isFlightResponse, flightData;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            headers = (_headers = {}, _defineProperty(_headers, _appRouterHeaders.RSC, '1'), _defineProperty(_headers, _appRouterHeaders.NEXT_ROUTER_STATE_TREE, JSON.stringify(flightRouterState)), _headers);\n\n            if (prefetch) {\n              // Enable prefetch response\n              headers[_appRouterHeaders.NEXT_ROUTER_PREFETCH] = '1';\n            }\n\n            _context.next = 4;\n            return fetch(url.toString(), {\n              headers: headers\n            });\n\n          case 4:\n            res = _context.sent;\n            canonicalUrl = res.redirected ? urlToUrlWithoutFlightMarker(res.url) : undefined;\n            isFlightResponse = res.headers.get('content-type') === 'application/octet-stream'; // If fetch returns something different than flight response handle it like a mpa navigation\n\n            if (isFlightResponse) {\n              _context.next = 9;\n              break;\n            }\n\n            return _context.abrupt(\"return\", [res.url, undefined]);\n\n          case 9:\n            _context.next = 11;\n            return (0, _client).createFromFetch(Promise.resolve(res));\n\n          case 11:\n            flightData = _context.sent;\n            return _context.abrupt(\"return\", [flightData, canonicalUrl]);\n\n          case 13:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _fetchServerResponse.apply(this, arguments);\n} // Ensure the initialParallelRoutes are not combined because of double-rendering in the browser with Strict Mode.\n\n\nvar initialParallelRoutes =  false ? 0 : new Map();\nvar prefetched = new Set();\n\nfunction findHeadInCache(cache, parallelRoutes) {\n  var isLastItem = Object.keys(parallelRoutes).length === 0;\n\n  if (isLastItem) {\n    return cache.head;\n  }\n\n  for (var key in parallelRoutes) {\n    var _parallelRoutes$key = _slicedToArray(parallelRoutes[key], 2),\n        segment = _parallelRoutes$key[0],\n        childParallelRoutes = _parallelRoutes$key[1];\n\n    var childSegmentMap = cache.parallelRoutes.get(key);\n\n    if (!childSegmentMap) {\n      continue;\n    }\n\n    var cacheKey = Array.isArray(segment) ? segment[1] : segment;\n    var cacheNode = childSegmentMap.get(cacheKey);\n\n    if (!cacheNode) {\n      continue;\n    }\n\n    var item = findHeadInCache(cacheNode, childParallelRoutes);\n\n    if (item) {\n      return item;\n    }\n  }\n\n  return undefined;\n}\n/**\n * The global router that wraps the application components.\n */\n\n\nfunction Router(_ref) {\n  _s();\n\n  var initialHead = _ref.initialHead,\n      initialTree = _ref.initialTree,\n      initialCanonicalUrl = _ref.initialCanonicalUrl,\n      children = _ref.children,\n      assetPrefix = _ref.assetPrefix;\n  var initialState = (0, _react).useMemo(function () {\n    return {\n      tree: initialTree,\n      cache: {\n        status: _appRouterContext.CacheStates.READY,\n        data: null,\n        subTreeData: children,\n        parallelRoutes:  false ? 0 : initialParallelRoutes\n      },\n      prefetchCache: new Map(),\n      pushRef: {\n        pendingPush: false,\n        mpaNavigation: false\n      },\n      focusAndScrollRef: {\n        apply: false\n      },\n      canonicalUrl: // location.href is read as the initial value for canonicalUrl in the browser\n      // This is safe to do as canonicalUrl can't be rendered, it's only used to control the history updates in the useEffect further down in this file.\n       true ? (0, _reducer).createHrefFromUrl(window.location) : 0\n    };\n  }, [children, initialCanonicalUrl, initialTree]);\n\n  var _useReducerWithReduxD = (0, _useReducerWithDevtools).useReducerWithReduxDevtools(_reducer.reducer, initialState),\n      _useReducerWithReduxD2 = _slicedToArray(_useReducerWithReduxD, 3),\n      _useReducerWithReduxD3 = _useReducerWithReduxD2[0],\n      tree = _useReducerWithReduxD3.tree,\n      cache = _useReducerWithReduxD3.cache,\n      prefetchCache = _useReducerWithReduxD3.prefetchCache,\n      pushRef = _useReducerWithReduxD3.pushRef,\n      focusAndScrollRef = _useReducerWithReduxD3.focusAndScrollRef,\n      canonicalUrl = _useReducerWithReduxD3.canonicalUrl,\n      dispatch = _useReducerWithReduxD2[1],\n      sync = _useReducerWithReduxD2[2];\n\n  var head = (0, _react).useMemo(function () {\n    return findHeadInCache(cache, tree[1]);\n  }, [cache, tree]);\n  (0, _react).useEffect(function () {\n    // Ensure initialParallelRoutes is cleaned up from memory once it's used.\n    initialParallelRoutes = null;\n  }, []); // Add memoized pathname/query for useSearchParams and usePathname.\n\n  var _useMemo = (0, _react).useMemo(function () {\n    var url = new URL(canonicalUrl,  false ? 0 : window.location.href);\n    return {\n      // This is turned into a readonly class in `useSearchParams`\n      searchParams: url.searchParams,\n      pathname: url.pathname\n    };\n  }, [canonicalUrl]),\n      searchParams = _useMemo.searchParams,\n      pathname = _useMemo.pathname;\n  /**\n  * Server response that only patches the cache and tree.\n  */\n\n\n  var changeByServerResponse = (0, _react).useCallback(function (previousTree, flightData, overrideCanonicalUrl) {\n    dispatch({\n      type: _reducer.ACTION_SERVER_PATCH,\n      flightData: flightData,\n      previousTree: previousTree,\n      overrideCanonicalUrl: overrideCanonicalUrl,\n      cache: {\n        status: _appRouterContext.CacheStates.LAZY_INITIALIZED,\n        data: null,\n        subTreeData: null,\n        parallelRoutes: new Map()\n      },\n      mutable: {}\n    });\n  }, [dispatch]);\n  /**\n  * The app router that is exposed through `useRouter`. It's only concerned with dispatching actions to the reducer, does not hold state.\n  */\n\n  var appRouter = (0, _react).useMemo(function () {\n    var navigate = function navigate(href, navigateType, forceOptimisticNavigation) {\n      return dispatch({\n        type: _reducer.ACTION_NAVIGATE,\n        url: new URL(href, location.origin),\n        forceOptimisticNavigation: forceOptimisticNavigation,\n        navigateType: navigateType,\n        cache: {\n          status: _appRouterContext.CacheStates.LAZY_INITIALIZED,\n          data: null,\n          subTreeData: null,\n          parallelRoutes: new Map()\n        },\n        mutable: {}\n      });\n    };\n\n    var routerInstance = {\n      back: function back() {\n        return window.history.back();\n      },\n      forward: function forward() {\n        return window.history.forward();\n      },\n      prefetch: _async_to_generator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(href) {\n        var url, ref, routerTree, serverResponse;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!prefetched.has(href)) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 2:\n                prefetched.add(href);\n                url = new URL(href, location.origin);\n                _context2.prev = 4;\n                routerTree = ((ref = window.history.state) == null ? void 0 : ref.tree) || initialTree;\n                _context2.next = 8;\n                return fetchServerResponse(url, // initialTree is used when history.state.tree is missing because the history state is set in `useEffect` below, it being missing means this is the hydration case.\n                routerTree, true);\n\n              case 8:\n                serverResponse = _context2.sent;\n\n                // @ts-ignore startTransition exists\n                _react[\"default\"].startTransition(function () {\n                  dispatch({\n                    type: _reducer.ACTION_PREFETCH,\n                    url: url,\n                    tree: routerTree,\n                    serverResponse: serverResponse\n                  });\n                });\n\n                _context2.next = 15;\n                break;\n\n              case 12:\n                _context2.prev = 12;\n                _context2.t0 = _context2[\"catch\"](4);\n                console.error('PREFETCH ERROR', _context2.t0);\n\n              case 15:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[4, 12]]);\n      })),\n      replace: function replace(href) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        // @ts-ignore startTransition exists\n        _react[\"default\"].startTransition(function () {\n          navigate(href, 'replace', Boolean(options.forceOptimisticNavigation));\n        });\n      },\n      push: function push(href) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        // @ts-ignore startTransition exists\n        _react[\"default\"].startTransition(function () {\n          navigate(href, 'push', Boolean(options.forceOptimisticNavigation));\n        });\n      },\n      refresh: function refresh() {\n        // @ts-ignore startTransition exists\n        _react[\"default\"].startTransition(function () {\n          dispatch({\n            type: _reducer.ACTION_REFRESH,\n            cache: {\n              status: _appRouterContext.CacheStates.LAZY_INITIALIZED,\n              data: null,\n              subTreeData: null,\n              parallelRoutes: new Map()\n            },\n            mutable: {}\n          });\n        });\n      }\n    };\n    return routerInstance;\n  }, [dispatch, initialTree]);\n  (0, _react).useEffect(function () {\n    // When mpaNavigation flag is set do a hard navigation to the new url.\n    if (pushRef.mpaNavigation) {\n      window.location.href = canonicalUrl;\n      return;\n    } // Identifier is shortened intentionally.\n    // __NA is used to identify if the history entry can be handled by the app-router.\n    // __N is used to identify if the history entry can be handled by the old router.\n\n\n    var historyState = {\n      __NA: true,\n      tree: tree\n    };\n\n    if (pushRef.pendingPush && (0, _reducer).createHrefFromUrl(new URL(window.location.href)) !== canonicalUrl) {\n      // This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.\n      pushRef.pendingPush = false;\n      window.history.pushState(historyState, '', canonicalUrl);\n    } else {\n      window.history.replaceState(historyState, '', canonicalUrl);\n    }\n\n    sync();\n  }, [tree, pushRef, canonicalUrl, sync]); // Add `window.nd` for debugging purposes.\n  // This is not meant for use in applications as concurrent rendering will affect the cache/tree/router.\n\n  if (true) {\n    // @ts-ignore this is for debugging\n    window.nd = {\n      router: appRouter,\n      cache: cache,\n      prefetchCache: prefetchCache,\n      tree: tree\n    };\n  }\n  /**\n  * Handle popstate event, this is used to handle back/forward in the browser.\n  * By default dispatches ACTION_RESTORE, however if the history entry was not pushed/replaced by app-router it will reload the page.\n  * That case can happen when the old router injected the history entry.\n  */\n\n\n  var onPopState = (0, _react).useCallback(function (_ref2) {\n    var state = _ref2.state;\n\n    if (!state) {\n      // TODO-APP: this case only happens when pushState/replaceState was called outside of Next.js. It should probably reload the page in this case.\n      return;\n    } // This case happens when the history entry was pushed by the `pages` router.\n\n\n    if (!state.__NA) {\n      window.location.reload();\n      return;\n    } // @ts-ignore useTransition exists\n    // TODO-APP: Ideally the back button should not use startTransition as it should apply the updates synchronously\n    // Without startTransition works if the cache is there for this path\n\n\n    _react[\"default\"].startTransition(function () {\n      dispatch({\n        type: _reducer.ACTION_RESTORE,\n        url: new URL(window.location.href),\n        tree: state.tree\n      });\n    });\n  }, [dispatch]); // Register popstate event to call onPopstate.\n\n  (0, _react).useEffect(function () {\n    window.addEventListener('popstate', onPopState);\n    return function () {\n      window.removeEventListener('popstate', onPopState);\n    };\n  }, [onPopState]);\n\n  var content = /*#__PURE__*/_react[\"default\"].createElement(_react[\"default\"].Fragment, null, head || initialHead, cache.subTreeData);\n\n  return /*#__PURE__*/_react[\"default\"].createElement(_hooksClientContext.PathnameContext.Provider, {\n    value: pathname\n  }, /*#__PURE__*/_react[\"default\"].createElement(_hooksClientContext.SearchParamsContext.Provider, {\n    value: searchParams\n  }, /*#__PURE__*/_react[\"default\"].createElement(_appRouterContext.GlobalLayoutRouterContext.Provider, {\n    value: {\n      changeByServerResponse: changeByServerResponse,\n      tree: tree,\n      focusAndScrollRef: focusAndScrollRef\n    }\n  }, /*#__PURE__*/_react[\"default\"].createElement(_appRouterContext.AppRouterContext.Provider, {\n    value: appRouter\n  }, /*#__PURE__*/_react[\"default\"].createElement(_appRouterContext.LayoutRouterContext.Provider, {\n    value: {\n      childNodes: cache.parallelRoutes,\n      tree: tree,\n      // Root node always has `url`\n      // Provided in AppTreeContext to ensure it can be overwritten in layout-router\n      url: canonicalUrl\n    }\n  }, HotReloader ? /*#__PURE__*/_react[\"default\"].createElement(HotReloader, {\n    assetPrefix: assetPrefix\n  }, content) : content)))));\n}\n\n_s(Router, \"E4Qd1Kk83CxC+YgSLfkcNAcoSWY=\", true);\n\n_c2 = Router;\n\nif ((typeof exports[\"default\"] === 'function' || typeof exports[\"default\"] === 'object' && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === 'undefined') {\n  Object.defineProperty(exports[\"default\"], '__esModule', {\n    value: true\n  });\n  Object.assign(exports[\"default\"], exports);\n  module.exports = exports[\"default\"];\n}\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"AppRouter\");\n$RefreshReg$(_c2, \"Router\");\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9hcHAtcm91dGVyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Ozs7Ozs7Ozs7QUFDQUEsOENBQTZDO0VBQ3pDRyxLQUFLLEVBQUU7QUFEa0MsQ0FBN0M7QUFHQUQsa0JBQUEsR0FBa0JFLFNBQWxCO0FBQ0FGLDJCQUFBLEdBQThCRyxtQkFBOUI7O0FBQ0EsSUFBSUMsbUJBQW1CLEdBQUdDLHNKQUExQjs7QUFDQSxJQUFJQyx5QkFBeUIsR0FBR0Qsa0tBQWhDOztBQUNBLElBQUlFLGdDQUFnQyxHQUFHRixnTEFBdkM7O0FBQ0EsSUFBSUcsTUFBTSxHQUFHRix5QkFBeUIsQ0FBQ0QsbUJBQU8sQ0FBQyw0RUFBRCxDQUFSLENBQXRDOztBQUNBLElBQUlJLE9BQU8sR0FBR0osbUJBQU8sQ0FBQyw2SUFBRCxDQUFyQjs7QUFDQSxJQUFJSyxpQkFBaUIsR0FBR0wsbUJBQU8sQ0FBQyxtSEFBRCxDQUEvQjs7QUFDQSxJQUFJTSxRQUFRLEdBQUdOLG1CQUFPLENBQUMscUZBQUQsQ0FBdEI7O0FBQ0EsSUFBSU8sbUJBQW1CLEdBQUdQLG1CQUFPLENBQUMsdUhBQUQsQ0FBakM7O0FBQ0EsSUFBSVEsdUJBQXVCLEdBQUdSLG1CQUFPLENBQUMseUhBQUQsQ0FBckM7O0FBQ0EsSUFBSVMsY0FBYyxHQUFHVCxtQkFBTyxDQUFDLG1HQUFELENBQTVCOztBQUNBLElBQUlVLGlCQUFpQixHQUFHVixtQkFBTyxDQUFDLDJHQUFELENBQS9COztBQUNBLFNBQVNILFNBQVQsQ0FBbUJjLEtBQW5CLEVBQTBCO0VBQ2hCLElBQUVDLG9CQUFGLEdBQTRCRCxLQUE1QixDQUFFQyxvQkFBRjtFQUFBLElBQW1DQyxJQUFuQyxHQUEwQ1gsZ0NBQWdDLENBQUNTLEtBQUQsRUFBUSxDQUNwRixzQkFEb0YsQ0FBUixDQUExRTs7RUFHTixPQUFPLGFBQWNSLE1BQU0sV0FBTixDQUFlVyxhQUFmLENB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LE9BQVAsR0FBaUJBLE9BQU8sV0FBeEI7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2FwcC1yb3V0ZXIuanM/NDE1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQXBwUm91dGVyO1xuZXhwb3J0cy5mZXRjaFNlcnZlclJlc3BvbnNlID0gZmV0Y2hTZXJ2ZXJSZXNwb25zZTtcbnZhciBfYXN5bmNfdG9fZ2VuZXJhdG9yID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2FzeW5jX3RvX2dlbmVyYXRvci5qc1wiKS5kZWZhdWx0O1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLmpzXCIpLmRlZmF1bHQ7XG52YXIgX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9fb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZS5qc1wiKS5kZWZhdWx0O1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfY2xpZW50ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50XCIpO1xudmFyIF9hcHBSb3V0ZXJDb250ZXh0ID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0XCIpO1xudmFyIF9yZWR1Y2VyID0gcmVxdWlyZShcIi4vcmVkdWNlclwiKTtcbnZhciBfaG9va3NDbGllbnRDb250ZXh0ID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvaG9va3MtY2xpZW50LWNvbnRleHRcIik7XG52YXIgX3VzZVJlZHVjZXJXaXRoRGV2dG9vbHMgPSByZXF1aXJlKFwiLi91c2UtcmVkdWNlci13aXRoLWRldnRvb2xzXCIpO1xudmFyIF9lcnJvckJvdW5kYXJ5ID0gcmVxdWlyZShcIi4vZXJyb3ItYm91bmRhcnlcIik7XG52YXIgX2FwcFJvdXRlckhlYWRlcnMgPSByZXF1aXJlKFwiLi9hcHAtcm91dGVyLWhlYWRlcnNcIik7XG5mdW5jdGlvbiBBcHBSb3V0ZXIocHJvcHMpIHtcbiAgICBjb25zdCB7IGdsb2JhbEVycm9yQ29tcG9uZW50ICB9ID0gcHJvcHMsIHJlc3QgPSBfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZShwcm9wcywgW1xuICAgICAgICBcImdsb2JhbEVycm9yQ29tcG9uZW50XCJcbiAgICBdKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9lcnJvckJvdW5kYXJ5LkVycm9yQm91bmRhcnksIHtcbiAgICAgICAgZXJyb3JDb21wb25lbnQ6IGdsb2JhbEVycm9yQ29tcG9uZW50XG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJvdXRlciwgT2JqZWN0LmFzc2lnbih7fSwgcmVzdCkpKTtcbn1cblxuZnVuY3Rpb24gdXJsVG9VcmxXaXRob3V0RmxpZ2h0TWFya2VyKHVybCkge1xuICAgIGNvbnN0IHVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzID0gbmV3IFVSTCh1cmwsIGxvY2F0aW9uLm9yaWdpbik7XG4gICAgLy8gVE9ETy1BUFA6IGhhbmRsZSAucnNjIGZvciBzdGF0aWMgZXhwb3J0IGNhc2VcbiAgICByZXR1cm4gdXJsV2l0aG91dEZsaWdodFBhcmFtZXRlcnM7XG59XG5jb25zdCBIb3RSZWxvYWRlciA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgPyBudWxsIDogcmVxdWlyZSgnLi9yZWFjdC1kZXYtb3ZlcmxheS9ob3QtcmVsb2FkZXItY2xpZW50JykuZGVmYXVsdDtcbmZ1bmN0aW9uIGZldGNoU2VydmVyUmVzcG9uc2UodXJsLCBmbGlnaHRSb3V0ZXJTdGF0ZSwgcHJlZmV0Y2gpIHtcbiAgICByZXR1cm4gX2ZldGNoU2VydmVyUmVzcG9uc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9mZXRjaFNlcnZlclJlc3BvbnNlKCkge1xuICAgIF9mZXRjaFNlcnZlclJlc3BvbnNlID0gX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbioodXJsLCBmbGlnaHRSb3V0ZXJTdGF0ZSwgcHJlZmV0Y2gpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIC8vIEVuYWJsZSBmbGlnaHQgcmVzcG9uc2VcbiAgICAgICAgICAgIFtfYXBwUm91dGVySGVhZGVycy5SU0NdOiAnMScsXG4gICAgICAgICAgICAvLyBQcm92aWRlIHRoZSBjdXJyZW50IHJvdXRlciBzdGF0ZVxuICAgICAgICAgICAgW19hcHBSb3V0ZXJIZWFkZXJzLk5FWFRfUk9VVEVSX1NUQVRFX1RSRUVdOiBKU09OLnN0cmluZ2lmeShmbGlnaHRSb3V0ZXJTdGF0ZSlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHByZWZldGNoKSB7XG4gICAgICAgICAgICAvLyBFbmFibGUgcHJlZmV0Y2ggcmVzcG9uc2VcbiAgICAgICAgICAgIGhlYWRlcnNbX2FwcFJvdXRlckhlYWRlcnMuTkVYVF9ST1VURVJfUFJFRkVUQ0hdID0gJzEnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IHlpZWxkIGZldGNoKHVybC50b1N0cmluZygpLCB7XG4gICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjYW5vbmljYWxVcmwgPSByZXMucmVkaXJlY3RlZCA/IHVybFRvVXJsV2l0aG91dEZsaWdodE1hcmtlcihyZXMudXJsKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgaXNGbGlnaHRSZXNwb25zZSA9IHJlcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuICAgICAgICAvLyBJZiBmZXRjaCByZXR1cm5zIHNvbWV0aGluZyBkaWZmZXJlbnQgdGhhbiBmbGlnaHQgcmVzcG9uc2UgaGFuZGxlIGl0IGxpa2UgYSBtcGEgbmF2aWdhdGlvblxuICAgICAgICBpZiAoIWlzRmxpZ2h0UmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgcmVzLnVybCxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWRcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIHRoZSBgZmV0Y2hgIHJlYWRhYmxlIHN0cmVhbSB0aGF0IGNhbiBiZSB1bndyYXBwZWQgYnkgYFJlYWN0LnVzZWAuXG4gICAgICAgIGNvbnN0IGZsaWdodERhdGEgPSB5aWVsZCAoMCwgX2NsaWVudCkuY3JlYXRlRnJvbUZldGNoKFByb21pc2UucmVzb2x2ZShyZXMpKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGZsaWdodERhdGEsXG4gICAgICAgICAgICBjYW5vbmljYWxVcmxcbiAgICAgICAgXTtcbiAgICB9KTtcbiAgICByZXR1cm4gX2ZldGNoU2VydmVyUmVzcG9uc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbi8vIEVuc3VyZSB0aGUgaW5pdGlhbFBhcmFsbGVsUm91dGVzIGFyZSBub3QgY29tYmluZWQgYmVjYXVzZSBvZiBkb3VibGUtcmVuZGVyaW5nIGluIHRoZSBicm93c2VyIHdpdGggU3RyaWN0IE1vZGUuXG5sZXQgaW5pdGlhbFBhcmFsbGVsUm91dGVzID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogbmV3IE1hcCgpO1xuY29uc3QgcHJlZmV0Y2hlZCA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIGZpbmRIZWFkSW5DYWNoZShjYWNoZSwgcGFyYWxsZWxSb3V0ZXMpIHtcbiAgICBjb25zdCBpc0xhc3RJdGVtID0gT2JqZWN0LmtleXMocGFyYWxsZWxSb3V0ZXMpLmxlbmd0aCA9PT0gMDtcbiAgICBpZiAoaXNMYXN0SXRlbSkge1xuICAgICAgICByZXR1cm4gY2FjaGUuaGVhZDtcbiAgICB9XG4gICAgZm9yKGNvbnN0IGtleSBpbiBwYXJhbGxlbFJvdXRlcyl7XG4gICAgICAgIGNvbnN0IFtzZWdtZW50LCBjaGlsZFBhcmFsbGVsUm91dGVzXSA9IHBhcmFsbGVsUm91dGVzW2tleV07XG4gICAgICAgIGNvbnN0IGNoaWxkU2VnbWVudE1hcCA9IGNhY2hlLnBhcmFsbGVsUm91dGVzLmdldChrZXkpO1xuICAgICAgICBpZiAoIWNoaWxkU2VnbWVudE1hcCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBBcnJheS5pc0FycmF5KHNlZ21lbnQpID8gc2VnbWVudFsxXSA6IHNlZ21lbnQ7XG4gICAgICAgIGNvbnN0IGNhY2hlTm9kZSA9IGNoaWxkU2VnbWVudE1hcC5nZXQoY2FjaGVLZXkpO1xuICAgICAgICBpZiAoIWNhY2hlTm9kZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbSA9IGZpbmRIZWFkSW5DYWNoZShjYWNoZU5vZGUsIGNoaWxkUGFyYWxsZWxSb3V0ZXMpO1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8qKlxuICogVGhlIGdsb2JhbCByb3V0ZXIgdGhhdCB3cmFwcyB0aGUgYXBwbGljYXRpb24gY29tcG9uZW50cy5cbiAqLyBmdW5jdGlvbiBSb3V0ZXIoeyBpbml0aWFsSGVhZCAsIGluaXRpYWxUcmVlICwgaW5pdGlhbENhbm9uaWNhbFVybCAsIGNoaWxkcmVuICwgYXNzZXRQcmVmaXggIH0pIHtcbiAgICBjb25zdCBpbml0aWFsU3RhdGUgPSAoMCwgX3JlYWN0KS51c2VNZW1vKCgpPT57XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0cmVlOiBpbml0aWFsVHJlZSxcbiAgICAgICAgICAgIGNhY2hlOiB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5SRUFEWSxcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIHN1YlRyZWVEYXRhOiBjaGlsZHJlbixcbiAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBuZXcgTWFwKCkgOiBpbml0aWFsUGFyYWxsZWxSb3V0ZXNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVmZXRjaENhY2hlOiBuZXcgTWFwKCksXG4gICAgICAgICAgICBwdXNoUmVmOiB7XG4gICAgICAgICAgICAgICAgcGVuZGluZ1B1c2g6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1wYU5hdmlnYXRpb246IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHtcbiAgICAgICAgICAgICAgICBhcHBseTogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYW5vbmljYWxVcmw6IC8vIGxvY2F0aW9uLmhyZWYgaXMgcmVhZCBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBmb3IgY2Fub25pY2FsVXJsIGluIHRoZSBicm93c2VyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHNhZmUgdG8gZG8gYXMgY2Fub25pY2FsVXJsIGNhbid0IGJlIHJlbmRlcmVkLCBpdCdzIG9ubHkgdXNlZCB0byBjb250cm9sIHRoZSBoaXN0b3J5IHVwZGF0ZXMgaW4gdGhlIHVzZUVmZmVjdCBmdXJ0aGVyIGRvd24gaW4gdGhpcyBmaWxlLlxuICAgICAgICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyAoMCwgX3JlZHVjZXIpLmNyZWF0ZUhyZWZGcm9tVXJsKHdpbmRvdy5sb2NhdGlvbikgOiBpbml0aWFsQ2Fub25pY2FsVXJsXG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgaW5pdGlhbENhbm9uaWNhbFVybCxcbiAgICAgICAgaW5pdGlhbFRyZWVcbiAgICBdKTtcbiAgICBjb25zdCBbeyB0cmVlICwgY2FjaGUgLCBwcmVmZXRjaENhY2hlICwgcHVzaFJlZiAsIGZvY3VzQW5kU2Nyb2xsUmVmICwgY2Fub25pY2FsVXJsICB9LCBkaXNwYXRjaCwgc3luYywgXSA9ICgwLCBfdXNlUmVkdWNlcldpdGhEZXZ0b29scykudXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzKF9yZWR1Y2VyLnJlZHVjZXIsIGluaXRpYWxTdGF0ZSk7XG4gICAgY29uc3QgaGVhZCA9ICgwLCBfcmVhY3QpLnVzZU1lbW8oKCk9PntcbiAgICAgICAgcmV0dXJuIGZpbmRIZWFkSW5DYWNoZShjYWNoZSwgdHJlZVsxXSk7XG4gICAgfSwgW1xuICAgICAgICBjYWNoZSxcbiAgICAgICAgdHJlZVxuICAgIF0pO1xuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICAvLyBFbnN1cmUgaW5pdGlhbFBhcmFsbGVsUm91dGVzIGlzIGNsZWFuZWQgdXAgZnJvbSBtZW1vcnkgb25jZSBpdCdzIHVzZWQuXG4gICAgICAgIGluaXRpYWxQYXJhbGxlbFJvdXRlcyA9IG51bGw7XG4gICAgfSwgW10pO1xuICAgIC8vIEFkZCBtZW1vaXplZCBwYXRobmFtZS9xdWVyeSBmb3IgdXNlU2VhcmNoUGFyYW1zIGFuZCB1c2VQYXRobmFtZS5cbiAgICBjb25zdCB7IHNlYXJjaFBhcmFtcyAsIHBhdGhuYW1lICB9ID0gKDAsIF9yZWFjdCkudXNlTWVtbygoKT0+e1xuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGNhbm9uaWNhbFVybCwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAnaHR0cDovL24nIDogd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0dXJuZWQgaW50byBhIHJlYWRvbmx5IGNsYXNzIGluIGB1c2VTZWFyY2hQYXJhbXNgXG4gICAgICAgICAgICBzZWFyY2hQYXJhbXM6IHVybC5zZWFyY2hQYXJhbXMsXG4gICAgICAgICAgICBwYXRobmFtZTogdXJsLnBhdGhuYW1lXG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBjYW5vbmljYWxVcmxcbiAgICBdKTtcbiAgICAvKipcbiAgICogU2VydmVyIHJlc3BvbnNlIHRoYXQgb25seSBwYXRjaGVzIHRoZSBjYWNoZSBhbmQgdHJlZS5cbiAgICovIGNvbnN0IGNoYW5nZUJ5U2VydmVyUmVzcG9uc2UgPSAoMCwgX3JlYWN0KS51c2VDYWxsYmFjaygocHJldmlvdXNUcmVlLCBmbGlnaHREYXRhLCBvdmVycmlkZUNhbm9uaWNhbFVybCk9PntcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogX3JlZHVjZXIuQUNUSU9OX1NFUlZFUl9QQVRDSCxcbiAgICAgICAgICAgIGZsaWdodERhdGEsXG4gICAgICAgICAgICBwcmV2aW91c1RyZWUsXG4gICAgICAgICAgICBvdmVycmlkZUNhbm9uaWNhbFVybCxcbiAgICAgICAgICAgIGNhY2hlOiB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5MQVpZX0lOSVRJQUxJWkVELFxuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgc3ViVHJlZURhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG11dGFibGU6IHt9XG4gICAgICAgIH0pO1xuICAgIH0sIFtcbiAgICAgICAgZGlzcGF0Y2hcbiAgICBdKTtcbiAgICAvKipcbiAgICogVGhlIGFwcCByb3V0ZXIgdGhhdCBpcyBleHBvc2VkIHRocm91Z2ggYHVzZVJvdXRlcmAuIEl0J3Mgb25seSBjb25jZXJuZWQgd2l0aCBkaXNwYXRjaGluZyBhY3Rpb25zIHRvIHRoZSByZWR1Y2VyLCBkb2VzIG5vdCBob2xkIHN0YXRlLlxuICAgKi8gY29uc3QgYXBwUm91dGVyID0gKDAsIF9yZWFjdCkudXNlTWVtbygoKT0+e1xuICAgICAgICBjb25zdCBuYXZpZ2F0ZSA9IChocmVmLCBuYXZpZ2F0ZVR5cGUsIGZvcmNlT3B0aW1pc3RpY05hdmlnYXRpb24pPT57XG4gICAgICAgICAgICByZXR1cm4gZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IF9yZWR1Y2VyLkFDVElPTl9OQVZJR0FURSxcbiAgICAgICAgICAgICAgICB1cmw6IG5ldyBVUkwoaHJlZiwgbG9jYXRpb24ub3JpZ2luKSxcbiAgICAgICAgICAgICAgICBmb3JjZU9wdGltaXN0aWNOYXZpZ2F0aW9uLFxuICAgICAgICAgICAgICAgIG5hdmlnYXRlVHlwZSxcbiAgICAgICAgICAgICAgICBjYWNoZToge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLkxBWllfSU5JVElBTElaRUQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHN1YlRyZWVEYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtdXRhYmxlOiB7fVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJvdXRlckluc3RhbmNlID0ge1xuICAgICAgICAgICAgYmFjazogKCk9PndpbmRvdy5oaXN0b3J5LmJhY2soKSxcbiAgICAgICAgICAgIGZvcndhcmQ6ICgpPT53aW5kb3cuaGlzdG9yeS5mb3J3YXJkKCksXG4gICAgICAgICAgICBwcmVmZXRjaDogX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbiooaHJlZikge1xuICAgICAgICAgICAgICAgIC8vIElmIHByZWZldGNoIGhhcyBhbHJlYWR5IGJlZW4gdHJpZ2dlcmVkLCBkb24ndCB0cmlnZ2VyIGl0IGFnYWluLlxuICAgICAgICAgICAgICAgIGlmIChwcmVmZXRjaGVkLmhhcyhocmVmKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZWZldGNoZWQuYWRkKGhyZWYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoaHJlZiwgbG9jYXRpb24ub3JpZ2luKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByb3V0ZXJUcmVlID0gKChyZWYgPSB3aW5kb3cuaGlzdG9yeS5zdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi50cmVlKSB8fCBpbml0aWFsVHJlZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VydmVyUmVzcG9uc2UgPSB5aWVsZCBmZXRjaFNlcnZlclJlc3BvbnNlKHVybCwgLy8gaW5pdGlhbFRyZWUgaXMgdXNlZCB3aGVuIGhpc3Rvcnkuc3RhdGUudHJlZSBpcyBtaXNzaW5nIGJlY2F1c2UgdGhlIGhpc3Rvcnkgc3RhdGUgaXMgc2V0IGluIGB1c2VFZmZlY3RgIGJlbG93LCBpdCBiZWluZyBtaXNzaW5nIG1lYW5zIHRoaXMgaXMgdGhlIGh5ZHJhdGlvbiBjYXNlLlxuICAgICAgICAgICAgICAgICAgICByb3V0ZXJUcmVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBzdGFydFRyYW5zaXRpb24gZXhpc3RzXG4gICAgICAgICAgICAgICAgICAgIF9yZWFjdC5kZWZhdWx0LnN0YXJ0VHJhbnNpdGlvbigoKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IF9yZWR1Y2VyLkFDVElPTl9QUkVGRVRDSCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJlZTogcm91dGVyVHJlZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJSZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQUkVGRVRDSCBFUlJPUicsIGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICByZXBsYWNlOiAoaHJlZiwgb3B0aW9ucyA9IHt9KT0+e1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgc3RhcnRUcmFuc2l0aW9uIGV4aXN0c1xuICAgICAgICAgICAgICAgIF9yZWFjdC5kZWZhdWx0LnN0YXJ0VHJhbnNpdGlvbigoKT0+e1xuICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZShocmVmLCAncmVwbGFjZScsIEJvb2xlYW4ob3B0aW9ucy5mb3JjZU9wdGltaXN0aWNOYXZpZ2F0aW9uKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHVzaDogKGhyZWYsIG9wdGlvbnMgPSB7fSk9PntcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIHN0YXJ0VHJhbnNpdGlvbiBleGlzdHNcbiAgICAgICAgICAgICAgICBfcmVhY3QuZGVmYXVsdC5zdGFydFRyYW5zaXRpb24oKCk9PntcbiAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGUoaHJlZiwgJ3B1c2gnLCBCb29sZWFuKG9wdGlvbnMuZm9yY2VPcHRpbWlzdGljTmF2aWdhdGlvbikpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlZnJlc2g6ICgpPT57XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBzdGFydFRyYW5zaXRpb24gZXhpc3RzXG4gICAgICAgICAgICAgICAgX3JlYWN0LmRlZmF1bHQuc3RhcnRUcmFuc2l0aW9uKCgpPT57XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IF9yZWR1Y2VyLkFDVElPTl9SRUZSRVNILFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLkxBWllfSU5JVElBTElaRUQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlRGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YWJsZToge31cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByb3V0ZXJJbnN0YW5jZTtcbiAgICB9LCBbXG4gICAgICAgIGRpc3BhdGNoLFxuICAgICAgICBpbml0aWFsVHJlZVxuICAgIF0pO1xuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICAvLyBXaGVuIG1wYU5hdmlnYXRpb24gZmxhZyBpcyBzZXQgZG8gYSBoYXJkIG5hdmlnYXRpb24gdG8gdGhlIG5ldyB1cmwuXG4gICAgICAgIGlmIChwdXNoUmVmLm1wYU5hdmlnYXRpb24pIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gY2Fub25pY2FsVXJsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElkZW50aWZpZXIgaXMgc2hvcnRlbmVkIGludGVudGlvbmFsbHkuXG4gICAgICAgIC8vIF9fTkEgaXMgdXNlZCB0byBpZGVudGlmeSBpZiB0aGUgaGlzdG9yeSBlbnRyeSBjYW4gYmUgaGFuZGxlZCBieSB0aGUgYXBwLXJvdXRlci5cbiAgICAgICAgLy8gX19OIGlzIHVzZWQgdG8gaWRlbnRpZnkgaWYgdGhlIGhpc3RvcnkgZW50cnkgY2FuIGJlIGhhbmRsZWQgYnkgdGhlIG9sZCByb3V0ZXIuXG4gICAgICAgIGNvbnN0IGhpc3RvcnlTdGF0ZSA9IHtcbiAgICAgICAgICAgIF9fTkE6IHRydWUsXG4gICAgICAgICAgICB0cmVlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwdXNoUmVmLnBlbmRpbmdQdXNoICYmICgwLCBfcmVkdWNlcikuY3JlYXRlSHJlZkZyb21VcmwobmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZikpICE9PSBjYW5vbmljYWxVcmwpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaW50ZW50aW9uYWxseSBtdXRhdGVzIFJlYWN0IHN0YXRlLCBwdXNoUmVmIGlzIG92ZXJ3cml0dGVuIHRvIGVuc3VyZSBhZGRpdGlvbmFsIHB1c2gvcmVwbGFjZSBjYWxscyBkbyBub3QgdHJpZ2dlciBhbiBhZGRpdGlvbmFsIGhpc3RvcnkgZW50cnkuXG4gICAgICAgICAgICBwdXNoUmVmLnBlbmRpbmdQdXNoID0gZmFsc2U7XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoaGlzdG9yeVN0YXRlLCAnJywgY2Fub25pY2FsVXJsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShoaXN0b3J5U3RhdGUsICcnLCBjYW5vbmljYWxVcmwpO1xuICAgICAgICB9XG4gICAgICAgIHN5bmMoKTtcbiAgICB9LCBbXG4gICAgICAgIHRyZWUsXG4gICAgICAgIHB1c2hSZWYsXG4gICAgICAgIGNhbm9uaWNhbFVybCxcbiAgICAgICAgc3luY1xuICAgIF0pO1xuICAgIC8vIEFkZCBgd2luZG93Lm5kYCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxuICAgIC8vIFRoaXMgaXMgbm90IG1lYW50IGZvciB1c2UgaW4gYXBwbGljYXRpb25zIGFzIGNvbmN1cnJlbnQgcmVuZGVyaW5nIHdpbGwgYWZmZWN0IHRoZSBjYWNoZS90cmVlL3JvdXRlci5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZSB0aGlzIGlzIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgd2luZG93Lm5kID0ge1xuICAgICAgICAgICAgcm91dGVyOiBhcHBSb3V0ZXIsXG4gICAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICAgIHByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICB0cmVlXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgKiBIYW5kbGUgcG9wc3RhdGUgZXZlbnQsIHRoaXMgaXMgdXNlZCB0byBoYW5kbGUgYmFjay9mb3J3YXJkIGluIHRoZSBicm93c2VyLlxuICAgKiBCeSBkZWZhdWx0IGRpc3BhdGNoZXMgQUNUSU9OX1JFU1RPUkUsIGhvd2V2ZXIgaWYgdGhlIGhpc3RvcnkgZW50cnkgd2FzIG5vdCBwdXNoZWQvcmVwbGFjZWQgYnkgYXBwLXJvdXRlciBpdCB3aWxsIHJlbG9hZCB0aGUgcGFnZS5cbiAgICogVGhhdCBjYXNlIGNhbiBoYXBwZW4gd2hlbiB0aGUgb2xkIHJvdXRlciBpbmplY3RlZCB0aGUgaGlzdG9yeSBlbnRyeS5cbiAgICovIGNvbnN0IG9uUG9wU3RhdGUgPSAoMCwgX3JlYWN0KS51c2VDYWxsYmFjaygoeyBzdGF0ZSAgfSk9PntcbiAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgLy8gVE9ETy1BUFA6IHRoaXMgY2FzZSBvbmx5IGhhcHBlbnMgd2hlbiBwdXNoU3RhdGUvcmVwbGFjZVN0YXRlIHdhcyBjYWxsZWQgb3V0c2lkZSBvZiBOZXh0LmpzLiBJdCBzaG91bGQgcHJvYmFibHkgcmVsb2FkIHRoZSBwYWdlIGluIHRoaXMgY2FzZS5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIGNhc2UgaGFwcGVucyB3aGVuIHRoZSBoaXN0b3J5IGVudHJ5IHdhcyBwdXNoZWQgYnkgdGhlIGBwYWdlc2Agcm91dGVyLlxuICAgICAgICBpZiAoIXN0YXRlLl9fTkEpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtaWdub3JlIHVzZVRyYW5zaXRpb24gZXhpc3RzXG4gICAgICAgIC8vIFRPRE8tQVBQOiBJZGVhbGx5IHRoZSBiYWNrIGJ1dHRvbiBzaG91bGQgbm90IHVzZSBzdGFydFRyYW5zaXRpb24gYXMgaXQgc2hvdWxkIGFwcGx5IHRoZSB1cGRhdGVzIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gV2l0aG91dCBzdGFydFRyYW5zaXRpb24gd29ya3MgaWYgdGhlIGNhY2hlIGlzIHRoZXJlIGZvciB0aGlzIHBhdGhcbiAgICAgICAgX3JlYWN0LmRlZmF1bHQuc3RhcnRUcmFuc2l0aW9uKCgpPT57XG4gICAgICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogX3JlZHVjZXIuQUNUSU9OX1JFU1RPUkUsXG4gICAgICAgICAgICAgICAgdXJsOiBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKSxcbiAgICAgICAgICAgICAgICB0cmVlOiBzdGF0ZS50cmVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSwgW1xuICAgICAgICBkaXNwYXRjaFxuICAgIF0pO1xuICAgIC8vIFJlZ2lzdGVyIHBvcHN0YXRlIGV2ZW50IHRvIGNhbGwgb25Qb3BzdGF0ZS5cbiAgICAoMCwgX3JlYWN0KS51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgb25Qb3BTdGF0ZSk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgb25Qb3BTdGF0ZSk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBvblBvcFN0YXRlXG4gICAgXSk7XG4gICAgY29uc3QgY29udGVudCA9IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgaGVhZCB8fCBpbml0aWFsSGVhZCwgY2FjaGUuc3ViVHJlZURhdGEpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2hvb2tzQ2xpZW50Q29udGV4dC5QYXRobmFtZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHBhdGhuYW1lXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9ob29rc0NsaWVudENvbnRleHQuU2VhcmNoUGFyYW1zQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogc2VhcmNoUGFyYW1zXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9hcHBSb3V0ZXJDb250ZXh0Lkdsb2JhbExheW91dFJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIGNoYW5nZUJ5U2VydmVyUmVzcG9uc2UsXG4gICAgICAgICAgICB0cmVlLFxuICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWZcbiAgICAgICAgfVxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfYXBwUm91dGVyQ29udGV4dC5BcHBSb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBhcHBSb3V0ZXJcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2FwcFJvdXRlckNvbnRleHQuTGF5b3V0Um91dGVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgY2hpbGROb2RlczogY2FjaGUucGFyYWxsZWxSb3V0ZXMsXG4gICAgICAgICAgICB0cmVlOiB0cmVlLFxuICAgICAgICAgICAgLy8gUm9vdCBub2RlIGFsd2F5cyBoYXMgYHVybGBcbiAgICAgICAgICAgIC8vIFByb3ZpZGVkIGluIEFwcFRyZWVDb250ZXh0IHRvIGVuc3VyZSBpdCBjYW4gYmUgb3ZlcndyaXR0ZW4gaW4gbGF5b3V0LXJvdXRlclxuICAgICAgICAgICAgdXJsOiBjYW5vbmljYWxVcmxcbiAgICAgICAgfVxuICAgIH0sIEhvdFJlbG9hZGVyID8gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEhvdFJlbG9hZGVyLCB7XG4gICAgICAgIGFzc2V0UHJlZml4OiBhc3NldFByZWZpeFxuICAgIH0sIGNvbnRlbnQpIDogY29udGVudCkpKSkpO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAtcm91dGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkFwcFJvdXRlciIsImZldGNoU2VydmVyUmVzcG9uc2UiLCJfYXN5bmNfdG9fZ2VuZXJhdG9yIiwicmVxdWlyZSIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZSIsIl9yZWFjdCIsIl9jbGllbnQiLCJfYXBwUm91dGVyQ29udGV4dCIsIl9yZWR1Y2VyIiwiX2hvb2tzQ2xpZW50Q29udGV4dCIsIl91c2VSZWR1Y2VyV2l0aERldnRvb2xzIiwiX2Vycm9yQm91bmRhcnkiLCJfYXBwUm91dGVySGVhZGVycyIsInByb3BzIiwiZ2xvYmFsRXJyb3JDb21wb25lbnQiLCJyZXN0IiwiY3JlYXRlRWxlbWVudCIsIkVycm9yQm91bmRhcnkiLCJlcnJvckNvbXBvbmVudCIsIlJvdXRlciIsImFzc2lnbiIsInVybFRvVXJsV2l0aG91dEZsaWdodE1hcmtlciIsInVybCIsInVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzIiwiVVJMIiwibG9jYXRpb24iLCJvcmlnaW4iLCJIb3RSZWxvYWRlciIsImZsaWdodFJvdXRlclN0YXRlIiwicHJlZmV0Y2giLCJfZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsImFwcGx5IiwiYXJndW1lbnRzIiwiaGVhZGVycyIsIlJTQyIsIk5FWFRfUk9VVEVSX1NUQVRFX1RSRUUiLCJKU09OIiwic3RyaW5naWZ5IiwiTkVYVF9ST1VURVJfUFJFRkVUQ0giLCJmZXRjaCIsInRvU3RyaW5nIiwicmVzIiwiY2Fub25pY2FsVXJsIiwicmVkaXJlY3RlZCIsInVuZGVmaW5lZCIsImlzRmxpZ2h0UmVzcG9uc2UiLCJnZXQiLCJjcmVhdGVGcm9tRmV0Y2giLCJQcm9taXNlIiwicmVzb2x2ZSIsImZsaWdodERhdGEiLCJpbml0aWFsUGFyYWxsZWxSb3V0ZXMiLCJNYXAiLCJwcmVmZXRjaGVkIiwiU2V0IiwiZmluZEhlYWRJbkNhY2hlIiwiY2FjaGUiLCJwYXJhbGxlbFJvdXRlcyIsImlzTGFzdEl0ZW0iLCJrZXlzIiwibGVuZ3RoIiwiaGVhZCIsImtleSIsInNlZ21lbnQiLCJjaGlsZFBhcmFsbGVsUm91dGVzIiwiY2hpbGRTZWdtZW50TWFwIiwiY2FjaGVLZXkiLCJBcnJheSIsImlzQXJyYXkiLCJjYWNoZU5vZGUiLCJpdGVtIiwiaW5pdGlhbEhlYWQiLCJpbml0aWFsVHJlZSIsImluaXRpYWxDYW5vbmljYWxVcmwiLCJjaGlsZHJlbiIsImFzc2V0UHJlZml4IiwiaW5pdGlhbFN0YXRlIiwidXNlTWVtbyIsInRyZWUiLCJzdGF0dXMiLCJDYWNoZVN0YXRlcyIsIlJFQURZIiwiZGF0YSIsInN1YlRyZWVEYXRhIiwicHJlZmV0Y2hDYWNoZSIsInB1c2hSZWYiLCJwZW5kaW5nUHVzaCIsIm1wYU5hdmlnYXRpb24iLCJmb2N1c0FuZFNjcm9sbFJlZiIsImNyZWF0ZUhyZWZGcm9tVXJsIiwid2luZG93IiwidXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzIiwicmVkdWNlciIsImRpc3BhdGNoIiwic3luYyIsInVzZUVmZmVjdCIsImhyZWYiLCJzZWFyY2hQYXJhbXMiLCJwYXRobmFtZSIsImNoYW5nZUJ5U2VydmVyUmVzcG9uc2UiLCJ1c2VDYWxsYmFjayIsInByZXZpb3VzVHJlZSIsIm92ZXJyaWRlQ2Fub25pY2FsVXJsIiwidHlwZSIsIkFDVElPTl9TRVJWRVJfUEFUQ0giLCJMQVpZX0lOSVRJQUxJWkVEIiwibXV0YWJsZSIsImFwcFJvdXRlciIsIm5hdmlnYXRlIiwibmF2aWdhdGVUeXBlIiwiZm9yY2VPcHRpbWlzdGljTmF2aWdhdGlvbiIsIkFDVElPTl9OQVZJR0FURSIsInJvdXRlckluc3RhbmNlIiwiYmFjayIsImhpc3RvcnkiLCJmb3J3YXJkIiwiaGFzIiwiYWRkIiwicm91dGVyVHJlZSIsInJlZiIsInN0YXRlIiwic2VydmVyUmVzcG9uc2UiLCJzdGFydFRyYW5zaXRpb24iLCJBQ1RJT05fUFJFRkVUQ0giLCJjb25zb2xlIiwiZXJyb3IiLCJyZXBsYWNlIiwib3B0aW9ucyIsIkJvb2xlYW4iLCJwdXNoIiwicmVmcmVzaCIsIkFDVElPTl9SRUZSRVNIIiwiaGlzdG9yeVN0YXRlIiwiX19OQSIsInB1c2hTdGF0ZSIsInJlcGxhY2VTdGF0ZSIsIm5kIiwicm91dGVyIiwib25Qb3BTdGF0ZSIsInJlbG9hZCIsIkFDVElPTl9SRVNUT1JFIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjb250ZW50IiwiRnJhZ21lbnQiLCJQYXRobmFtZUNvbnRleHQiLCJQcm92aWRlciIsIlNlYXJjaFBhcmFtc0NvbnRleHQiLCJHbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0IiwiQXBwUm91dGVyQ29udGV4dCIsIkxheW91dFJvdXRlckNvbnRleHQiLCJjaGlsZE5vZGVzIiwiX19lc01vZHVsZSIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/app-router.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/error-boundary.js":
/*!********************************************************************!*\
  !*** ./node_modules/next/dist/client/components/error-boundary.js ***!
  \********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\"use client\";\n\"use strict\";\n\nvar _classCallCheck = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/classCallCheck.js */ \"(app-client)/./node_modules/next/dist/compiled/@babel/runtime/helpers/classCallCheck.js\");\n\nvar _createClass = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/createClass.js */ \"(app-client)/./node_modules/next/dist/compiled/@babel/runtime/helpers/createClass.js\");\n\nvar _inherits = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/inherits.js */ \"(app-client)/./node_modules/next/dist/compiled/@babel/runtime/helpers/inherits.js\");\n\nvar _possibleConstructorReturn = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/possibleConstructorReturn.js */ \"(app-client)/./node_modules/next/dist/compiled/@babel/runtime/helpers/possibleConstructorReturn.js\");\n\nvar _getPrototypeOf = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/getPrototypeOf.js */ \"(app-client)/./node_modules/next/dist/compiled/@babel/runtime/helpers/getPrototypeOf.js\");\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = GlobalError;\nexports.ErrorBoundary = ErrorBoundary;\n\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"(app-client)/./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\n\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\"));\n\nfunction GlobalError(_ref) {\n  var error = _ref.error;\n  return /*#__PURE__*/_react[\"default\"].createElement(\"html\", null, /*#__PURE__*/_react[\"default\"].createElement(\"head\", null), /*#__PURE__*/_react[\"default\"].createElement(\"body\", null, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n    style: styles.error\n  }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n    style: styles.desc\n  }, /*#__PURE__*/_react[\"default\"].createElement(\"h2\", {\n    style: styles.text\n  }, \"Application error: a client-side exception has occurred (see the browser console for more information).\"), (error == null ? void 0 : error.digest) && /*#__PURE__*/_react[\"default\"].createElement(\"p\", {\n    style: styles.text\n  }, \"Digest: \".concat(error.digest))))));\n}\n\n_c = GlobalError;\nvar styles = {\n  error: {\n    fontFamily: '-apple-system, BlinkMacSystemFont, Roboto, \"Segoe UI\", \"Fira Sans\", Avenir, \"Helvetica Neue\", \"Lucida Grande\", sans-serif',\n    height: '100vh',\n    textAlign: 'center',\n    display: 'flex',\n    flexDirection: 'column',\n    alignItems: 'center',\n    justifyContent: 'center'\n  },\n  desc: {\n    display: 'inline-block',\n    textAlign: 'left',\n    lineHeight: '49px',\n    height: '49px',\n    verticalAlign: 'middle'\n  },\n  text: {\n    fontSize: '14px',\n    fontWeight: 'normal',\n    lineHeight: '49px',\n    margin: 0,\n    padding: 0\n  }\n};\n\nvar ErrorBoundaryHandler = /*#__PURE__*/function (_react$default$Compon) {\n  _inherits(ErrorBoundaryHandler, _react$default$Compon);\n\n  var _super = _createSuper(ErrorBoundaryHandler);\n\n  function ErrorBoundaryHandler(props) {\n    var _this;\n\n    _classCallCheck(this, ErrorBoundaryHandler);\n\n    _this = _super.call(this, props);\n\n    _this.reset = function () {\n      _this.setState({\n        error: null\n      });\n    };\n\n    _this.state = {\n      error: null\n    };\n    return _this;\n  }\n\n  _createClass(ErrorBoundaryHandler, [{\n    key: \"render\",\n    value: function render() {\n      if (this.state.error) {\n        return /*#__PURE__*/_react[\"default\"].createElement(_react[\"default\"].Fragment, null, this.props.errorStyles, /*#__PURE__*/_react[\"default\"].createElement(this.props.errorComponent, {\n          error: this.state.error,\n          reset: this.reset\n        }));\n      }\n\n      return this.props.children;\n    }\n  }], [{\n    key: \"getDerivedStateFromError\",\n    value: function getDerivedStateFromError(error) {\n      return {\n        error: error\n      };\n    }\n  }]);\n\n  return ErrorBoundaryHandler;\n}(_react[\"default\"].Component);\n\nexports.ErrorBoundaryHandler = ErrorBoundaryHandler;\n\nfunction ErrorBoundary(_ref2) {\n  var errorComponent = _ref2.errorComponent,\n      errorStyles = _ref2.errorStyles,\n      children = _ref2.children;\n\n  if (errorComponent) {\n    return /*#__PURE__*/_react[\"default\"].createElement(ErrorBoundaryHandler, {\n      errorComponent: errorComponent,\n      errorStyles: errorStyles\n    }, children);\n  }\n\n  return /*#__PURE__*/_react[\"default\"].createElement(_react[\"default\"].Fragment, null, children);\n}\n\n_c2 = ErrorBoundary;\n\nif ((typeof exports[\"default\"] === 'function' || typeof exports[\"default\"] === 'object' && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === 'undefined') {\n  Object.defineProperty(exports[\"default\"], '__esModule', {\n    value: true\n  });\n  Object.assign(exports[\"default\"], exports);\n  module.exports = exports[\"default\"];\n}\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"GlobalError\");\n$RefreshReg$(_c2, \"ErrorBoundary\");\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9lcnJvci1ib3VuZGFyeS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBQ0FBLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBRGtDLENBQTdDO0FBR0FELGtCQUFBLEdBQWtCRSxXQUFsQjtBQUNBRixxQkFBQSxHQUF3QkcsYUFBeEI7O0FBQ0EsSUFBSUMsd0JBQXdCLEdBQUdDLGdLQUEvQjs7QUFDQSxJQUFJQyxNQUFNLEdBQUdGLHdCQUF3QixDQUFDQyxtQkFBTyxDQUFDLDRFQUFELENBQVIsQ0FBckM7O0FBQ0EsU0FBU0gsV0FBVCxPQUFpQztFQUFBLElBQVZLLEtBQVUsUUFBVkEsS0FBVTtFQUM3QixPQUFPLGFBQWNELE1BQU0sV0FBTixDQUFlRSxhQUFmLENBQTZCLE1BQTdCLEVBQXFDLElBQXJDLEVBQTJDLGFBQWNGLE1BQU0sV0FBTixDQUFlRSxhQUFmLENBQTZCLE1BQTdCLEVBQXFDLElBQXJDLENBQXpELEVBQXFHLGFBQWNGLE1BQU0sV0FBTixDQUFlRSxhQUFmLENBQTZCLE1BQTdCLEVBQXFDLElBQXJDLEVBQTJDLGFBQWNGLE1BQU0sV0FBTixDQUFlRSxhQUFmLENBQTZCLEtBQTdCLEVBQW9DO0lBQ2pPQyxLQUFLLEVBQUVDLE1BQU0sQ0FBQ0g7RUFEbU4sQ0FBcEMsRUFFOUwsYUFBY0QsTUFBTSxXQUFOLENBQWVFLGFBQWYsQ0FBNkIsS0FBN0IsRUFBb0M7SUFDakRDLEtBQUssRUFBRUMsTUFBTSxDQUFDQztFQURtQyxDQUFwQyxFQUVkLGFBQWNMLE1BQU0sV0FBTixDQUFlRSxhQUFmLENBQTZCLElBQTdCLEVBQW1DO0lBQ2hEQyxLQUFLLEVBQUVDLE1BQU0sQ0FBQ0U7RUFEa0MsQ0FBbkMsRUFFZCx5R0FGYyxDQUZBLEVBSThGLENBQUNMLEtBQUssSUFBSSxJQUFULEdBQWdCLEtBQUssQ0FBckIsR0FBeUJBLEtB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LFFBQTNCLElBQXVDQSxPQUFPLFdBQVAsS0FBb0IsSUFBdEcsS0FBZ0gsT0FBT0EsT0FBTyxXQUFQLENBQWdCcUMsVUFBdkIsS0FBc0MsV0FBMUosRUFBdUs7RUFDckt2QyxNQUFNLENBQUNDLGNBQVAsQ0FBc0JDLE9BQU8sV0FBN0IsRUFBdUMsWUFBdkMsRUFBcUQ7SUFBRUMsS0FBSyxFQUFFO0VBQVQsQ0FBckQ7RUFDQUgsTUFBTSxDQUFDd0MsTUFBUCxDQUFjdEMsT0FBTyxXQUFyQixFQUErQkEsT0FBL0I7RUFDQXVDLE1BQU0sQ0FBQ3ZDLE9BQVAsR0FBaUJBLE9BQU8sV0FBeEI7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2Vycm9yLWJvdW5kYXJ5LmpzPzc2OTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEdsb2JhbEVycm9yO1xuZXhwb3J0cy5FcnJvckJvdW5kYXJ5ID0gRXJyb3JCb3VuZGFyeTtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuanNcIikuZGVmYXVsdDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbmZ1bmN0aW9uIEdsb2JhbEVycm9yKHsgZXJyb3IgIH0pIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaHRtbFwiLCBudWxsLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJoZWFkXCIsIG51bGwpLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJib2R5XCIsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIHN0eWxlOiBzdHlsZXMuZXJyb3JcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBzdHlsZTogc3R5bGVzLmRlc2NcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJoMlwiLCB7XG4gICAgICAgIHN0eWxlOiBzdHlsZXMudGV4dFxuICAgIH0sIFwiQXBwbGljYXRpb24gZXJyb3I6IGEgY2xpZW50LXNpZGUgZXhjZXB0aW9uIGhhcyBvY2N1cnJlZCAoc2VlIHRoZSBicm93c2VyIGNvbnNvbGUgZm9yIG1vcmUgaW5mb3JtYXRpb24pLlwiKSwgKGVycm9yID09IG51bGwgPyB2b2lkIDAgOiBlcnJvci5kaWdlc3QpICYmIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInBcIiwge1xuICAgICAgICBzdHlsZTogc3R5bGVzLnRleHRcbiAgICB9LCBgRGlnZXN0OiAke2Vycm9yLmRpZ2VzdH1gKSkpKSk7XG59XG5cbmNvbnN0IHN0eWxlcyA9IHtcbiAgICBlcnJvcjoge1xuICAgICAgICBmb250RmFtaWx5OiAnLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBSb2JvdG8sIFwiU2Vnb2UgVUlcIiwgXCJGaXJhIFNhbnNcIiwgQXZlbmlyLCBcIkhlbHZldGljYSBOZXVlXCIsIFwiTHVjaWRhIEdyYW5kZVwiLCBzYW5zLXNlcmlmJyxcbiAgICAgICAgaGVpZ2h0OiAnMTAwdmgnLFxuICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLFxuICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInXG4gICAgfSxcbiAgICBkZXNjOiB7XG4gICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICB0ZXh0QWxpZ246ICdsZWZ0JyxcbiAgICAgICAgbGluZUhlaWdodDogJzQ5cHgnLFxuICAgICAgICBoZWlnaHQ6ICc0OXB4JyxcbiAgICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZSdcbiAgICB9LFxuICAgIHRleHQ6IHtcbiAgICAgICAgZm9udFNpemU6ICcxNHB4JyxcbiAgICAgICAgZm9udFdlaWdodDogJ25vcm1hbCcsXG4gICAgICAgIGxpbmVIZWlnaHQ6ICc0OXB4JyxcbiAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICBwYWRkaW5nOiAwXG4gICAgfVxufTtcbmNsYXNzIEVycm9yQm91bmRhcnlIYW5kbGVyIGV4dGVuZHMgX3JlYWN0LmRlZmF1bHQuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvclxuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCB0aGlzLnByb3BzLmVycm9yU3R5bGVzLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQodGhpcy5wcm9wcy5lcnJvckNvbXBvbmVudCwge1xuICAgICAgICAgICAgICAgIGVycm9yOiB0aGlzLnN0YXRlLmVycm9yLFxuICAgICAgICAgICAgICAgIHJlc2V0OiB0aGlzLnJlc2V0XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHByb3BzKXtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLnJlc2V0ID0gKCk9PntcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5FcnJvckJvdW5kYXJ5SGFuZGxlciA9IEVycm9yQm91bmRhcnlIYW5kbGVyO1xuZnVuY3Rpb24gRXJyb3JCb3VuZGFyeSh7IGVycm9yQ29tcG9uZW50ICwgZXJyb3JTdHlsZXMgLCBjaGlsZHJlbiAgfSkge1xuICAgIGlmIChlcnJvckNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEVycm9yQm91bmRhcnlIYW5kbGVyLCB7XG4gICAgICAgICAgICBlcnJvckNvbXBvbmVudDogZXJyb3JDb21wb25lbnQsXG4gICAgICAgICAgICBlcnJvclN0eWxlczogZXJyb3JTdHlsZXNcbiAgICAgICAgfSwgY2hpbGRyZW4pO1xuICAgIH1cbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbik7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yLWJvdW5kYXJ5LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkdsb2JhbEVycm9yIiwiRXJyb3JCb3VuZGFyeSIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfcmVhY3QiLCJlcnJvciIsImNyZWF0ZUVsZW1lbnQiLCJzdHlsZSIsInN0eWxlcyIsImRlc2MiLCJ0ZXh0IiwiZGlnZXN0IiwiZm9udEZhbWlseSIsImhlaWdodCIsInRleHRBbGlnbiIsImRpc3BsYXkiLCJmbGV4RGlyZWN0aW9uIiwiYWxpZ25JdGVtcyIsImp1c3RpZnlDb250ZW50IiwibGluZUhlaWdodCIsInZlcnRpY2FsQWxpZ24iLCJmb250U2l6ZSIsImZvbnRXZWlnaHQiLCJtYXJnaW4iLCJwYWRkaW5nIiwiRXJyb3JCb3VuZGFyeUhhbmRsZXIiLCJwcm9wcyIsInJlc2V0Iiwic2V0U3RhdGUiLCJzdGF0ZSIsIkZyYWdtZW50IiwiZXJyb3JTdHlsZXMiLCJlcnJvckNvbXBvbmVudCIsImNoaWxkcmVuIiwiQ29tcG9uZW50IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/error-boundary.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/infinite-promise.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/client/components/infinite-promise.js ***!
  \**********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.createInfinitePromise = createInfinitePromise;\n/**\n * Used to cache in createInfinitePromise\n */\n\nvar infinitePromise;\n\nfunction createInfinitePromise() {\n  if (!infinitePromise) {\n    // Only create the Promise once\n    infinitePromise = new Promise(function () {// This is used to debug when the rendering is never updated.\n      // setTimeout(() => {\n      //   infinitePromise = new Error('Infinite promise')\n      //   resolve()\n      // }, 5000)\n    });\n  }\n\n  return infinitePromise;\n}\n\nif ((typeof exports[\"default\"] === 'function' || typeof exports[\"default\"] === 'object' && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === 'undefined') {\n  Object.defineProperty(exports[\"default\"], '__esModule', {\n    value: true\n  });\n  Object.assign(exports[\"default\"], exports);\n  module.exports = exports[\"default\"];\n}\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9pbmZpbml0ZS1wcm9taXNlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUNiQSw4Q0FBNkM7RUFDekNHLEtBQUssRUFBRTtBQURrQyxDQUE3QztBQUdBRCw2QkFBQSxHQUFnQ0UscUJBQWhDO0FBQ0E7QUFDQTtBQUNBOztBQUFJLElBQUlDLGVBQUo7O0FBQ0osU0FBU0QscUJBQVQsR0FBaUM7RUFDN0IsSUFBSSxDQUFDQyxlQUFMLEVBQXNCO0lBQ2xCO0lBQ0FBLGVBQWUsR0FBRyxJQUFJQyxPQUFKLENBQVksWUFBSSxDQUNsQztNQUNBO01BQ0E7TUFDQTtNQUNBO0lBQ0MsQ0FOaUIsQ0FBbEI7RUFPSDs7RUFDRCxPQUFPRCxlQUFQO0FBQ0g7O0FBRUQsSUFBSSxDQUFDLE9BQU9ILE9BQU8sV0FBZCxLQUEyQixVQUEzQixJQUEwQyxPQUFPQSxPQUFPLFdBQWQsS0FBMkIsUUFBM0IsSUFBdUNBLE9BQU8sV0FBUCxLQUFvQixJQUF0RyxLQUFnSCxPQUFPQSxPQUFPLFdBQVAsQ0FBZ0JLLFVBQXZCLEtBQXNDLFdBQTFKLEVBQXVLO0VBQ3JLUCxNQUFNLENBQUNDLGNBQVAsQ0FBc0JDLE9BQU8sV0FBN0IsRUFBdUMsWUFBdkMsRUFBcUQ7SUFBRUMsS0FBSyxFQUFFO0VBQVQsQ0FBckQ7RUFDQUgsTUFBTSxDQUFDUSxNQUFQLENBQWNOLE9BQU8sV0FBckIsRUFBK0JBLE9BQS9CO0VBQ0FPLE1BQU0sQ0FBQ1AsT0FBUCxHQUFpQkEsT0FBTyxXQUF4QjtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvaW5maW5pdGUtcHJvbWlzZS5qcz83MmZmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jcmVhdGVJbmZpbml0ZVByb21pc2UgPSBjcmVhdGVJbmZpbml0ZVByb21pc2U7XG4vKipcbiAqIFVzZWQgdG8gY2FjaGUgaW4gY3JlYXRlSW5maW5pdGVQcm9taXNlXG4gKi8gbGV0IGluZmluaXRlUHJvbWlzZTtcbmZ1bmN0aW9uIGNyZWF0ZUluZmluaXRlUHJvbWlzZSgpIHtcbiAgICBpZiAoIWluZmluaXRlUHJvbWlzZSkge1xuICAgICAgICAvLyBPbmx5IGNyZWF0ZSB0aGUgUHJvbWlzZSBvbmNlXG4gICAgICAgIGluZmluaXRlUHJvbWlzZSA9IG5ldyBQcm9taXNlKCgpPT57XG4gICAgICAgIC8vIFRoaXMgaXMgdXNlZCB0byBkZWJ1ZyB3aGVuIHRoZSByZW5kZXJpbmcgaXMgbmV2ZXIgdXBkYXRlZC5cbiAgICAgICAgLy8gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIC8vICAgaW5maW5pdGVQcm9taXNlID0gbmV3IEVycm9yKCdJbmZpbml0ZSBwcm9taXNlJylcbiAgICAgICAgLy8gICByZXNvbHZlKClcbiAgICAgICAgLy8gfSwgNTAwMClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBpbmZpbml0ZVByb21pc2U7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZmluaXRlLXByb21pc2UuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiY3JlYXRlSW5maW5pdGVQcm9taXNlIiwiaW5maW5pdGVQcm9taXNlIiwiUHJvbWlzZSIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/infinite-promise.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/layout-router.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/components/layout-router.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\"use client\";\n\"use strict\";\n\nvar _toConsumableArray = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/toConsumableArray.js */ \"(app-client)/./node_modules/next/dist/compiled/@babel/runtime/helpers/toConsumableArray.js\");\n\nvar _classCallCheck = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/classCallCheck.js */ \"(app-client)/./node_modules/next/dist/compiled/@babel/runtime/helpers/classCallCheck.js\");\n\nvar _createClass = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/createClass.js */ \"(app-client)/./node_modules/next/dist/compiled/@babel/runtime/helpers/createClass.js\");\n\nvar _inherits = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/inherits.js */ \"(app-client)/./node_modules/next/dist/compiled/@babel/runtime/helpers/inherits.js\");\n\nvar _possibleConstructorReturn = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/possibleConstructorReturn.js */ \"(app-client)/./node_modules/next/dist/compiled/@babel/runtime/helpers/possibleConstructorReturn.js\");\n\nvar _getPrototypeOf = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/getPrototypeOf.js */ \"(app-client)/./node_modules/next/dist/compiled/@babel/runtime/helpers/getPrototypeOf.js\");\n\nvar _defineProperty = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/defineProperty.js */ \"(app-client)/./node_modules/next/dist/compiled/@babel/runtime/helpers/defineProperty.js\");\n\nvar _slicedToArray = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/slicedToArray.js */ \"(app-client)/./node_modules/next/dist/compiled/@babel/runtime/helpers/slicedToArray.js\");\n\nvar _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$();\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = OuterLayoutRouter;\nexports.InnerLayoutRouter = InnerLayoutRouter;\n\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"(app-client)/./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\n\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"(app-client)/./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\n\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(app-client)/./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\n\nvar _react = _interop_require_wildcard(__webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\"));\n\nvar _reactDom = _interop_require_default(__webpack_require__(/*! react-dom */ \"(app-client)/./node_modules/next/dist/compiled/react-dom/index.js\"));\n\nvar _appRouterContext = __webpack_require__(/*! ../../shared/lib/app-router-context */ \"(app-client)/./node_modules/next/dist/shared/lib/app-router-context.js\");\n\nvar _appRouter = __webpack_require__(/*! ./app-router */ \"(app-client)/./node_modules/next/dist/client/components/app-router.js\");\n\nvar _infinitePromise = __webpack_require__(/*! ./infinite-promise */ \"(app-client)/./node_modules/next/dist/client/components/infinite-promise.js\");\n\nvar _errorBoundary = __webpack_require__(/*! ./error-boundary */ \"(app-client)/./node_modules/next/dist/client/components/error-boundary.js\");\n\nvar _matchSegments = __webpack_require__(/*! ./match-segments */ \"(app-client)/./node_modules/next/dist/client/components/match-segments.js\");\n\nvar _navigation = __webpack_require__(/*! ./navigation */ \"(app-client)/./node_modules/next/dist/client/components/navigation.js\");\n\nfunction OuterLayoutRouter(_ref) {\n  _s();\n\n  var parallelRouterKey = _ref.parallelRouterKey,\n      segmentPath = _ref.segmentPath,\n      childProp = _ref.childProp,\n      error = _ref.error,\n      errorStyles = _ref.errorStyles,\n      templateStyles = _ref.templateStyles,\n      loading = _ref.loading,\n      loadingStyles = _ref.loadingStyles,\n      hasLoading = _ref.hasLoading,\n      template = _ref.template,\n      notFound = _ref.notFound,\n      notFoundStyles = _ref.notFoundStyles,\n      rootLayoutIncluded = _ref.rootLayoutIncluded;\n  var context = (0, _react).useContext(_appRouterContext.LayoutRouterContext);\n\n  if (!context) {\n    throw new Error('invariant expected layout router to be mounted');\n  }\n\n  var childNodes = context.childNodes,\n      tree = context.tree,\n      url = context.url; // Get the current parallelRouter cache node\n\n  var childNodesForParallelRouter = childNodes.get(parallelRouterKey); // If the parallel router cache node does not exist yet, create it.\n  // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\n\n  if (!childNodesForParallelRouter) {\n    childNodes.set(parallelRouterKey, new Map());\n    childNodesForParallelRouter = childNodes.get(parallelRouterKey);\n  } // Get the active segment in the tree\n  // The reason arrays are used in the data format is that these are transferred from the server to the browser so it's optimized to save bytes.\n\n\n  var treeSegment = tree[1][parallelRouterKey][0];\n  var childPropSegment = Array.isArray(childProp.segment) ? childProp.segment[1] : childProp.segment; // If segment is an array it's a dynamic route and we want to read the dynamic route value as the segment to get from the cache.\n\n  var currentChildSegment = Array.isArray(treeSegment) ? treeSegment[1] : treeSegment;\n  /**\n  * Decides which segments to keep rendering, all segments that are not active will be wrapped in `<Offscreen>`.\n  */\n  // TODO-APP: Add handling of `<Offscreen>` when it's available.\n\n  var preservedSegments = [currentChildSegment];\n  return /*#__PURE__*/_react[\"default\"].createElement(_react[\"default\"].Fragment, null, preservedSegments.map(function (preservedSegment) {\n    return (\n      /*\n      - Error boundary\n      - Only renders error boundary if error component is provided.\n      - Rendered for each segment to ensure they have their own error state.\n      - Loading boundary\n      - Only renders suspense boundary if loading components is provided.\n      - Rendered for each segment to ensure they have their own loading state.\n      - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.\n      */\n\n      /*#__PURE__*/\n      _react[\"default\"].createElement(_appRouterContext.TemplateContext.Provider, {\n        key: preservedSegment,\n        value: /*#__PURE__*/_react[\"default\"].createElement(_errorBoundary.ErrorBoundary, {\n          errorComponent: error,\n          errorStyles: errorStyles\n        }, /*#__PURE__*/_react[\"default\"].createElement(LoadingBoundary, {\n          hasLoading: hasLoading,\n          loading: loading,\n          loadingStyles: loadingStyles\n        }, /*#__PURE__*/_react[\"default\"].createElement(NotFoundBoundary, {\n          notFound: notFound,\n          notFoundStyles: notFoundStyles\n        }, /*#__PURE__*/_react[\"default\"].createElement(RedirectBoundary, null, /*#__PURE__*/_react[\"default\"].createElement(InnerLayoutRouter, {\n          parallelRouterKey: parallelRouterKey,\n          url: url,\n          tree: tree,\n          childNodes: childNodesForParallelRouter,\n          childProp: childPropSegment === preservedSegment ? childProp : null,\n          segmentPath: segmentPath,\n          path: preservedSegment,\n          isActive: currentChildSegment === preservedSegment,\n          rootLayoutIncluded: rootLayoutIncluded\n        })))))\n      }, /*#__PURE__*/_react[\"default\"].createElement(_react[\"default\"].Fragment, null, templateStyles, template))\n    );\n  }));\n}\n/**\n * Add refetch marker to router state at the point of the current layout segment.\n * This ensures the response returned is not further down than the current layout segment.\n */\n\n\n_s(OuterLayoutRouter, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n\n_c = OuterLayoutRouter;\n\nfunction walkAddRefetch(segmentPathToWalk, treeToRecreate) {\n  if (segmentPathToWalk) {\n    var _segmentPathToWalk = _slicedToArray(segmentPathToWalk, 2),\n        segment = _segmentPathToWalk[0],\n        parallelRouteKey = _segmentPathToWalk[1];\n\n    var isLast = segmentPathToWalk.length === 2;\n\n    if ((0, _matchSegments).matchSegment(treeToRecreate[0], segment)) {\n      if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {\n        if (isLast) {\n          var subTree = walkAddRefetch(undefined, treeToRecreate[1][parallelRouteKey]);\n          return [treeToRecreate[0], _extends({}, treeToRecreate[1], _defineProperty({}, parallelRouteKey, [subTree[0], subTree[1], subTree[2], 'refetch']))];\n        }\n\n        return [treeToRecreate[0], _extends({}, treeToRecreate[1], _defineProperty({}, parallelRouteKey, walkAddRefetch(segmentPathToWalk.slice(2), treeToRecreate[1][parallelRouteKey])))];\n      }\n    }\n  }\n\n  return treeToRecreate;\n} // TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available\n\n/**\n * Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning\n */\n\n\nfunction findDOMNode(instance) {\n  // Tree-shake for server bundle\n  if (false) {} // Only apply strict mode warning when not in production\n\n  if (true) {\n    var originalConsoleError = console.error;\n\n    try {\n      console.error = function () {\n        for (var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++) {\n          messages[_key] = arguments[_key];\n        }\n\n        // Ignore strict mode warning for the findDomNode call below\n        if (!messages[0].includes('Warning: %s is deprecated in StrictMode.')) {\n          originalConsoleError.apply(void 0, messages);\n        }\n      };\n\n      return _reactDom[\"default\"].findDOMNode(instance);\n    } finally {\n      console.error = originalConsoleError;\n    }\n  }\n\n  return _reactDom[\"default\"].findDOMNode(instance);\n}\n/**\n * Check if the top of the HTMLElement is in the viewport.\n */\n\n\nfunction topOfElementInViewport(element) {\n  var rect = element.getBoundingClientRect();\n  return rect.top >= 0;\n}\n\nvar ScrollAndFocusHandler = /*#__PURE__*/function (_react$default$Compon) {\n  _inherits(ScrollAndFocusHandler, _react$default$Compon);\n\n  var _super = _createSuper(ScrollAndFocusHandler);\n\n  function ScrollAndFocusHandler() {\n    _classCallCheck(this, ScrollAndFocusHandler);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(ScrollAndFocusHandler, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.\n      var focusAndScrollRef = this.props.focusAndScrollRef;\n      var domNode = findDOMNode(this);\n\n      if (focusAndScrollRef.apply && domNode instanceof HTMLElement) {\n        // State is mutated to ensure that the focus and scroll is applied only once.\n        focusAndScrollRef.apply = false; // Set focus on the element\n\n        domNode.focus(); // Only scroll into viewport when the layout is not visible currently.\n\n        if (!topOfElementInViewport(domNode)) {\n          var htmlElement = document.documentElement;\n          var existing = htmlElement.style.scrollBehavior;\n          htmlElement.style.scrollBehavior = 'auto'; // In Chrome-based browsers we need to force reflow before calling `scrollTo`.\n          // Otherwise it will not pickup the change in scrollBehavior\n          // More info here: https://github.com/vercel/next.js/issues/40719#issuecomment-1336248042\n\n          htmlElement.getClientRects();\n          domNode.scrollIntoView();\n          htmlElement.style.scrollBehavior = existing;\n        }\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return this.props.children;\n    }\n  }]);\n\n  return ScrollAndFocusHandler;\n}(_react[\"default\"].Component);\n\nfunction InnerLayoutRouter(_ref2) {\n  _s2();\n\n  var parallelRouterKey = _ref2.parallelRouterKey,\n      url = _ref2.url,\n      childNodes = _ref2.childNodes,\n      childProp = _ref2.childProp,\n      segmentPath = _ref2.segmentPath,\n      tree = _ref2.tree,\n      path = _ref2.path,\n      rootLayoutIncluded = _ref2.rootLayoutIncluded;\n  var context = (0, _react).useContext(_appRouterContext.GlobalLayoutRouterContext);\n\n  if (!context) {\n    throw new Error('invariant global layout router not mounted');\n  }\n\n  var changeByServerResponse = context.changeByServerResponse,\n      fullTree = context.tree,\n      focusAndScrollRef = context.focusAndScrollRef; // Read segment path from the parallel router cache node.\n\n  var childNode = childNodes.get(path); // If childProp is available this means it's the Flight / SSR case.\n\n  if (childProp && // TODO-APP: verify if this can be null based on user code\n  childProp.current !== null) {\n    if (childNode && childNode.status === _appRouterContext.CacheStates.LAZY_INITIALIZED) {\n      // @ts-expect-error TODO-APP: handle changing of the type\n      childNode.status = _appRouterContext.CacheStates.READY; // @ts-expect-error TODO-APP: handle changing of the type\n\n      childNode.subTreeData = childProp.current; // Mutates the prop in order to clean up the memory associated with the subTreeData as it is now part of the cache.\n\n      childProp.current = null;\n    } else {\n      // Add the segment's subTreeData to the cache.\n      // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\n      childNodes.set(path, {\n        status: _appRouterContext.CacheStates.READY,\n        data: null,\n        subTreeData: childProp.current,\n        parallelRoutes: new Map()\n      }); // Mutates the prop in order to clean up the memory associated with the subTreeData as it is now part of the cache.\n\n      childProp.current = null; // In the above case childNode was set on childNodes, so we have to get it from the cacheNodes again.\n\n      childNode = childNodes.get(path);\n    }\n  } // When childNode is not available during rendering client-side we need to fetch it from the server.\n\n\n  if (!childNode || childNode.status === _appRouterContext.CacheStates.LAZY_INITIALIZED) {\n    /**\n    * Router state with refetch marker added\n    */\n    // TODO-APP: remove ''\n    var refetchTree = walkAddRefetch([''].concat(_toConsumableArray(segmentPath)), fullTree);\n    /**\n    * Flight data fetch kicked off during render and put into the cache.\n    */\n\n    childNodes.set(path, {\n      status: _appRouterContext.CacheStates.DATA_FETCH,\n      data: (0, _appRouter).fetchServerResponse(new URL(url, location.origin), refetchTree),\n      subTreeData: null,\n      head: childNode && childNode.status === _appRouterContext.CacheStates.LAZY_INITIALIZED ? childNode.head : undefined,\n      parallelRoutes: childNode && childNode.status === _appRouterContext.CacheStates.LAZY_INITIALIZED ? childNode.parallelRoutes : new Map()\n    }); // In the above case childNode was set on childNodes, so we have to get it from the cacheNodes again.\n\n    childNode = childNodes.get(path);\n  } // This case should never happen so it throws an error. It indicates there's a bug in the Next.js.\n\n\n  if (!childNode) {\n    throw new Error('Child node should always exist');\n  } // This case should never happen so it throws an error. It indicates there's a bug in the Next.js.\n\n\n  if (childNode.subTreeData && childNode.data) {\n    throw new Error('Child node should not have both subTreeData and data');\n  } // If cache node has a data request we have to unwrap response by `use` and update the cache.\n\n\n  if (childNode.data) {\n    /**\n    * Flight response data\n    */\n    // When the data has not resolved yet `use` will suspend here.\n    var _use = (0, _react).use(childNode.data),\n        _use2 = _slicedToArray(_use, 2),\n        flightData = _use2[0],\n        overrideCanonicalUrl = _use2[1]; // Handle case when navigating to page in `pages` from `app`\n\n\n    if (typeof flightData === 'string') {\n      window.location.href = url;\n      return null;\n    } // segmentPath from the server does not match the layout's segmentPath\n\n\n    childNode.data = null; // setTimeout is used to start a new transition during render, this is an intentional hack around React.\n\n    setTimeout(function () {\n      // @ts-ignore startTransition exists\n      _react[\"default\"].startTransition(function () {\n        changeByServerResponse(fullTree, flightData, overrideCanonicalUrl);\n      });\n    }); // Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.\n\n    (0, _react).use((0, _infinitePromise).createInfinitePromise());\n  } // If cache node has no subTreeData and no data request we have to infinitely suspend as the data will likely flow in from another place.\n  // TODO-APP: double check users can't return null in a component that will kick in here.\n\n\n  if (!childNode.subTreeData) {\n    (0, _react).use((0, _infinitePromise).createInfinitePromise());\n  }\n\n  var subtree = // The layout router context narrows down tree and childNodes at each level.\n\n  /*#__PURE__*/\n  _react[\"default\"].createElement(_appRouterContext.LayoutRouterContext.Provider, {\n    value: {\n      tree: tree[1][parallelRouterKey],\n      childNodes: childNode.parallelRoutes,\n      // TODO-APP: overriding of url for parallel routes\n      url: url\n    }\n  }, childNode.subTreeData); // Ensure root layout is not wrapped in a div as the root layout renders `<html>`\n\n\n  return rootLayoutIncluded ? /*#__PURE__*/_react[\"default\"].createElement(ScrollAndFocusHandler, {\n    focusAndScrollRef: focusAndScrollRef\n  }, subtree) : subtree;\n}\n/**\n * Renders suspense boundary with the provided \"loading\" property as the fallback.\n * If no loading property is provided it renders the children without a suspense boundary.\n */\n\n\n_s2(InnerLayoutRouter, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n\n_c2 = InnerLayoutRouter;\n\nfunction LoadingBoundary(_ref3) {\n  var children = _ref3.children,\n      loading = _ref3.loading,\n      loadingStyles = _ref3.loadingStyles,\n      hasLoading = _ref3.hasLoading;\n\n  if (hasLoading) {\n    return /*#__PURE__*/_react[\"default\"].createElement(_react[\"default\"].Suspense, {\n      fallback: /*#__PURE__*/_react[\"default\"].createElement(_react[\"default\"].Fragment, null, loadingStyles, loading)\n    }, children);\n  }\n\n  return /*#__PURE__*/_react[\"default\"].createElement(_react[\"default\"].Fragment, null, children);\n}\n\n_c3 = LoadingBoundary;\n\nfunction HandleRedirect(_ref4) {\n  _s3();\n\n  var redirect = _ref4.redirect;\n  var router = (0, _navigation).useRouter();\n  (0, _react).useEffect(function () {\n    router.replace(redirect, {});\n  }, [redirect, router]);\n  return null;\n}\n\n_s3(HandleRedirect, \"vQduR7x+OPXj6PSmJyFnf+hU7bg=\", true);\n\n_c4 = HandleRedirect;\n\nvar RedirectErrorBoundary = /*#__PURE__*/function (_react$default$Compon2) {\n  _inherits(RedirectErrorBoundary, _react$default$Compon2);\n\n  var _super2 = _createSuper(RedirectErrorBoundary);\n\n  function RedirectErrorBoundary(props) {\n    var _this;\n\n    _classCallCheck(this, RedirectErrorBoundary);\n\n    _this = _super2.call(this, props);\n    _this.state = {\n      redirect: null\n    };\n    return _this;\n  }\n\n  _createClass(RedirectErrorBoundary, [{\n    key: \"render\",\n    value: function render() {\n      var redirect = this.state.redirect;\n\n      if (redirect !== null) {\n        return /*#__PURE__*/_react[\"default\"].createElement(HandleRedirect, {\n          redirect: redirect\n        });\n      }\n\n      return this.props.children;\n    }\n  }], [{\n    key: \"getDerivedStateFromError\",\n    value: function getDerivedStateFromError(error) {\n      var ref;\n\n      if (error == null ? void 0 : (ref = error.digest) == null ? void 0 : ref.startsWith('NEXT_REDIRECT')) {\n        var url = error.digest.split(';')[1];\n        return {\n          redirect: url\n        };\n      } // Re-throw if error is not for redirect\n\n\n      throw error;\n    }\n  }]);\n\n  return RedirectErrorBoundary;\n}(_react[\"default\"].Component);\n\nfunction RedirectBoundary(_ref5) {\n  _s4();\n\n  var children = _ref5.children;\n  var router = (0, _navigation).useRouter();\n  return /*#__PURE__*/_react[\"default\"].createElement(RedirectErrorBoundary, {\n    router: router\n  }, children);\n}\n\n_s4(RedirectBoundary, \"fN7XvhJ+p5oE6+Xlo0NJmXpxjC8=\", true);\n\n_c5 = RedirectBoundary;\n\nvar NotFoundErrorBoundary = /*#__PURE__*/function (_react$default$Compon3) {\n  _inherits(NotFoundErrorBoundary, _react$default$Compon3);\n\n  var _super3 = _createSuper(NotFoundErrorBoundary);\n\n  function NotFoundErrorBoundary(props) {\n    var _this2;\n\n    _classCallCheck(this, NotFoundErrorBoundary);\n\n    _this2 = _super3.call(this, props);\n    _this2.state = {\n      notFoundTriggered: false\n    };\n    return _this2;\n  }\n\n  _createClass(NotFoundErrorBoundary, [{\n    key: \"render\",\n    value: function render() {\n      if (this.state.notFoundTriggered) {\n        return /*#__PURE__*/_react[\"default\"].createElement(_react[\"default\"].Fragment, null, /*#__PURE__*/_react[\"default\"].createElement(\"meta\", {\n          name: \"robots\",\n          content: \"noindex\"\n        }), this.props.notFoundStyles, this.props.notFound);\n      }\n\n      return this.props.children;\n    }\n  }], [{\n    key: \"getDerivedStateFromError\",\n    value: function getDerivedStateFromError(error) {\n      if ((error == null ? void 0 : error.digest) === 'NEXT_NOT_FOUND') {\n        return {\n          notFoundTriggered: true\n        };\n      } // Re-throw if error is not for 404\n\n\n      throw error;\n    }\n  }]);\n\n  return NotFoundErrorBoundary;\n}(_react[\"default\"].Component);\n\nfunction NotFoundBoundary(_ref6) {\n  var notFound = _ref6.notFound,\n      notFoundStyles = _ref6.notFoundStyles,\n      children = _ref6.children;\n  return notFound ? /*#__PURE__*/_react[\"default\"].createElement(NotFoundErrorBoundary, {\n    notFound: notFound,\n    notFoundStyles: notFoundStyles\n  }, children) : /*#__PURE__*/_react[\"default\"].createElement(_react[\"default\"].Fragment, null, children);\n}\n\n_c6 = NotFoundBoundary;\n\nif ((typeof exports[\"default\"] === 'function' || typeof exports[\"default\"] === 'object' && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === 'undefined') {\n  Object.defineProperty(exports[\"default\"], '__esModule', {\n    value: true\n  });\n  Object.assign(exports[\"default\"], exports);\n  module.exports = exports[\"default\"];\n}\n\nvar _c, _c2, _c3, _c4, _c5, _c6;\n\n$RefreshReg$(_c, \"OuterLayoutRouter\");\n$RefreshReg$(_c2, \"InnerLayoutRouter\");\n$RefreshReg$(_c3, \"LoadingBoundary\");\n$RefreshReg$(_c4, \"HandleRedirect\");\n$RefreshReg$(_c5, \"RedirectBoundary\");\n$RefreshReg$(_c6, \"NotFoundBoundary\");\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9sYXlvdXQtcm91dGVyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBQSw4Q0FBNkM7RUFDekNHLEtBQUssRUFBRTtBQURrQyxDQUE3QztBQUdBRCxrQkFBQSxHQUFrQkUsaUJBQWxCO0FBQ0FGLHlCQUFBLEdBQTRCRyxpQkFBNUI7O0FBQ0EsSUFBSUMsUUFBUSxHQUFHQyxnSUFBZjs7QUFDQSxJQUFJQyx3QkFBd0IsR0FBR0QsZ0tBQS9COztBQUNBLElBQUlFLHlCQUF5QixHQUFHRixrS0FBaEM7O0FBQ0EsSUFBSUcsTUFBTSxHQUFHRCx5QkFBeUIsQ0FBQ0YsbUJBQU8sQ0FBQyw0RUFBRCxDQUFSLENBQXRDOztBQUNBLElBQUlJLFNBQVMsR0FBR0gsd0JBQXdCLENBQUNELG1CQUFPLENBQUMsb0ZBQUQsQ0FBUixDQUF4Qzs7QUFDQSxJQUFJSyxpQkFBaUIsR0FBR0wsbUJBQU8sQ0FBQyxtSEFBRCxDQUEvQjs7QUFDQSxJQUFJTSxVQUFVLEdBQUdOLG1CQUFPLENBQUMsMkZBQUQsQ0FBeEI7O0FBQ0EsSUFBSU8sZ0JBQWdCLEdBQUdQLG1CQUFPLENBQUMsdUdBQUQsQ0FBOUI7O0FBQ0EsSUFBSVEsY0FBYyxHQUFHUixtQkFBTyxDQUFDLG1HQUFELENBQTVCOztBQUNBLElBQUlTLGNBQWMsR0FBR1QsbUJBQU8sQ0FBQyxtR0FBRCxDQUE1Qjs7QUFDQSxJQUFJVSxXQUFXLEdBQUdWLG1CQUFPLENBQUMsMkZBQUQsQ0FBekI7O0FBQ0EsU0FBU0gsaUJBQVQsT0FBdU47RUFBQTs7RUFBQSxJQUExTGMsaUJBQTBMLFFBQTFMQSxpQkFBMEw7RUFBQSxJQUF0S0MsV0FBc0ssUUFBdEtBLFdBQXNLO0VBQUEsSUFBeEpDLFNBQXdKLFFBQXhKQSxTQUF3SjtFQUFBLElBQTVJQyxLQUE0SSxRQUE1SUEsS0FBNEk7RUFBQSxJQUFwSUMsV0FBb0ksUUFBcElBLFdBQW9JO0VBQUEsSUFBdEhDLGNBQXNILFFBQXRIQSxjQUFzSDtFQUFBLElBQXJHQyxPQUFxRyxRQUFyR0EsT0FBcUc7RUFBQSxJQUEzRkMsYUFBMkYsUUFBM0ZBLGFBQTJGO0VBQUEsSUFBM0VDLFVBQTJFLFFBQTNFQSxVQUEyRTtFQUFBLElBQTlEQyxRQUE4RCxRQUE5REEsUUFBOEQ7RUFBQSxJQUFuREMsUUFBbUQsUUFBbkRBLFFBQW1EO0VBQUEsSUFBeENDLGNBQXdDLFFBQXhDQSxjQUF3QztFQUFBLElBQXZCQyxrQkFBdUIsUUFBdkJBLGtCQUF1QjtFQUNuTixJQUFNQyxPQUFPLEdBQUcsQ0FBQyxHQUFHckIsTUFBSixFQUFZc0IsVUFBWixDQUF1QnBCLGlCQUFpQixDQUFDcUIsbUJBQXpDLENBQWhCOztFQUNBLElBQUksQ0FBQ0YsT0FBTCxFQUFjO0lBQ1YsTUFBTSxJQUFJRyxLQUFKLENBQVUsZ0RBQVYsQ0FBTjtFQUNIOztFQUNELElBQVFDLFVBQVIsR0FBcUNKLE9BQXJDLENBQVFJLFVBQVI7RUFBQSxJQUFxQkMsSUFBckIsR0FBcUNMLE9BQXJDLENBQXFCSyxJQUFyQjtFQUFBLElBQTRCQyxHQUE1QixHQUFxQ04sT0FBckMsQ0FBNEJNLEdBQTVCLENBTG1OLENBTW5OOztFQUNBLElBQUlDLDJCQUEyQixHQUFHSCxVQUFVLENBQUNJLEdBQVgsQ0FBZXJCLGlCQUFmLENBQWxDLENBUG1OLENBUW5OO0VBQ0E7O0VBQ0EsSUFBSSxDQUFDb0IsMkJBQUwsRUFBa0M7SUFDOUJILFVBQVUsQ0FBQ0ssR0FBWCxDQUFldEIsaUJBQWYsRUFBa0MsSUFBSXVCLEdBQUosRUFBbEM7SUFDQUgsMkJBQTJCLEdBQUdILFVBQVUsQ0FBQ0ksR0FBWCxDQUFlckIsaUJBQWYsQ0FBOUI7RUFDSCxDQWJrTixDQWNuTjtFQUNBOzs7RUFDQSxJQUFNd0IsV0FBVyxHQUFHTixJQUFJLENBQUMsQ0FBRCxDQUFKLENBQVFsQixpQkFBUixFQUEyQixDQUEzQixDQUFwQjtFQUNBLElBQU15QixnQkFBZ0IsR0FBR0MsS0FBSyxDQUFDQyxPQUFOLENBQWN6QixTQUFTLENBQUMwQixPQUF4QixJQUFtQzFCLFNBQVMsQ0FBQzBCLE9BQVYsQ0FBa0IsQ0FBbEIsQ0FBbkMsR0FBMEQxQixTQUFTLENBQUMwQixPQUE3RixDQWpCbU4sQ0FrQm5OOztFQUNBLElBQU1DLG1CQUFtQixHQUFHSCxLQUFLLENBQUNDLE9BQU4sQ0FBY0gsV0FBZCxJQUE2QkEsV0FBVyxDQUFDLENBQUQsQ0FBeEMsR0FBOENBLFdBQTFFO0VBQ0E7QUFDSjtBQUNBO0VBQU07O0VBQ0YsSUFBTU0saUJBQWlCLEdBQUcsQ0FDdEJELG1CQURzQixDQUExQjtFQUdBLE9BQU8sYUFBY3JDLE1BQU0sV0FBTixDQUFldUMsYUFBZixDQUE2QnZDLE1BQU0sV0FBTixDQUFld0MsUUFBNUMsRUFBc0QsSUFBdEQsRUFBNERGLGlCQUFpQixDQUFDRyxHQUFsQixDQUFzQixVQUFDQyxnQkFBRCxFQUFvQjtJQUN2SDtNQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7TUFBYTtNQUFjMUMsTUFBTSxXQUFOLENBQWV1QyxhQUFmLENBQTZCckMsaUJBQWlCLENBQUN5QyxlQUFsQixDQUFrQ0MsUUFBL0QsRUFBeUU7UUFDeEZDLEdBQUcsRUFBRUgsZ0JBRG1GO1FBRXhGakQsS0FBSyxFQUFFLGFBQWNPLE1BQU0sV0FBTixDQUFldUMsYUFBZixDQUE2QmxDLGNBQWMsQ0FBQ3lDLGFBQTVDLEVBQTJEO1VBQzVFQyxjQUFjLEVBQUVwQyxLQUQ0RDtVQUU1RUMsV0FBVyxFQUFFQTtRQUYrRCxDQUEzRCxFQUdsQixhQUFjWixNQUFNLFdBQU4sQ0FBZXVDLGFBQWYsQ0FBNkJTLGVBQTdCLEVBQThDO1VBQzNEaEMsVUFBVSxFQUFFQSxVQUQrQztVQUUzREYsT0FBTyxFQUFFQSxPQUZrRDtVQUczREMsYUFBYSxFQUFFQTtRQUg0QyxDQUE5QyxFQUlkLGFBQWNmLE1BQU0sV0FBTixDQUFldUMsYUFBZixDQUE2QlUsZ0JBQTdCLEVBQStDO1VBQzVEL0IsUUFBUSxFQUFFQSxRQURrRDtVQUU1REMsY0FBYyxFQUFFQTtRQUY0QyxDQUEvQyxFQUdkLGFBQWNuQixNQUFNLFdBQU4sQ0FBZXVDLGFBQWYsQ0FBNkJXLGdCQUE3QixFQUErQyxJQUEvQyxFQUFxRCxhQUFjbEQsTUFBTSxXQUFOLENBQWV1QyxhQUFmLENBQTZCNUMsaUJBQTdCLEVBQWdEO1VBQ2hJYSxpQkFBaUIsRUFBRUEsaUJBRDZHO1VBRWhJbUIsR0FBRyxFQUFFQSxHQUYySDtVQUdoSUQsSUFBSSxFQUFFQSxJQUgwSDtVQUloSUQsVUFBVSxFQUFFRywyQkFKb0g7VUFLaElsQixTQUFTLEVBQUV1QixnQkFBZ0IsS0FBS1MsZ0JBQXJCLEdBQXdDaEMsU0FBeEMsR0FBb0QsSUFMaUU7VUFNaElELFdBQVcsRUFBRUEsV0FObUg7VUFPaEkwQyxJQUFJLEVBQUVULGdCQVAwSDtVQVFoSVUsUUFBUSxFQUFFZixtQkFBbUIsS0FBS0ssZ0JBUjhGO1VBU2hJdEIsa0JBQWtCLEVBQUVBO1FBVDRHLENBQWhELENBQW5FLENBSEEsQ0FKQSxDQUhJO01BRm1FLENBQXpFLEVBdUJoQixhQUFjcEIsTUFBTSxXQUFOLENBQWV1QyxhQUFmLENBQTZCdkMsTUFBTSxXQUFOLENBQWV3QyxRQUE1QyxFQUFzRCxJQUF0RCxFQUE0RDNCLGNBQTVELEVBQTRFSSxRQUE1RSxDQXZCRTtJQVJuQjtFQWdDSCxDQWpDZ0YsQ0FBNUQsQ0FBckI7QUFrQ0g7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7O0dBakVTdkIsaUI7O0tBQUFBLGlCOztBQWlFTCxTQUFTMkQsY0FBVCxDQUF3QkMsaUJBQXhCLEVBQTJDQyxjQUEzQyxFQUEyRDtFQUMzRCxJQUFJRCxpQkFBSixFQUF1QjtJQUNuQix3Q0FBb0NBLGlCQUFwQztJQUFBLElBQU9sQixPQUFQO0lBQUEsSUFBZ0JvQixnQkFBaEI7O0lBQ0EsSUFBTUMsTUFBTSxHQUFHSCxpQkFBaUIsQ0FBQ0ksTUFBbEIsS0FBNkIsQ0FBNUM7O0lBQ0EsSUFBSSxDQUFDLEdBQUdwRCxjQUFKLEVBQW9CcUQsWUFBcEIsQ0FBaUNKLGNBQWMsQ0FBQyxDQUFELENBQS9DLEVBQW9EbkIsT0FBcEQsQ0FBSixFQUFrRTtNQUM5RCxJQUFJbUIsY0FBYyxDQUFDLENBQUQsQ0FBZCxDQUFrQkssY0FBbEIsQ0FBaUNKLGdCQUFqQyxDQUFKLEVBQXdEO1FBQ3BELElBQUlDLE1BQUosRUFBWTtVQUNSLElBQU1JLE9BQU8sR0FBR1IsY0FBYyxDQUFDUyxTQUFELEVBQVlQLGNBQWMsQ0FBQyxDQUFELENBQWQsQ0FBa0JDLGdCQUFsQixDQUFaLENBQTlCO1VBQ0EsT0FBTyxDQUNIRCxjQUFjLENBQUMsQ0FBRCxDQURYLEVBRUgzRCxRQUFRLENBQUMsRUFBRCxFQUFLMkQsY0FBYyxDQUFDLENBQUQsQ0FBbkIsc0JBQ0hDLGdCQURHLEVBQ2dCLENBQ2hCSyxPQUFPLENBQUMsQ0FBRCxDQURTLEVBRWhCQSxPQUFPLENBQUMsQ0FBRCxDQUZTLEVBR2hCQSxPQUFPLENBQUMsQ0FBRCxDQUhTLEVBSWhCLFNBSmdCLENBRGhCLEVBRkwsQ0FBUDtRQVdIOztRQUNELE9BQU8sQ0FDSE4sY0FBYyxDQUFDLENBQUQsQ0FEWCxFQUVIM0QsUUFBUSxDQUFDLEVBQUQsRUFBSzJELGNBQWMsQ0FBQyxDQUFELENBQW5CLHNCQUNIQyxnQkFERyxFQUNnQkgsY0FBYyxDQUFDQyxpQkFBaUIsQ0FBQ1MsS0FBbEIsQ0FBd0IsQ0FBeEIsQ0FBRCxFQUE2QlIsY0FBYyxDQUFDLENBQUQsQ0FBZCxDQUFrQkMsZ0JBQWxCLENBQTdCLENBRDlCLEVBRkwsQ0FBUDtNQU1IO0lBQ0o7RUFDSjs7RUFDRCxPQUFPRCxjQUFQO0FBQ0gsQyxDQUNEOztBQUNBO0FBQ0E7QUFDQTs7O0FBQUksU0FBU1MsV0FBVCxDQUFxQkMsUUFBckIsRUFBK0I7RUFDL0I7RUFDQSxJQUFJLE9BQTZCLEVBRkYsQ0FHL0I7O0VBQ0EsSUFBSSxNQUF1QztJQUN2QyxJQUFNQyxvQkFBb0IsR0FBR0MsT0FBTyxDQUFDeEQsS0FBckM7O0lBQ0EsSUFBSTtNQUNBd0QsT0FBTyxDQUFDeEQsS0FBUixHQUFnQixZQUFlO1FBQUEsa0NBQVh5RCxRQUFXO1VBQVhBLFFBQVc7UUFBQTs7UUFDM0I7UUFDQSxJQUFJLENBQUNBLFFBQVEsQ0FBQyxDQUFELENBQVIsQ0FBWUMsUUFBWixDQUFxQiwwQ0FBckIsQ0FBTCxFQUF1RTtVQUNuRUgsb0JBQW9CLE1BQXBCLFNBQXdCRSxRQUF4QjtRQUNIO01BQ0osQ0FMRDs7TUFNQSxPQUFPbkUsU0FBUyxXQUFULENBQWtCK0QsV0FBbEIsQ0FBOEJDLFFBQTlCLENBQVA7SUFDSCxDQVJELFNBUVM7TUFDTEUsT0FBTyxDQUFDeEQsS0FBUixHQUFnQnVELG9CQUFoQjtJQUNIO0VBQ0o7O0VBQ0QsT0FBT2pFLFNBQVMsV0FBVCxDQUFrQitELFdBQWxCLENBQThCQyxRQUE5QixDQUFQO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7OztBQUFJLFNBQVNLLHNCQUFULENBQWdDQyxPQUFoQyxFQUF5QztFQUN6QyxJQUFNQyxJQUFJLEdBQUdELE9BQU8sQ0FBQ0UscUJBQVIsRUFBYjtFQUNBLE9BQU9ELElBQUksQ0FBQ0UsR0FBTCxJQUFZLENBQW5CO0FBQ0g7O0lBQ0tDLHFCOzs7Ozs7Ozs7Ozs7O1dBQ0YsNkJBQW9CO01BQ2hCO01BQ0EsSUFBUUMsaUJBQVIsR0FBK0IsS0FBS0MsS0FBcEMsQ0FBUUQsaUJBQVI7TUFDQSxJQUFNRSxPQUFPLEdBQUdkLFdBQVcsQ0FBQyxJQUFELENBQTNCOztNQUNBLElBQUlZLGlCQUFpQixDQUFDRyxLQUFsQixJQUEyQkQsT0FBTyxZQUFZRSxXQUFsRCxFQUErRDtRQUMzRDtRQUNBSixpQkFBaUIsQ0FBQ0csS0FBbEIsR0FBMEIsS0FBMUIsQ0FGMkQsQ0FHM0Q7O1FBQ0FELE9BQU8sQ0FBQ0csS0FBUixHQUoyRCxDQUszRDs7UUFDQSxJQUFJLENBQUNYLHNCQUFzQixDQUFDUSxPQUFELENBQTNCLEVBQXNDO1VBQ2xDLElBQU1JLFdBQVcsR0FBR0MsUUFBUSxDQUFDQyxlQUE3QjtVQUNBLElBQU1DLFFBQVEsR0FBR0gsV0FBVyxDQUFDSSxLQUFaLENBQWtCQyxjQUFuQztVQUNBTCxXQUFXLENBQUNJLEtBQVosQ0FBa0JDLGNBQWxCLEdBQW1DLE1BQW5DLENBSGtDLENBSWxDO1VBQ0E7VUFDQTs7VUFDQUwsV0FBVyxDQUFDTSxjQUFaO1VBQ0FWLE9BQU8sQ0FBQ1csY0FBUjtVQUNBUCxXQUFXLENBQUNJLEtBQVosQ0FBa0JDLGNBQWxCLEdBQW1DRixRQUFuQztRQUNIO01BQ0o7SUFDSjs7O1dBQ0Qsa0JBQVM7TUFDTCxPQUFPLEtBQUtSLEtBQUwsQ0FBV2EsUUFBbEI7SUFDSDs7OztFQTFCK0IxRixNQUFNLFdBQU4sQ0FBZTJGLFM7O0FBNEJuRCxTQUFTaEcsaUJBQVQsUUFFOEI7RUFBQTs7RUFBQSxJQUZEYSxpQkFFQyxTQUZEQSxpQkFFQztFQUFBLElBRm1CbUIsR0FFbkIsU0FGbUJBLEdBRW5CO0VBQUEsSUFGeUJGLFVBRXpCLFNBRnlCQSxVQUV6QjtFQUFBLElBRnNDZixTQUV0QyxTQUZzQ0EsU0FFdEM7RUFBQSxJQUZrREQsV0FFbEQsU0FGa0RBLFdBRWxEO0VBQUEsSUFGZ0VpQixJQUVoRSxTQUZnRUEsSUFFaEU7RUFBQSxJQUE5QnlCLElBQThCLFNBQTlCQSxJQUE4QjtFQUFBLElBQXZCL0Isa0JBQXVCLFNBQXZCQSxrQkFBdUI7RUFDMUIsSUFBTUMsT0FBTyxHQUFHLENBQUMsR0FBR3JCLE1BQUosRUFBWXNCLFVBQVosQ0FBdUJwQixpQkFBaUIsQ0FBQzBGLHlCQUF6QyxDQUFoQjs7RUFDQSxJQUFJLENBQUN2RSxPQUFMLEVBQWM7SUFDVixNQUFNLElBQUlHLEtBQUosQ0FBVSw0Q0FBVixDQUFOO0VBQ0g7O0VBQ0QsSUFBUXFFLHNCQUFSLEdBQXlFeEUsT0FBekUsQ0FBUXdFLHNCQUFSO0VBQUEsSUFBdUNDLFFBQXZDLEdBQXlFekUsT0FBekUsQ0FBaUNLLElBQWpDO0VBQUEsSUFBa0RrRCxpQkFBbEQsR0FBeUV2RCxPQUF6RSxDQUFrRHVELGlCQUFsRCxDQUwwQixDQU0xQjs7RUFDQSxJQUFJbUIsU0FBUyxHQUFHdEUsVUFBVSxDQUFDSSxHQUFYLENBQWVzQixJQUFmLENBQWhCLENBUDBCLENBUTFCOztFQUNBLElBQUl6QyxTQUFTLElBQUk7RUFDakJBLFNBQVMsQ0FBQ3NGLE9BQVYsS0FBc0IsSUFEdEIsRUFDNEI7SUFDeEIsSUFBSUQsU0FBUyxJQUFJQSxTQUFTLENBQUNFLE1BQVYsS0FBcUIvRixpQkFBaUIsQ0FBQ2dHLFdBQWxCLENBQThCQyxnQkFBcEUsRUFBc0Y7TUFDbEY7TUFDQUosU0FBUyxDQUFDRSxNQUFWLEdBQW1CL0YsaUJBQWlCLENBQUNnRyxXQUFsQixDQUE4QkUsS0FBakQsQ0FGa0YsQ0FHbEY7O01BQ0FMLFNBQVMsQ0FBQ00sV0FBVixHQUF3QjNGLFNBQVMsQ0FBQ3NGLE9BQWxDLENBSmtGLENBS2xGOztNQUNBdEYsU0FBUyxDQUFDc0YsT0FBVixHQUFvQixJQUFwQjtJQUNILENBUEQsTUFPTztNQUNIO01BQ0E7TUFDQXZFLFVBQVUsQ0FBQ0ssR0FBWCxDQUFlcUIsSUFBZixFQUFxQjtRQUNqQjhDLE1BQU0sRUFBRS9GLGlCQUFpQixDQUFDZ0csV0FBbEIsQ0FBOEJFLEtBRHJCO1FBRWpCRSxJQUFJLEVBQUUsSUFGVztRQUdqQkQsV0FBVyxFQUFFM0YsU0FBUyxDQUFDc0YsT0FITjtRQUlqQk8sY0FBYyxFQUFFLElBQUl4RSxHQUFKO01BSkMsQ0FBckIsRUFIRyxDQVNIOztNQUNBckIsU0FBUyxDQUFDc0YsT0FBVixHQUFvQixJQUFwQixDQVZHLENBV0g7O01BQ0FELFNBQVMsR0FBR3RFLFVBQVUsQ0FBQ0ksR0FBWCxDQUFlc0IsSUFBZixDQUFaO0lBQ0g7RUFDSixDQWhDeUIsQ0FpQzFCOzs7RUFDQSxJQUFJLENBQUM0QyxTQUFELElBQWNBLFNBQVMsQ0FBQ0UsTUFBVixLQUFxQi9GLGlCQUFpQixDQUFDZ0csV0FBbEIsQ0FBOEJDLGdCQUFyRSxFQUF1RjtJQUNuRjtBQUNSO0FBQ0E7SUFBUTtJQUNBLElBQU1LLFdBQVcsR0FBR25ELGNBQWMsRUFDOUIsRUFEOEIsNEJBRTNCNUMsV0FGMkIsSUFHL0JxRixRQUgrQixDQUFsQztJQUlBO0FBQ1I7QUFDQTs7SUFBUXJFLFVBQVUsQ0FBQ0ssR0FBWCxDQUFlcUIsSUFBZixFQUFxQjtNQUNqQjhDLE1BQU0sRUFBRS9GLGlCQUFpQixDQUFDZ0csV0FBbEIsQ0FBOEJPLFVBRHJCO01BRWpCSCxJQUFJLEVBQUUsQ0FBQyxHQUFHbkcsVUFBSixFQUFnQnVHLG1CQUFoQixDQUFvQyxJQUFJQyxHQUFKLENBQVFoRixHQUFSLEVBQWFpRixRQUFRLENBQUNDLE1BQXRCLENBQXBDLEVBQW1FTCxXQUFuRSxDQUZXO01BR2pCSCxXQUFXLEVBQUUsSUFISTtNQUlqQlMsSUFBSSxFQUFFZixTQUFTLElBQUlBLFNBQVMsQ0FBQ0UsTUFBVixLQUFxQi9GLGlCQUFpQixDQUFDZ0csV0FBbEIsQ0FBOEJDLGdCQUFoRSxHQUFtRkosU0FBUyxDQUFDZSxJQUE3RixHQUFvR2hELFNBSnpGO01BS2pCeUMsY0FBYyxFQUFFUixTQUFTLElBQUlBLFNBQVMsQ0FBQ0UsTUFBVixLQUFxQi9GLGlCQUFpQixDQUFDZ0csV0FBbEIsQ0FBOEJDLGdCQUFoRSxHQUFtRkosU0FBUyxDQUFDUSxjQUE3RixHQUE4RyxJQUFJeEUsR0FBSjtJQUw3RyxDQUFyQixFQVZtRixDQWlCbkY7O0lBQ0FnRSxTQUFTLEdBQUd0RSxVQUFVLENBQUNJLEdBQVgsQ0FBZXNCLElBQWYsQ0FBWjtFQUNILENBckR5QixDQXNEMUI7OztFQUNBLElBQUksQ0FBQzRDLFNBQUwsRUFBZ0I7SUFDWixNQUFNLElBQUl2RSxLQUFKLENBQVUsZ0NBQVYsQ0FBTjtFQUNILENBekR5QixDQTBEMUI7OztFQUNBLElBQUl1RSxTQUFTLENBQUNNLFdBQVYsSUFBeUJOLFNBQVMsQ0FBQ08sSUFBdkMsRUFBNkM7SUFDekMsTUFBTSxJQUFJOUUsS0FBSixDQUFVLHNEQUFWLENBQU47RUFDSCxDQTdEeUIsQ0E4RDFCOzs7RUFDQSxJQUFJdUUsU0FBUyxDQUFDTyxJQUFkLEVBQW9CO0lBQ2hCO0FBQ1I7QUFDQTtJQUFRO0lBQ0EsV0FBMkMsQ0FBQyxHQUFHdEcsTUFBSixFQUFZK0csR0FBWixDQUFnQmhCLFNBQVMsQ0FBQ08sSUFBMUIsQ0FBM0M7SUFBQTtJQUFBLElBQU9VLFVBQVA7SUFBQSxJQUFtQkMsb0JBQW5CLFlBSmdCLENBS2hCOzs7SUFDQSxJQUFJLE9BQU9ELFVBQVAsS0FBc0IsUUFBMUIsRUFBb0M7TUFDaENFLE1BQU0sQ0FBQ04sUUFBUCxDQUFnQk8sSUFBaEIsR0FBdUJ4RixHQUF2QjtNQUNBLE9BQU8sSUFBUDtJQUNILENBVGUsQ0FVaEI7OztJQUNBb0UsU0FBUyxDQUFDTyxJQUFWLEdBQWlCLElBQWpCLENBWGdCLENBWWhCOztJQUNBYyxVQUFVLENBQUMsWUFBSTtNQUNYO01BQ0FwSCxNQUFNLFdBQU4sQ0FBZXFILGVBQWYsQ0FBK0IsWUFBSTtRQUMvQnhCLHNCQUFzQixDQUFDQyxRQUFELEVBQVdrQixVQUFYLEVBQXVCQyxvQkFBdkIsQ0FBdEI7TUFDSCxDQUZEO0lBR0gsQ0FMUyxDQUFWLENBYmdCLENBbUJoQjs7SUFDQSxDQUFDLEdBQUdqSCxNQUFKLEVBQVkrRyxHQUFaLENBQWdCLENBQUMsR0FBRzNHLGdCQUFKLEVBQXNCa0gscUJBQXRCLEVBQWhCO0VBQ0gsQ0FwRnlCLENBcUYxQjtFQUNBOzs7RUFDQSxJQUFJLENBQUN2QixTQUFTLENBQUNNLFdBQWYsRUFBNEI7SUFDeEIsQ0FBQyxHQUFHckcsTUFBSixFQUFZK0csR0FBWixDQUFnQixDQUFDLEdBQUczRyxnQkFBSixFQUFzQmtILHFCQUF0QixFQUFoQjtFQUNIOztFQUNELElBQU1DLE9BQU8sR0FBRzs7RUFDaEI7RUFBY3ZILE1BQU0sV0FBTixDQUFldUMsYUFBZixDQUE2QnJDLGlCQUFpQixDQUFDcUIsbUJBQWxCLENBQXNDcUIsUUFBbkUsRUFBNkU7SUFDdkZuRCxLQUFLLEVBQUU7TUFDSGlDLElBQUksRUFBRUEsSUFBSSxDQUFDLENBQUQsQ0FBSixDQUFRbEIsaUJBQVIsQ0FESDtNQUVIaUIsVUFBVSxFQUFFc0UsU0FBUyxDQUFDUSxjQUZuQjtNQUdIO01BQ0E1RSxHQUFHLEVBQUVBO0lBSkY7RUFEZ0YsQ0FBN0UsRUFPWG9FLFNBQVMsQ0FBQ00sV0FQQyxDQURkLENBMUYwQixDQW1HMUI7OztFQUNBLE9BQU9qRixrQkFBa0IsR0FBRyxhQUFjcEIsTUFBTSxXQUFOLENBQWV1QyxhQUFmLENBQTZCb0MscUJBQTdCLEVBQW9EO0lBQzFGQyxpQkFBaUIsRUFBRUE7RUFEdUUsQ0FBcEQsRUFFdkMyQyxPQUZ1QyxDQUFqQixHQUVYQSxPQUZkO0FBR0g7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7O0lBN0dTNUgsaUI7O01BQUFBLGlCOztBQTZHTCxTQUFTcUQsZUFBVCxRQUErRTtFQUFBLElBQXBEMEMsUUFBb0QsU0FBcERBLFFBQW9EO0VBQUEsSUFBekM1RSxPQUF5QyxTQUF6Q0EsT0FBeUM7RUFBQSxJQUEvQkMsYUFBK0IsU0FBL0JBLGFBQStCO0VBQUEsSUFBZkMsVUFBZSxTQUFmQSxVQUFlOztFQUMvRSxJQUFJQSxVQUFKLEVBQWdCO0lBQ1osT0FBTyxhQUFjaEIsTUFBTSxXQUFOLENBQWV1QyxhQUFmLENBQTZCdkMsTUFBTSxXQUFOLENBQWV3SCxRQUE1QyxFQUFzRDtNQUN2RUMsUUFBUSxFQUFFLGFBQWN6SCxNQUFNLFdBQU4sQ0FBZXVDLGFBQWYsQ0FBNkJ2QyxNQUFNLFdBQU4sQ0FBZXdDLFFBQTVDLEVBQXNELElBQXRELEVBQTREekIsYUFBNUQsRUFBMkVELE9BQTNFO0lBRCtDLENBQXRELEVBRWxCNEUsUUFGa0IsQ0FBckI7RUFHSDs7RUFDRCxPQUFPLGFBQWMxRixNQUFNLFdBQU4sQ0FBZXVDLGFBQWYsQ0FBNkJ2QyxNQUFNLFdBQU4sQ0FBZXdDLFFBQTVDLEVBQXNELElBQXRELEVBQTREa0QsUUFBNUQsQ0FBckI7QUFDSDs7TUFQWTFDLGU7O0FBUWIsU0FBUzBFLGNBQVQsUUFBdUM7RUFBQTs7RUFBQSxJQUFiQyxRQUFhLFNBQWJBLFFBQWE7RUFDbkMsSUFBTUMsTUFBTSxHQUFHLENBQUMsR0FBR3JILFdBQUosRUFBaUJzSCxTQUFqQixFQUFmO0VBQ0EsQ0FBQyxHQUFHN0gsTUFBSixFQUFZOEgsU0FBWixDQUFzQixZQUFJO0lBQ3RCRixNQUFNLENBQUNHLE9BQVAsQ0FBZUosUUFBZixFQUF5QixFQUF6QjtFQUNILENBRkQsRUFFRyxDQUNDQSxRQURELEVBRUNDLE1BRkQsQ0FGSDtFQU1BLE9BQU8sSUFBUDtBQUNIOztJQVRRRixjOztNQUFBQSxjOztJQVVITSxxQjs7Ozs7RUFxQkYsK0JBQVluRCxLQUFaLEVBQWtCO0lBQUE7O0lBQUE7O0lBQ2QsMkJBQU1BLEtBQU47SUFDQSxNQUFLb0QsS0FBTCxHQUFhO01BQ1ROLFFBQVEsRUFBRTtJQURELENBQWI7SUFGYztFQUtqQjs7OztXQWRELGtCQUFTO01BQ0wsSUFBTUEsUUFBUSxHQUFHLEtBQUtNLEtBQUwsQ0FBV04sUUFBNUI7O01BQ0EsSUFBSUEsUUFBUSxLQUFLLElBQWpCLEVBQXVCO1FBQ25CLE9BQU8sYUFBYzNILE1BQU0sV0FBTixDQUFldUMsYUFBZixDQUE2Qm1GLGNBQTdCLEVBQTZDO1VBQzlEQyxRQUFRLEVBQUVBO1FBRG9ELENBQTdDLENBQXJCO01BR0g7O01BQ0QsT0FBTyxLQUFLOUMsS0FBTCxDQUFXYSxRQUFsQjtJQUNIOzs7V0FuQkQsa0NBQWdDL0UsS0FBaEMsRUFBdUM7TUFDbkMsSUFBSXVILEdBQUo7O01BQ0EsSUFBSXZILEtBQUssSUFBSSxJQUFULEdBQWdCLEtBQUssQ0FBckIsR0FBeUIsQ0FBQ3VILEdBQUcsR0FBR3ZILEtBQUssQ0FBQ3dILE1BQWIsS0FBd0IsSUFBeEIsR0FBK0IsS0FBSyxDQUFwQyxHQUF3Q0QsR0FBRyxDQUFDRSxVQUFKLENBQWUsZUFBZixDQUFyRSxFQUFzRztRQUNsRyxJQUFNekcsR0FBRyxHQUFHaEIsS0FBSyxDQUFDd0gsTUFBTixDQUFhRSxLQUFiLENBQW1CLEdBQW5CLEVBQXdCLENBQXhCLENBQVo7UUFDQSxPQUFPO1VBQ0hWLFFBQVEsRUFBRWhHO1FBRFAsQ0FBUDtNQUdILENBUGtDLENBUW5DOzs7TUFDQSxNQUFNaEIsS0FBTjtJQUNIOzs7O0VBWCtCWCxNQUFNLFdBQU4sQ0FBZTJGLFM7O0FBNEJuRCxTQUFTekMsZ0JBQVQsUUFBeUM7RUFBQTs7RUFBQSxJQUFid0MsUUFBYSxTQUFiQSxRQUFhO0VBQ3JDLElBQU1rQyxNQUFNLEdBQUcsQ0FBQyxHQUFHckgsV0FBSixFQUFpQnNILFNBQWpCLEVBQWY7RUFDQSxPQUFPLGFBQWM3SCxNQUFNLFdBQU4sQ0FBZXVDLGFBQWYsQ0FBNkJ5RixxQkFBN0IsRUFBb0Q7SUFDckVKLE1BQU0sRUFBRUE7RUFENkQsQ0FBcEQsRUFFbEJsQyxRQUZrQixDQUFyQjtBQUdIOztJQUxReEMsZ0I7O01BQUFBLGdCOztJQU1Ib0YscUI7Ozs7O0VBbUJGLCtCQUFZekQsS0FBWixFQUFrQjtJQUFBOztJQUFBOztJQUNkLDRCQUFNQSxLQUFOO0lBQ0EsT0FBS29ELEtBQUwsR0FBYTtNQUNUTSxpQkFBaUIsRUFBRTtJQURWLENBQWI7SUFGYztFQUtqQjs7OztXQWRELGtCQUFTO01BQ0wsSUFBSSxLQUFLTixLQUFMLENBQVdNLGlCQUFmLEVBQWtDO1FBQzlCLE9BQU8sYUFBY3ZJLE1BQU0sV0FBTixDQUFldUMsYUFBZixDQUE2QnZDLE1BQU0sV0FBTixDQUFld0MsUUFBNUMsRUFBc0QsSUFBdEQsRUFBNEQsYUFBY3hDLE1BQU0sV0FBTixDQUFldUMsYUFBZixDQUE2QixNQUE3QixFQUFxQztVQUNoSWlHLElBQUksRUFBRSxRQUQwSDtVQUVoSUMsT0FBTyxFQUFFO1FBRnVILENBQXJDLENBQTFFLEVBR2pCLEtBQUs1RCxLQUFMLENBQVcxRCxjQUhNLEVBR1UsS0FBSzBELEtBQUwsQ0FBVzNELFFBSHJCLENBQXJCO01BSUg7O01BQ0QsT0FBTyxLQUFLMkQsS0FBTCxDQUFXYSxRQUFsQjtJQUNIOzs7V0FqQkQsa0NBQWdDL0UsS0FBaEMsRUFBdUM7TUFDbkMsSUFBSSxDQUFDQSxLQUFLLElBQUksSUFBVCxHQUFnQixLQUFLLENBQXJCLEdBQXlCQSxLQUFLLENBQUN3SCxNQUFoQyxNQUE0QyxnQkFBaEQsRUFBa0U7UUFDOUQsT0FBTztVQUNISSxpQkFBaUIsRUFBRTtRQURoQixDQUFQO01BR0gsQ0FMa0MsQ0FNbkM7OztNQUNBLE1BQU01SCxLQUFOO0lBQ0g7Ozs7RUFUK0JYLE1BQU0sV0FBTixDQUFlMkYsUzs7QUEwQm5ELFNBQVMxQyxnQkFBVCxRQUFxRTtFQUFBLElBQXpDL0IsUUFBeUMsU0FBekNBLFFBQXlDO0VBQUEsSUFBOUJDLGNBQThCLFNBQTlCQSxjQUE4QjtFQUFBLElBQWJ1RSxRQUFhLFNBQWJBLFFBQWE7RUFDakUsT0FBT3hFLFFBQVEsR0FBRyxhQUFjbEIsTUFBTSxXQUFOLENBQWV1QyxhQUFmLENBQTZCK0YscUJBQTdCLEVBQW9EO0lBQ2hGcEgsUUFBUSxFQUFFQSxRQURzRTtJQUVoRkMsY0FBYyxFQUFFQTtFQUZnRSxDQUFwRCxFQUc3QnVFLFFBSDZCLENBQWpCLEdBR0EsYUFBYzFGLE1BQU0sV0FBTixDQUFldUMsYUFBZixDQUE2QnZDLE1BQU0sV0FBTixDQUFld0MsUUFBNUMsRUFBc0QsSUFBdEQsRUFBNERrRCxRQUE1RCxDQUg3QjtBQUlIOztNQUxRekMsZ0I7O0FBT1QsSUFBSSxDQUFDLE9BQU96RCxPQUFPLFdBQWQsS0FBMkIsVUFBM0IsSUFBMEMsT0FBT0EsT0FBTyxXQUFkLEtBQTJCLFFBQTNCLElBQXVDQSxPQUFPLFdBQVAsS0FBb0IsSUFBdEcsS0FBZ0gsT0FBT0EsT0FBTyxXQUFQLENBQWdCa0osVUFBdkIsS0FBc0MsV0FBMUosRUFBdUs7RUFDcktwSixNQUFNLENBQUNDLGNBQVAsQ0FBc0JDLE9BQU8sV0FBN0IsRUFBdUMsWUFBdkMsRUFBcUQ7SUFBRUMsS0FBSyxFQUFFO0VBQVQsQ0FBckQ7RUFDQUgsTUFBTSxDQUFDcUosTUFBUCxDQUFjbkosT0FBTyxXQUFyQixFQUErQkEsT0FBL0I7RUFDQW9KLE1BQU0sQ0FBQ3BKLE9BQVAsR0FBaUJBLE9BQU8sV0FBeEI7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2xheW91dC1yb3V0ZXIuanM/MGJmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gT3V0ZXJMYXlvdXRSb3V0ZXI7XG5leHBvcnRzLklubmVyTGF5b3V0Um91dGVyID0gSW5uZXJMYXlvdXRSb3V0ZXI7XG52YXIgX2V4dGVuZHMgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9fZXh0ZW5kcy5qc1wiKS5kZWZhdWx0O1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5qc1wiKS5kZWZhdWx0O1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLmpzXCIpLmRlZmF1bHQ7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9yZWFjdERvbSA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwicmVhY3QtZG9tXCIpKTtcbnZhciBfYXBwUm91dGVyQ29udGV4dCA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dFwiKTtcbnZhciBfYXBwUm91dGVyID0gcmVxdWlyZShcIi4vYXBwLXJvdXRlclwiKTtcbnZhciBfaW5maW5pdGVQcm9taXNlID0gcmVxdWlyZShcIi4vaW5maW5pdGUtcHJvbWlzZVwiKTtcbnZhciBfZXJyb3JCb3VuZGFyeSA9IHJlcXVpcmUoXCIuL2Vycm9yLWJvdW5kYXJ5XCIpO1xudmFyIF9tYXRjaFNlZ21lbnRzID0gcmVxdWlyZShcIi4vbWF0Y2gtc2VnbWVudHNcIik7XG52YXIgX25hdmlnYXRpb24gPSByZXF1aXJlKFwiLi9uYXZpZ2F0aW9uXCIpO1xuZnVuY3Rpb24gT3V0ZXJMYXlvdXRSb3V0ZXIoeyBwYXJhbGxlbFJvdXRlcktleSAsIHNlZ21lbnRQYXRoICwgY2hpbGRQcm9wICwgZXJyb3IgLCBlcnJvclN0eWxlcyAsIHRlbXBsYXRlU3R5bGVzICwgbG9hZGluZyAsIGxvYWRpbmdTdHlsZXMgLCBoYXNMb2FkaW5nICwgdGVtcGxhdGUgLCBub3RGb3VuZCAsIG5vdEZvdW5kU3R5bGVzICwgcm9vdExheW91dEluY2x1ZGVkICB9KSB7XG4gICAgY29uc3QgY29udGV4dCA9ICgwLCBfcmVhY3QpLnVzZUNvbnRleHQoX2FwcFJvdXRlckNvbnRleHQuTGF5b3V0Um91dGVyQ29udGV4dCk7XG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IGV4cGVjdGVkIGxheW91dCByb3V0ZXIgdG8gYmUgbW91bnRlZCcpO1xuICAgIH1cbiAgICBjb25zdCB7IGNoaWxkTm9kZXMgLCB0cmVlICwgdXJsICB9ID0gY29udGV4dDtcbiAgICAvLyBHZXQgdGhlIGN1cnJlbnQgcGFyYWxsZWxSb3V0ZXIgY2FjaGUgbm9kZVxuICAgIGxldCBjaGlsZE5vZGVzRm9yUGFyYWxsZWxSb3V0ZXIgPSBjaGlsZE5vZGVzLmdldChwYXJhbGxlbFJvdXRlcktleSk7XG4gICAgLy8gSWYgdGhlIHBhcmFsbGVsIHJvdXRlciBjYWNoZSBub2RlIGRvZXMgbm90IGV4aXN0IHlldCwgY3JlYXRlIGl0LlxuICAgIC8vIFRoaXMgd3JpdGVzIHRvIHRoZSBjYWNoZSB3aGVuIHRoZXJlIGlzIG5vIGl0ZW0gaW4gdGhlIGNhY2hlIHlldC4gSXQgbmV2ZXIgKm92ZXJ3cml0ZXMqIGV4aXN0aW5nIGNhY2hlIGl0ZW1zIHdoaWNoIGlzIHdoeSBpdCdzIHNhZmUgaW4gY29uY3VycmVudCBtb2RlLlxuICAgIGlmICghY2hpbGROb2Rlc0ZvclBhcmFsbGVsUm91dGVyKSB7XG4gICAgICAgIGNoaWxkTm9kZXMuc2V0KHBhcmFsbGVsUm91dGVyS2V5LCBuZXcgTWFwKCkpO1xuICAgICAgICBjaGlsZE5vZGVzRm9yUGFyYWxsZWxSb3V0ZXIgPSBjaGlsZE5vZGVzLmdldChwYXJhbGxlbFJvdXRlcktleSk7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgYWN0aXZlIHNlZ21lbnQgaW4gdGhlIHRyZWVcbiAgICAvLyBUaGUgcmVhc29uIGFycmF5cyBhcmUgdXNlZCBpbiB0aGUgZGF0YSBmb3JtYXQgaXMgdGhhdCB0aGVzZSBhcmUgdHJhbnNmZXJyZWQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBicm93c2VyIHNvIGl0J3Mgb3B0aW1pemVkIHRvIHNhdmUgYnl0ZXMuXG4gICAgY29uc3QgdHJlZVNlZ21lbnQgPSB0cmVlWzFdW3BhcmFsbGVsUm91dGVyS2V5XVswXTtcbiAgICBjb25zdCBjaGlsZFByb3BTZWdtZW50ID0gQXJyYXkuaXNBcnJheShjaGlsZFByb3Auc2VnbWVudCkgPyBjaGlsZFByb3Auc2VnbWVudFsxXSA6IGNoaWxkUHJvcC5zZWdtZW50O1xuICAgIC8vIElmIHNlZ21lbnQgaXMgYW4gYXJyYXkgaXQncyBhIGR5bmFtaWMgcm91dGUgYW5kIHdlIHdhbnQgdG8gcmVhZCB0aGUgZHluYW1pYyByb3V0ZSB2YWx1ZSBhcyB0aGUgc2VnbWVudCB0byBnZXQgZnJvbSB0aGUgY2FjaGUuXG4gICAgY29uc3QgY3VycmVudENoaWxkU2VnbWVudCA9IEFycmF5LmlzQXJyYXkodHJlZVNlZ21lbnQpID8gdHJlZVNlZ21lbnRbMV0gOiB0cmVlU2VnbWVudDtcbiAgICAvKipcbiAgICogRGVjaWRlcyB3aGljaCBzZWdtZW50cyB0byBrZWVwIHJlbmRlcmluZywgYWxsIHNlZ21lbnRzIHRoYXQgYXJlIG5vdCBhY3RpdmUgd2lsbCBiZSB3cmFwcGVkIGluIGA8T2Zmc2NyZWVuPmAuXG4gICAqLyAvLyBUT0RPLUFQUDogQWRkIGhhbmRsaW5nIG9mIGA8T2Zmc2NyZWVuPmAgd2hlbiBpdCdzIGF2YWlsYWJsZS5cbiAgICBjb25zdCBwcmVzZXJ2ZWRTZWdtZW50cyA9IFtcbiAgICAgICAgY3VycmVudENoaWxkU2VnbWVudFxuICAgIF07XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgcHJlc2VydmVkU2VnbWVudHMubWFwKChwcmVzZXJ2ZWRTZWdtZW50KT0+e1xuICAgICAgICByZXR1cm4oLypcbiAgICAgICAgICAgIC0gRXJyb3IgYm91bmRhcnlcbiAgICAgICAgICAgICAgLSBPbmx5IHJlbmRlcnMgZXJyb3IgYm91bmRhcnkgaWYgZXJyb3IgY29tcG9uZW50IGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAtIFJlbmRlcmVkIGZvciBlYWNoIHNlZ21lbnQgdG8gZW5zdXJlIHRoZXkgaGF2ZSB0aGVpciBvd24gZXJyb3Igc3RhdGUuXG4gICAgICAgICAgICAtIExvYWRpbmcgYm91bmRhcnlcbiAgICAgICAgICAgICAgLSBPbmx5IHJlbmRlcnMgc3VzcGVuc2UgYm91bmRhcnkgaWYgbG9hZGluZyBjb21wb25lbnRzIGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAtIFJlbmRlcmVkIGZvciBlYWNoIHNlZ21lbnQgdG8gZW5zdXJlIHRoZXkgaGF2ZSB0aGVpciBvd24gbG9hZGluZyBzdGF0ZS5cbiAgICAgICAgICAgICAgLSBQYXNzZWQgdG8gdGhlIHJvdXRlciBkdXJpbmcgcmVuZGVyaW5nIHRvIGVuc3VyZSBpdCBjYW4gYmUgaW1tZWRpYXRlbHkgcmVuZGVyZWQgd2hlbiBzdXNwZW5kaW5nIG9uIGEgRmxpZ2h0IGZldGNoLlxuICAgICAgICAgICovIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfYXBwUm91dGVyQ29udGV4dC5UZW1wbGF0ZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgICAgIGtleTogcHJlc2VydmVkU2VnbWVudCxcbiAgICAgICAgICAgIHZhbHVlOiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2Vycm9yQm91bmRhcnkuRXJyb3JCb3VuZGFyeSwge1xuICAgICAgICAgICAgICAgIGVycm9yQ29tcG9uZW50OiBlcnJvcixcbiAgICAgICAgICAgICAgICBlcnJvclN0eWxlczogZXJyb3JTdHlsZXNcbiAgICAgICAgICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChMb2FkaW5nQm91bmRhcnksIHtcbiAgICAgICAgICAgICAgICBoYXNMb2FkaW5nOiBoYXNMb2FkaW5nLFxuICAgICAgICAgICAgICAgIGxvYWRpbmc6IGxvYWRpbmcsXG4gICAgICAgICAgICAgICAgbG9hZGluZ1N0eWxlczogbG9hZGluZ1N0eWxlc1xuICAgICAgICAgICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KE5vdEZvdW5kQm91bmRhcnksIHtcbiAgICAgICAgICAgICAgICBub3RGb3VuZDogbm90Rm91bmQsXG4gICAgICAgICAgICAgICAgbm90Rm91bmRTdHlsZXM6IG5vdEZvdW5kU3R5bGVzXG4gICAgICAgICAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmVkaXJlY3RCb3VuZGFyeSwgbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KElubmVyTGF5b3V0Um91dGVyLCB7XG4gICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXJLZXk6IHBhcmFsbGVsUm91dGVyS2V5LFxuICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgIHRyZWU6IHRyZWUsXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlczogY2hpbGROb2Rlc0ZvclBhcmFsbGVsUm91dGVyLFxuICAgICAgICAgICAgICAgIGNoaWxkUHJvcDogY2hpbGRQcm9wU2VnbWVudCA9PT0gcHJlc2VydmVkU2VnbWVudCA/IGNoaWxkUHJvcCA6IG51bGwsXG4gICAgICAgICAgICAgICAgc2VnbWVudFBhdGg6IHNlZ21lbnRQYXRoLFxuICAgICAgICAgICAgICAgIHBhdGg6IHByZXNlcnZlZFNlZ21lbnQsXG4gICAgICAgICAgICAgICAgaXNBY3RpdmU6IGN1cnJlbnRDaGlsZFNlZ21lbnQgPT09IHByZXNlcnZlZFNlZ21lbnQsXG4gICAgICAgICAgICAgICAgcm9vdExheW91dEluY2x1ZGVkOiByb290TGF5b3V0SW5jbHVkZWRcbiAgICAgICAgICAgIH0pKSkpKVxuICAgICAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIHRlbXBsYXRlU3R5bGVzLCB0ZW1wbGF0ZSkpKTtcbiAgICB9KSk7XG59XG5cbi8qKlxuICogQWRkIHJlZmV0Y2ggbWFya2VyIHRvIHJvdXRlciBzdGF0ZSBhdCB0aGUgcG9pbnQgb2YgdGhlIGN1cnJlbnQgbGF5b3V0IHNlZ21lbnQuXG4gKiBUaGlzIGVuc3VyZXMgdGhlIHJlc3BvbnNlIHJldHVybmVkIGlzIG5vdCBmdXJ0aGVyIGRvd24gdGhhbiB0aGUgY3VycmVudCBsYXlvdXQgc2VnbWVudC5cbiAqLyBmdW5jdGlvbiB3YWxrQWRkUmVmZXRjaChzZWdtZW50UGF0aFRvV2FsaywgdHJlZVRvUmVjcmVhdGUpIHtcbiAgICBpZiAoc2VnbWVudFBhdGhUb1dhbGspIHtcbiAgICAgICAgY29uc3QgW3NlZ21lbnQsIHBhcmFsbGVsUm91dGVLZXldID0gc2VnbWVudFBhdGhUb1dhbGs7XG4gICAgICAgIGNvbnN0IGlzTGFzdCA9IHNlZ21lbnRQYXRoVG9XYWxrLmxlbmd0aCA9PT0gMjtcbiAgICAgICAgaWYgKCgwLCBfbWF0Y2hTZWdtZW50cykubWF0Y2hTZWdtZW50KHRyZWVUb1JlY3JlYXRlWzBdLCBzZWdtZW50KSkge1xuICAgICAgICAgICAgaWYgKHRyZWVUb1JlY3JlYXRlWzFdLmhhc093blByb3BlcnR5KHBhcmFsbGVsUm91dGVLZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGFzdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJUcmVlID0gd2Fsa0FkZFJlZmV0Y2godW5kZWZpbmVkLCB0cmVlVG9SZWNyZWF0ZVsxXVtwYXJhbGxlbFJvdXRlS2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmVlVG9SZWNyZWF0ZVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9leHRlbmRzKHt9LCB0cmVlVG9SZWNyZWF0ZVsxXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtwYXJhbGxlbFJvdXRlS2V5XTogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmVmZXRjaCcsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgdHJlZVRvUmVjcmVhdGVbMF0sXG4gICAgICAgICAgICAgICAgICAgIF9leHRlbmRzKHt9LCB0cmVlVG9SZWNyZWF0ZVsxXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgW3BhcmFsbGVsUm91dGVLZXldOiB3YWxrQWRkUmVmZXRjaChzZWdtZW50UGF0aFRvV2Fsay5zbGljZSgyKSwgdHJlZVRvUmVjcmVhdGVbMV1bcGFyYWxsZWxSb3V0ZUtleV0pXG4gICAgICAgICAgICAgICAgICAgIH0pLCBcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cmVlVG9SZWNyZWF0ZTtcbn1cbi8vIFRPRE8tQVBQOiBSZXBsYWNlIHdpdGggbmV3IFJlYWN0IEFQSSBmb3IgZmluZGluZyBkb20gbm9kZXMgd2l0aG91dCBhIGByZWZgIHdoZW4gYXZhaWxhYmxlXG4vKipcbiAqIFdyYXBzIFJlYWN0RE9NLmZpbmRET01Ob2RlIHdpdGggYWRkaXRpb25hbCBsb2dpYyB0byBoaWRlIFJlYWN0IFN0cmljdCBNb2RlIHdhcm5pbmdcbiAqLyBmdW5jdGlvbiBmaW5kRE9NTm9kZShpbnN0YW5jZSkge1xuICAgIC8vIFRyZWUtc2hha2UgZm9yIHNlcnZlciBidW5kbGVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbnVsbDtcbiAgICAvLyBPbmx5IGFwcGx5IHN0cmljdCBtb2RlIHdhcm5pbmcgd2hlbiBub3QgaW4gcHJvZHVjdGlvblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsQ29uc29sZUVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IgPSAoLi4ubWVzc2FnZXMpPT57XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIHN0cmljdCBtb2RlIHdhcm5pbmcgZm9yIHRoZSBmaW5kRG9tTm9kZSBjYWxsIGJlbG93XG4gICAgICAgICAgICAgICAgaWYgKCFtZXNzYWdlc1swXS5pbmNsdWRlcygnV2FybmluZzogJXMgaXMgZGVwcmVjYXRlZCBpbiBTdHJpY3RNb2RlLicpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsQ29uc29sZUVycm9yKC4uLm1lc3NhZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIF9yZWFjdERvbS5kZWZhdWx0LmZpbmRET01Ob2RlKGluc3RhbmNlKTtcbiAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgY29uc29sZS5lcnJvciA9IG9yaWdpbmFsQ29uc29sZUVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfcmVhY3REb20uZGVmYXVsdC5maW5kRE9NTm9kZShpbnN0YW5jZSk7XG59XG4vKipcbiAqIENoZWNrIGlmIHRoZSB0b3Agb2YgdGhlIEhUTUxFbGVtZW50IGlzIGluIHRoZSB2aWV3cG9ydC5cbiAqLyBmdW5jdGlvbiB0b3BPZkVsZW1lbnRJblZpZXdwb3J0KGVsZW1lbnQpIHtcbiAgICBjb25zdCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gcmVjdC50b3AgPj0gMDtcbn1cbmNsYXNzIFNjcm9sbEFuZEZvY3VzSGFuZGxlciBleHRlbmRzIF9yZWFjdC5kZWZhdWx0LkNvbXBvbmVudCB7XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIC8vIEhhbmRsZSBzY3JvbGwgYW5kIGZvY3VzLCBpdCdzIG9ubHkgYXBwbGllZCBvbmNlIGluIHRoZSBmaXJzdCB1c2VFZmZlY3QgdGhhdCB0cmlnZ2VycyB0aGF0IGNoYW5nZWQuXG4gICAgICAgIGNvbnN0IHsgZm9jdXNBbmRTY3JvbGxSZWYgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBkb21Ob2RlID0gZmluZERPTU5vZGUodGhpcyk7XG4gICAgICAgIGlmIChmb2N1c0FuZFNjcm9sbFJlZi5hcHBseSAmJiBkb21Ob2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIFN0YXRlIGlzIG11dGF0ZWQgdG8gZW5zdXJlIHRoYXQgdGhlIGZvY3VzIGFuZCBzY3JvbGwgaXMgYXBwbGllZCBvbmx5IG9uY2UuXG4gICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZi5hcHBseSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gU2V0IGZvY3VzIG9uIHRoZSBlbGVtZW50XG4gICAgICAgICAgICBkb21Ob2RlLmZvY3VzKCk7XG4gICAgICAgICAgICAvLyBPbmx5IHNjcm9sbCBpbnRvIHZpZXdwb3J0IHdoZW4gdGhlIGxheW91dCBpcyBub3QgdmlzaWJsZSBjdXJyZW50bHkuXG4gICAgICAgICAgICBpZiAoIXRvcE9mRWxlbWVudEluVmlld3BvcnQoZG9tTm9kZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBodG1sRWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IGh0bWxFbGVtZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yO1xuICAgICAgICAgICAgICAgIGh0bWxFbGVtZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gJ2F1dG8nO1xuICAgICAgICAgICAgICAgIC8vIEluIENocm9tZS1iYXNlZCBicm93c2VycyB3ZSBuZWVkIHRvIGZvcmNlIHJlZmxvdyBiZWZvcmUgY2FsbGluZyBgc2Nyb2xsVG9gLlxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBpdCB3aWxsIG5vdCBwaWNrdXAgdGhlIGNoYW5nZSBpbiBzY3JvbGxCZWhhdmlvclxuICAgICAgICAgICAgICAgIC8vIE1vcmUgaW5mbyBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvaXNzdWVzLzQwNzE5I2lzc3VlY29tbWVudC0xMzM2MjQ4MDQyXG4gICAgICAgICAgICAgICAgaHRtbEVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgICAgICAgICBkb21Ob2RlLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICAgICAgaHRtbEVsZW1lbnQuc3R5bGUuc2Nyb2xsQmVoYXZpb3IgPSBleGlzdGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgIH1cbn1cbmZ1bmN0aW9uIElubmVyTGF5b3V0Um91dGVyKHsgcGFyYWxsZWxSb3V0ZXJLZXkgLCB1cmwgLCBjaGlsZE5vZGVzICwgY2hpbGRQcm9wICwgc2VnbWVudFBhdGggLCB0cmVlICwgLy8gVE9ETy1BUFA6IGltcGxlbWVudCBgPE9mZnNjcmVlbj5gIHdoZW4gYXZhaWxhYmxlLlxuLy8gaXNBY3RpdmUsXG5wYXRoICwgcm9vdExheW91dEluY2x1ZGVkICB9KSB7XG4gICAgY29uc3QgY29udGV4dCA9ICgwLCBfcmVhY3QpLnVzZUNvbnRleHQoX2FwcFJvdXRlckNvbnRleHQuR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCk7XG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IGdsb2JhbCBsYXlvdXQgcm91dGVyIG5vdCBtb3VudGVkJyk7XG4gICAgfVxuICAgIGNvbnN0IHsgY2hhbmdlQnlTZXJ2ZXJSZXNwb25zZSAsIHRyZWU6IGZ1bGxUcmVlICwgZm9jdXNBbmRTY3JvbGxSZWYgIH0gPSBjb250ZXh0O1xuICAgIC8vIFJlYWQgc2VnbWVudCBwYXRoIGZyb20gdGhlIHBhcmFsbGVsIHJvdXRlciBjYWNoZSBub2RlLlxuICAgIGxldCBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzLmdldChwYXRoKTtcbiAgICAvLyBJZiBjaGlsZFByb3AgaXMgYXZhaWxhYmxlIHRoaXMgbWVhbnMgaXQncyB0aGUgRmxpZ2h0IC8gU1NSIGNhc2UuXG4gICAgaWYgKGNoaWxkUHJvcCAmJiAvLyBUT0RPLUFQUDogdmVyaWZ5IGlmIHRoaXMgY2FuIGJlIG51bGwgYmFzZWQgb24gdXNlciBjb2RlXG4gICAgY2hpbGRQcm9wLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuc3RhdHVzID09PSBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5MQVpZX0lOSVRJQUxJWkVEKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE8tQVBQOiBoYW5kbGUgY2hhbmdpbmcgb2YgdGhlIHR5cGVcbiAgICAgICAgICAgIGNoaWxkTm9kZS5zdGF0dXMgPSBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5SRUFEWTtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETy1BUFA6IGhhbmRsZSBjaGFuZ2luZyBvZiB0aGUgdHlwZVxuICAgICAgICAgICAgY2hpbGROb2RlLnN1YlRyZWVEYXRhID0gY2hpbGRQcm9wLmN1cnJlbnQ7XG4gICAgICAgICAgICAvLyBNdXRhdGVzIHRoZSBwcm9wIGluIG9yZGVyIHRvIGNsZWFuIHVwIHRoZSBtZW1vcnkgYXNzb2NpYXRlZCB3aXRoIHRoZSBzdWJUcmVlRGF0YSBhcyBpdCBpcyBub3cgcGFydCBvZiB0aGUgY2FjaGUuXG4gICAgICAgICAgICBjaGlsZFByb3AuY3VycmVudCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBBZGQgdGhlIHNlZ21lbnQncyBzdWJUcmVlRGF0YSB0byB0aGUgY2FjaGUuXG4gICAgICAgICAgICAvLyBUaGlzIHdyaXRlcyB0byB0aGUgY2FjaGUgd2hlbiB0aGVyZSBpcyBubyBpdGVtIGluIHRoZSBjYWNoZSB5ZXQuIEl0IG5ldmVyICpvdmVyd3JpdGVzKiBleGlzdGluZyBjYWNoZSBpdGVtcyB3aGljaCBpcyB3aHkgaXQncyBzYWZlIGluIGNvbmN1cnJlbnQgbW9kZS5cbiAgICAgICAgICAgIGNoaWxkTm9kZXMuc2V0KHBhdGgsIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLlJFQURZLFxuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgc3ViVHJlZURhdGE6IGNoaWxkUHJvcC5jdXJyZW50LFxuICAgICAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gTXV0YXRlcyB0aGUgcHJvcCBpbiBvcmRlciB0byBjbGVhbiB1cCB0aGUgbWVtb3J5IGFzc29jaWF0ZWQgd2l0aCB0aGUgc3ViVHJlZURhdGEgYXMgaXQgaXMgbm93IHBhcnQgb2YgdGhlIGNhY2hlLlxuICAgICAgICAgICAgY2hpbGRQcm9wLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgLy8gSW4gdGhlIGFib3ZlIGNhc2UgY2hpbGROb2RlIHdhcyBzZXQgb24gY2hpbGROb2Rlcywgc28gd2UgaGF2ZSB0byBnZXQgaXQgZnJvbSB0aGUgY2FjaGVOb2RlcyBhZ2Fpbi5cbiAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXMuZ2V0KHBhdGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFdoZW4gY2hpbGROb2RlIGlzIG5vdCBhdmFpbGFibGUgZHVyaW5nIHJlbmRlcmluZyBjbGllbnQtc2lkZSB3ZSBuZWVkIHRvIGZldGNoIGl0IGZyb20gdGhlIHNlcnZlci5cbiAgICBpZiAoIWNoaWxkTm9kZSB8fCBjaGlsZE5vZGUuc3RhdHVzID09PSBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5MQVpZX0lOSVRJQUxJWkVEKSB7XG4gICAgICAgIC8qKlxuICAgICAqIFJvdXRlciBzdGF0ZSB3aXRoIHJlZmV0Y2ggbWFya2VyIGFkZGVkXG4gICAgICovIC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgY29uc3QgcmVmZXRjaFRyZWUgPSB3YWxrQWRkUmVmZXRjaChbXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgIC4uLnNlZ21lbnRQYXRoXG4gICAgICAgIF0sIGZ1bGxUcmVlKTtcbiAgICAgICAgLyoqXG4gICAgICogRmxpZ2h0IGRhdGEgZmV0Y2gga2lja2VkIG9mZiBkdXJpbmcgcmVuZGVyIGFuZCBwdXQgaW50byB0aGUgY2FjaGUuXG4gICAgICovIGNoaWxkTm9kZXMuc2V0KHBhdGgsIHtcbiAgICAgICAgICAgIHN0YXR1czogX2FwcFJvdXRlckNvbnRleHQuQ2FjaGVTdGF0ZXMuREFUQV9GRVRDSCxcbiAgICAgICAgICAgIGRhdGE6ICgwLCBfYXBwUm91dGVyKS5mZXRjaFNlcnZlclJlc3BvbnNlKG5ldyBVUkwodXJsLCBsb2NhdGlvbi5vcmlnaW4pLCByZWZldGNoVHJlZSksXG4gICAgICAgICAgICBzdWJUcmVlRGF0YTogbnVsbCxcbiAgICAgICAgICAgIGhlYWQ6IGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuc3RhdHVzID09PSBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5MQVpZX0lOSVRJQUxJWkVEID8gY2hpbGROb2RlLmhlYWQgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogY2hpbGROb2RlICYmIGNoaWxkTm9kZS5zdGF0dXMgPT09IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLkxBWllfSU5JVElBTElaRUQgPyBjaGlsZE5vZGUucGFyYWxsZWxSb3V0ZXMgOiBuZXcgTWFwKClcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEluIHRoZSBhYm92ZSBjYXNlIGNoaWxkTm9kZSB3YXMgc2V0IG9uIGNoaWxkTm9kZXMsIHNvIHdlIGhhdmUgdG8gZ2V0IGl0IGZyb20gdGhlIGNhY2hlTm9kZXMgYWdhaW4uXG4gICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXMuZ2V0KHBhdGgpO1xuICAgIH1cbiAgICAvLyBUaGlzIGNhc2Ugc2hvdWxkIG5ldmVyIGhhcHBlbiBzbyBpdCB0aHJvd3MgYW4gZXJyb3IuIEl0IGluZGljYXRlcyB0aGVyZSdzIGEgYnVnIGluIHRoZSBOZXh0LmpzLlxuICAgIGlmICghY2hpbGROb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hpbGQgbm9kZSBzaG91bGQgYWx3YXlzIGV4aXN0Jyk7XG4gICAgfVxuICAgIC8vIFRoaXMgY2FzZSBzaG91bGQgbmV2ZXIgaGFwcGVuIHNvIGl0IHRocm93cyBhbiBlcnJvci4gSXQgaW5kaWNhdGVzIHRoZXJlJ3MgYSBidWcgaW4gdGhlIE5leHQuanMuXG4gICAgaWYgKGNoaWxkTm9kZS5zdWJUcmVlRGF0YSAmJiBjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoaWxkIG5vZGUgc2hvdWxkIG5vdCBoYXZlIGJvdGggc3ViVHJlZURhdGEgYW5kIGRhdGEnKTtcbiAgICB9XG4gICAgLy8gSWYgY2FjaGUgbm9kZSBoYXMgYSBkYXRhIHJlcXVlc3Qgd2UgaGF2ZSB0byB1bndyYXAgcmVzcG9uc2UgYnkgYHVzZWAgYW5kIHVwZGF0ZSB0aGUgY2FjaGUuXG4gICAgaWYgKGNoaWxkTm9kZS5kYXRhKSB7XG4gICAgICAgIC8qKlxuICAgICAqIEZsaWdodCByZXNwb25zZSBkYXRhXG4gICAgICovIC8vIFdoZW4gdGhlIGRhdGEgaGFzIG5vdCByZXNvbHZlZCB5ZXQgYHVzZWAgd2lsbCBzdXNwZW5kIGhlcmUuXG4gICAgICAgIGNvbnN0IFtmbGlnaHREYXRhLCBvdmVycmlkZUNhbm9uaWNhbFVybF0gPSAoMCwgX3JlYWN0KS51c2UoY2hpbGROb2RlLmRhdGEpO1xuICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIG5hdmlnYXRpbmcgdG8gcGFnZSBpbiBgcGFnZXNgIGZyb20gYGFwcGBcbiAgICAgICAgaWYgKHR5cGVvZiBmbGlnaHREYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZWdtZW50UGF0aCBmcm9tIHRoZSBzZXJ2ZXIgZG9lcyBub3QgbWF0Y2ggdGhlIGxheW91dCdzIHNlZ21lbnRQYXRoXG4gICAgICAgIGNoaWxkTm9kZS5kYXRhID0gbnVsbDtcbiAgICAgICAgLy8gc2V0VGltZW91dCBpcyB1c2VkIHRvIHN0YXJ0IGEgbmV3IHRyYW5zaXRpb24gZHVyaW5nIHJlbmRlciwgdGhpcyBpcyBhbiBpbnRlbnRpb25hbCBoYWNrIGFyb3VuZCBSZWFjdC5cbiAgICAgICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBzdGFydFRyYW5zaXRpb24gZXhpc3RzXG4gICAgICAgICAgICBfcmVhY3QuZGVmYXVsdC5zdGFydFRyYW5zaXRpb24oKCk9PntcbiAgICAgICAgICAgICAgICBjaGFuZ2VCeVNlcnZlclJlc3BvbnNlKGZ1bGxUcmVlLCBmbGlnaHREYXRhLCBvdmVycmlkZUNhbm9uaWNhbFVybCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFN1c3BlbmQgaW5maW5pdGVseSBhcyBgY2hhbmdlQnlTZXJ2ZXJSZXNwb25zZWAgd2lsbCBjYXVzZSBhIGRpZmZlcmVudCBwYXJ0IG9mIHRoZSB0cmVlIHRvIGJlIHJlbmRlcmVkLlxuICAgICAgICAoMCwgX3JlYWN0KS51c2UoKDAsIF9pbmZpbml0ZVByb21pc2UpLmNyZWF0ZUluZmluaXRlUHJvbWlzZSgpKTtcbiAgICB9XG4gICAgLy8gSWYgY2FjaGUgbm9kZSBoYXMgbm8gc3ViVHJlZURhdGEgYW5kIG5vIGRhdGEgcmVxdWVzdCB3ZSBoYXZlIHRvIGluZmluaXRlbHkgc3VzcGVuZCBhcyB0aGUgZGF0YSB3aWxsIGxpa2VseSBmbG93IGluIGZyb20gYW5vdGhlciBwbGFjZS5cbiAgICAvLyBUT0RPLUFQUDogZG91YmxlIGNoZWNrIHVzZXJzIGNhbid0IHJldHVybiBudWxsIGluIGEgY29tcG9uZW50IHRoYXQgd2lsbCBraWNrIGluIGhlcmUuXG4gICAgaWYgKCFjaGlsZE5vZGUuc3ViVHJlZURhdGEpIHtcbiAgICAgICAgKDAsIF9yZWFjdCkudXNlKCgwLCBfaW5maW5pdGVQcm9taXNlKS5jcmVhdGVJbmZpbml0ZVByb21pc2UoKSk7XG4gICAgfVxuICAgIGNvbnN0IHN1YnRyZWUgPSAvLyBUaGUgbGF5b3V0IHJvdXRlciBjb250ZXh0IG5hcnJvd3MgZG93biB0cmVlIGFuZCBjaGlsZE5vZGVzIGF0IGVhY2ggbGV2ZWwuXG4gICAgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9hcHBSb3V0ZXJDb250ZXh0LkxheW91dFJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRyZWU6IHRyZWVbMV1bcGFyYWxsZWxSb3V0ZXJLZXldLFxuICAgICAgICAgICAgY2hpbGROb2RlczogY2hpbGROb2RlLnBhcmFsbGVsUm91dGVzLFxuICAgICAgICAgICAgLy8gVE9ETy1BUFA6IG92ZXJyaWRpbmcgb2YgdXJsIGZvciBwYXJhbGxlbCByb3V0ZXNcbiAgICAgICAgICAgIHVybDogdXJsXG4gICAgICAgIH1cbiAgICB9LCBjaGlsZE5vZGUuc3ViVHJlZURhdGEpO1xuICAgIC8vIEVuc3VyZSByb290IGxheW91dCBpcyBub3Qgd3JhcHBlZCBpbiBhIGRpdiBhcyB0aGUgcm9vdCBsYXlvdXQgcmVuZGVycyBgPGh0bWw+YFxuICAgIHJldHVybiByb290TGF5b3V0SW5jbHVkZWQgPyAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU2Nyb2xsQW5kRm9jdXNIYW5kbGVyLCB7XG4gICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiBmb2N1c0FuZFNjcm9sbFJlZlxuICAgIH0sIHN1YnRyZWUpIDogc3VidHJlZTtcbn1cbi8qKlxuICogUmVuZGVycyBzdXNwZW5zZSBib3VuZGFyeSB3aXRoIHRoZSBwcm92aWRlZCBcImxvYWRpbmdcIiBwcm9wZXJ0eSBhcyB0aGUgZmFsbGJhY2suXG4gKiBJZiBubyBsb2FkaW5nIHByb3BlcnR5IGlzIHByb3ZpZGVkIGl0IHJlbmRlcnMgdGhlIGNoaWxkcmVuIHdpdGhvdXQgYSBzdXNwZW5zZSBib3VuZGFyeS5cbiAqLyBmdW5jdGlvbiBMb2FkaW5nQm91bmRhcnkoeyBjaGlsZHJlbiAsIGxvYWRpbmcgLCBsb2FkaW5nU3R5bGVzICwgaGFzTG9hZGluZyAgfSkge1xuICAgIGlmIChoYXNMb2FkaW5nKSB7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuU3VzcGVuc2UsIHtcbiAgICAgICAgICAgIGZhbGxiYWNrOiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIGxvYWRpbmdTdHlsZXMsIGxvYWRpbmcpXG4gICAgICAgIH0sIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gSGFuZGxlUmVkaXJlY3QoeyByZWRpcmVjdCAgfSkge1xuICAgIGNvbnN0IHJvdXRlciA9ICgwLCBfbmF2aWdhdGlvbikudXNlUm91dGVyKCk7XG4gICAgKDAsIF9yZWFjdCkudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIHJvdXRlci5yZXBsYWNlKHJlZGlyZWN0LCB7fSk7XG4gICAgfSwgW1xuICAgICAgICByZWRpcmVjdCxcbiAgICAgICAgcm91dGVyXG4gICAgXSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5jbGFzcyBSZWRpcmVjdEVycm9yQm91bmRhcnkgZXh0ZW5kcyBfcmVhY3QuZGVmYXVsdC5Db21wb25lbnQge1xuICAgIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgaWYgKGVycm9yID09IG51bGwgPyB2b2lkIDAgOiAocmVmID0gZXJyb3IuZGlnZXN0KSA9PSBudWxsID8gdm9pZCAwIDogcmVmLnN0YXJ0c1dpdGgoJ05FWFRfUkVESVJFQ1QnKSkge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gZXJyb3IuZGlnZXN0LnNwbGl0KCc7JylbMV07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlZGlyZWN0OiB1cmxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmUtdGhyb3cgaWYgZXJyb3IgaXMgbm90IGZvciByZWRpcmVjdFxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCByZWRpcmVjdCA9IHRoaXMuc3RhdGUucmVkaXJlY3Q7XG4gICAgICAgIGlmIChyZWRpcmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChIYW5kbGVSZWRpcmVjdCwge1xuICAgICAgICAgICAgICAgIHJlZGlyZWN0OiByZWRpcmVjdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHByb3BzKXtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcmVkaXJlY3Q6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBSZWRpcmVjdEJvdW5kYXJ5KHsgY2hpbGRyZW4gIH0pIHtcbiAgICBjb25zdCByb3V0ZXIgPSAoMCwgX25hdmlnYXRpb24pLnVzZVJvdXRlcigpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmVkaXJlY3RFcnJvckJvdW5kYXJ5LCB7XG4gICAgICAgIHJvdXRlcjogcm91dGVyXG4gICAgfSwgY2hpbGRyZW4pO1xufVxuY2xhc3MgTm90Rm91bmRFcnJvckJvdW5kYXJ5IGV4dGVuZHMgX3JlYWN0LmRlZmF1bHQuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgICAgIGlmICgoZXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yLmRpZ2VzdCkgPT09ICdORVhUX05PVF9GT1VORCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbm90Rm91bmRUcmlnZ2VyZWQ6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmUtdGhyb3cgaWYgZXJyb3IgaXMgbm90IGZvciA0MDRcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUubm90Rm91bmRUcmlnZ2VyZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwicm9ib3RzXCIsXG4gICAgICAgICAgICAgICAgY29udGVudDogXCJub2luZGV4XCJcbiAgICAgICAgICAgIH0pLCB0aGlzLnByb3BzLm5vdEZvdW5kU3R5bGVzLCB0aGlzLnByb3BzLm5vdEZvdW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IocHJvcHMpe1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBub3RGb3VuZFRyaWdnZXJlZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBOb3RGb3VuZEJvdW5kYXJ5KHsgbm90Rm91bmQgLCBub3RGb3VuZFN0eWxlcyAsIGNoaWxkcmVuICB9KSB7XG4gICAgcmV0dXJuIG5vdEZvdW5kID8gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KE5vdEZvdW5kRXJyb3JCb3VuZGFyeSwge1xuICAgICAgICBub3RGb3VuZDogbm90Rm91bmQsXG4gICAgICAgIG5vdEZvdW5kU3R5bGVzOiBub3RGb3VuZFN0eWxlc1xuICAgIH0sIGNoaWxkcmVuKSA6IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYXlvdXQtcm91dGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIk91dGVyTGF5b3V0Um91dGVyIiwiSW5uZXJMYXlvdXRSb3V0ZXIiLCJfZXh0ZW5kcyIsInJlcXVpcmUiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwiX3JlYWN0IiwiX3JlYWN0RG9tIiwiX2FwcFJvdXRlckNvbnRleHQiLCJfYXBwUm91dGVyIiwiX2luZmluaXRlUHJvbWlzZSIsIl9lcnJvckJvdW5kYXJ5IiwiX21hdGNoU2VnbWVudHMiLCJfbmF2aWdhdGlvbiIsInBhcmFsbGVsUm91dGVyS2V5Iiwic2VnbWVudFBhdGgiLCJjaGlsZFByb3AiLCJlcnJvciIsImVycm9yU3R5bGVzIiwidGVtcGxhdGVTdHlsZXMiLCJsb2FkaW5nIiwibG9hZGluZ1N0eWxlcyIsImhhc0xvYWRpbmciLCJ0ZW1wbGF0ZSIsIm5vdEZvdW5kIiwibm90Rm91bmRTdHlsZXMiLCJyb290TGF5b3V0SW5jbHVkZWQiLCJjb250ZXh0IiwidXNlQ29udGV4dCIsIkxheW91dFJvdXRlckNvbnRleHQiLCJFcnJvciIsImNoaWxkTm9kZXMiLCJ0cmVlIiwidXJsIiwiY2hpbGROb2Rlc0ZvclBhcmFsbGVsUm91dGVyIiwiZ2V0Iiwic2V0IiwiTWFwIiwidHJlZVNlZ21lbnQiLCJjaGlsZFByb3BTZWdtZW50IiwiQXJyYXkiLCJpc0FycmF5Iiwic2VnbWVudCIsImN1cnJlbnRDaGlsZFNlZ21lbnQiLCJwcmVzZXJ2ZWRTZWdtZW50cyIsImNyZWF0ZUVsZW1lbnQiLCJGcmFnbWVudCIsIm1hcCIsInByZXNlcnZlZFNlZ21lbnQiLCJUZW1wbGF0ZUNvbnRleHQiLCJQcm92aWRlciIsImtleSIsIkVycm9yQm91bmRhcnkiLCJlcnJvckNvbXBvbmVudCIsIkxvYWRpbmdCb3VuZGFyeSIsIk5vdEZvdW5kQm91bmRhcnkiLCJSZWRpcmVjdEJvdW5kYXJ5IiwicGF0aCIsImlzQWN0aXZlIiwid2Fsa0FkZFJlZmV0Y2giLCJzZWdtZW50UGF0aFRvV2FsayIsInRyZWVUb1JlY3JlYXRlIiwicGFyYWxsZWxSb3V0ZUtleSIsImlzTGFzdCIsImxlbmd0aCIsIm1hdGNoU2VnbWVudCIsImhhc093blByb3BlcnR5Iiwic3ViVHJlZSIsInVuZGVmaW5lZCIsInNsaWNlIiwiZmluZERPTU5vZGUiLCJpbnN0YW5jZSIsIm9yaWdpbmFsQ29uc29sZUVycm9yIiwiY29uc29sZSIsIm1lc3NhZ2VzIiwiaW5jbHVkZXMiLCJ0b3BPZkVsZW1lbnRJblZpZXdwb3J0IiwiZWxlbWVudCIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ0b3AiLCJTY3JvbGxBbmRGb2N1c0hhbmRsZXIiLCJmb2N1c0FuZFNjcm9sbFJlZiIsInByb3BzIiwiZG9tTm9kZSIsImFwcGx5IiwiSFRNTEVsZW1lbnQiLCJmb2N1cyIsImh0bWxFbGVtZW50IiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJleGlzdGluZyIsInN0eWxlIiwic2Nyb2xsQmVoYXZpb3IiLCJnZXRDbGllbnRSZWN0cyIsInNjcm9sbEludG9WaWV3IiwiY2hpbGRyZW4iLCJDb21wb25lbnQiLCJHbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0IiwiY2hhbmdlQnlTZXJ2ZXJSZXNwb25zZSIsImZ1bGxUcmVlIiwiY2hpbGROb2RlIiwiY3VycmVudCIsInN0YXR1cyIsIkNhY2hlU3RhdGVzIiwiTEFaWV9JTklUSUFMSVpFRCIsIlJFQURZIiwic3ViVHJlZURhdGEiLCJkYXRhIiwicGFyYWxsZWxSb3V0ZXMiLCJyZWZldGNoVHJlZSIsIkRBVEFfRkVUQ0giLCJmZXRjaFNlcnZlclJlc3BvbnNlIiwiVVJMIiwibG9jYXRpb24iLCJvcmlnaW4iLCJoZWFkIiwidXNlIiwiZmxpZ2h0RGF0YSIsIm92ZXJyaWRlQ2Fub25pY2FsVXJsIiwid2luZG93IiwiaHJlZiIsInNldFRpbWVvdXQiLCJzdGFydFRyYW5zaXRpb24iLCJjcmVhdGVJbmZpbml0ZVByb21pc2UiLCJzdWJ0cmVlIiwiU3VzcGVuc2UiLCJmYWxsYmFjayIsIkhhbmRsZVJlZGlyZWN0IiwicmVkaXJlY3QiLCJyb3V0ZXIiLCJ1c2VSb3V0ZXIiLCJ1c2VFZmZlY3QiLCJyZXBsYWNlIiwiUmVkaXJlY3RFcnJvckJvdW5kYXJ5Iiwic3RhdGUiLCJyZWYiLCJkaWdlc3QiLCJzdGFydHNXaXRoIiwic3BsaXQiLCJOb3RGb3VuZEVycm9yQm91bmRhcnkiLCJub3RGb3VuZFRyaWdnZXJlZCIsIm5hbWUiLCJjb250ZW50IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/layout-router.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/match-segments.js":
/*!********************************************************************!*\
  !*** ./node_modules/next/dist/client/components/match-segments.js ***!
  \********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.matchSegment = void 0;\n\nvar matchSegment = function matchSegment(existingSegment, segment) {\n  // Common case: segment is just a string\n  if (typeof existingSegment === 'string' && typeof segment === 'string') {\n    return existingSegment === segment;\n  } // Dynamic parameter case: segment is an array with param/value. Both param and value are compared.\n\n\n  if (Array.isArray(existingSegment) && Array.isArray(segment)) {\n    return existingSegment[0] === segment[0] && existingSegment[1] === segment[1];\n  }\n\n  return false;\n};\n\nexports.matchSegment = matchSegment;\n\nif ((typeof exports[\"default\"] === 'function' || typeof exports[\"default\"] === 'object' && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === 'undefined') {\n  Object.defineProperty(exports[\"default\"], '__esModule', {\n    value: true\n  });\n  Object.assign(exports[\"default\"], exports);\n  module.exports = exports[\"default\"];\n}\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9tYXRjaC1zZWdtZW50cy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFDYkEsOENBQTZDO0VBQ3pDRyxLQUFLLEVBQUU7QUFEa0MsQ0FBN0M7QUFHQUQsb0JBQUEsR0FBdUIsS0FBSyxDQUE1Qjs7QUFDQSxJQUFNRSxZQUFZLEdBQUcsU0FBZkEsWUFBZSxDQUFDQyxlQUFELEVBQWtCQyxPQUFsQixFQUE0QjtFQUM3QztFQUNBLElBQUksT0FBT0QsZUFBUCxLQUEyQixRQUEzQixJQUF1QyxPQUFPQyxPQUFQLEtBQW1CLFFBQTlELEVBQXdFO0lBQ3BFLE9BQU9ELGVBQWUsS0FBS0MsT0FBM0I7RUFDSCxDQUo0QyxDQUs3Qzs7O0VBQ0EsSUFBSUMsS0FBSyxDQUFDQyxPQUFOLENBQWNILGVBQWQsS0FBa0NFLEtBQUssQ0FBQ0MsT0FBTixDQUFjRixPQUFkLENBQXRDLEVBQThEO0lBQzFELE9BQU9ELGVBQWUsQ0FBQyxDQUFELENBQWYsS0FBdUJDLE9BQU8sQ0FBQyxDQUFELENBQTlCLElBQXFDRCxlQUFlLENBQUMsQ0FBRCxDQUFmLEtBQXVCQyxPQUFPLENBQUMsQ0FBRCxDQUExRTtFQUNIOztFQUNELE9BQU8sS0FBUDtBQUNILENBVkQ7O0FBV0FKLG9CQUFBLEdBQXVCRSxZQUF2Qjs7QUFFQSxJQUFJLENBQUMsT0FBT0YsT0FBTyxXQUFkLEtBQTJCLFVBQTNCLElBQTBDLE9BQU9BLE9BQU8sV0FBZCxLQUEyQixRQUEzQixJQUF1Q0EsT0FBTyxXQUFQLEtBQW9CLElBQXRHLEtBQWdILE9BQU9BLE9BQU8sV0FBUCxDQUFnQk8sVUFBdkIsS0FBc0MsV0FBMUosRUFBdUs7RUFDcktULE1BQU0sQ0FBQ0MsY0FBUCxDQUFzQkMsT0FBTyxXQUE3QixFQUF1QyxZQUF2QyxFQUFxRDtJQUFFQyxLQUFLLEVBQUU7RUFBVCxDQUFyRDtFQUNBSCxNQUFNLENBQUNVLE1BQVAsQ0FBY1IsT0FBTyxXQUFyQixFQUErQkEsT0FBL0I7RUFDQVMsTUFBTSxDQUFDVCxPQUFQLEdBQWlCQSxPQUFPLFdBQXhCO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9tYXRjaC1zZWdtZW50cy5qcz9iY2IxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5tYXRjaFNlZ21lbnQgPSB2b2lkIDA7XG5jb25zdCBtYXRjaFNlZ21lbnQgPSAoZXhpc3RpbmdTZWdtZW50LCBzZWdtZW50KT0+e1xuICAgIC8vIENvbW1vbiBjYXNlOiBzZWdtZW50IGlzIGp1c3QgYSBzdHJpbmdcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nU2VnbWVudCA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHNlZ21lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBleGlzdGluZ1NlZ21lbnQgPT09IHNlZ21lbnQ7XG4gICAgfVxuICAgIC8vIER5bmFtaWMgcGFyYW1ldGVyIGNhc2U6IHNlZ21lbnQgaXMgYW4gYXJyYXkgd2l0aCBwYXJhbS92YWx1ZS4gQm90aCBwYXJhbSBhbmQgdmFsdWUgYXJlIGNvbXBhcmVkLlxuICAgIGlmIChBcnJheS5pc0FycmF5KGV4aXN0aW5nU2VnbWVudCkgJiYgQXJyYXkuaXNBcnJheShzZWdtZW50KSkge1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdTZWdtZW50WzBdID09PSBzZWdtZW50WzBdICYmIGV4aXN0aW5nU2VnbWVudFsxXSA9PT0gc2VnbWVudFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmV4cG9ydHMubWF0Y2hTZWdtZW50ID0gbWF0Y2hTZWdtZW50O1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRjaC1zZWdtZW50cy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtYXRjaFNlZ21lbnQiLCJleGlzdGluZ1NlZ21lbnQiLCJzZWdtZW50IiwiQXJyYXkiLCJpc0FycmF5IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/match-segments.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/reducer.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/client/components/reducer.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar _defineProperty = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/defineProperty.js */ \"(app-client)/./node_modules/next/dist/compiled/@babel/runtime/helpers/defineProperty.js\");\n\nvar _toConsumableArray = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/toConsumableArray.js */ \"(app-client)/./node_modules/next/dist/compiled/@babel/runtime/helpers/toConsumableArray.js\");\n\nvar _slicedToArray = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/slicedToArray.js */ \"(app-client)/./node_modules/next/dist/compiled/@babel/runtime/helpers/slicedToArray.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.createHrefFromUrl = createHrefFromUrl;\nexports.reducer = exports.ACTION_PREFETCH = exports.ACTION_SERVER_PATCH = exports.ACTION_RESTORE = exports.ACTION_NAVIGATE = exports.ACTION_REFRESH = void 0;\n\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"(app-client)/./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\n\nvar _appRouterContext = __webpack_require__(/*! ../../shared/lib/app-router-context */ \"(app-client)/./node_modules/next/dist/shared/lib/app-router-context.js\");\n\nvar _matchSegments = __webpack_require__(/*! ./match-segments */ \"(app-client)/./node_modules/next/dist/client/components/match-segments.js\");\n\nvar _appRouter = __webpack_require__(/*! ./app-router */ \"(app-client)/./node_modules/next/dist/client/components/app-router.js\");\n/**\n * Create data fetching record for Promise.\n */\n// TODO-APP: change `any` to type inference.\n\n\nfunction createRecordFromThenable(thenable) {\n  thenable.status = 'pending';\n  thenable.then(function (value) {\n    if (thenable.status === 'pending') {\n      thenable.status = 'fulfilled';\n      thenable.value = value;\n    }\n  }, function (err) {\n    if (thenable.status === 'pending') {\n      thenable.status = 'rejected';\n      thenable.value = err;\n    }\n  });\n  return thenable;\n}\n/**\n * Read record value or throw Promise if it's not resolved yet.\n */\n\n\nfunction readRecordValue(thenable) {\n  // @ts-expect-error TODO: fix type\n  if (thenable.status === 'fulfilled') {\n    // @ts-expect-error TODO: fix type\n    return thenable.value;\n  } else {\n    throw thenable;\n  }\n}\n\nfunction createHrefFromUrl(url) {\n  return url.pathname + url.search + url.hash;\n}\n/**\n * Invalidate cache one level down from the router state.\n */\n\n\nfunction invalidateCacheByRouterState(newCache, existingCache, routerState) {\n  // Remove segment that we got data for so that it is filled in during rendering of subTreeData.\n  for (var key in routerState[1]) {\n    var segmentForParallelRoute = routerState[1][key][0];\n    var cacheKey = Array.isArray(segmentForParallelRoute) ? segmentForParallelRoute[1] : segmentForParallelRoute;\n    var existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);\n\n    if (existingParallelRoutesCacheNode) {\n      var parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode);\n      parallelRouteCacheNode[\"delete\"](cacheKey);\n      newCache.parallelRoutes.set(key, parallelRouteCacheNode);\n    }\n  }\n}\n\nfunction fillLazyItemsTillLeafWithHead(newCache, existingCache, routerState, head) {\n  var isLastSegment = Object.keys(routerState[1]).length === 0;\n\n  if (isLastSegment) {\n    newCache.head = head;\n    return;\n  } // Remove segment that we got data for so that it is filled in during rendering of subTreeData.\n\n\n  for (var key in routerState[1]) {\n    var parallelRouteState = routerState[1][key];\n    var segmentForParallelRoute = parallelRouteState[0];\n    var cacheKey = Array.isArray(segmentForParallelRoute) ? segmentForParallelRoute[1] : segmentForParallelRoute;\n\n    if (existingCache) {\n      var existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);\n\n      if (existingParallelRoutesCacheNode) {\n        var parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode);\n        parallelRouteCacheNode[\"delete\"](cacheKey);\n        var _newCacheNode = {\n          status: _appRouterContext.CacheStates.LAZY_INITIALIZED,\n          data: null,\n          subTreeData: null,\n          parallelRoutes: new Map()\n        };\n        parallelRouteCacheNode.set(cacheKey, _newCacheNode);\n        fillLazyItemsTillLeafWithHead(_newCacheNode, undefined, parallelRouteState, head);\n        newCache.parallelRoutes.set(key, parallelRouteCacheNode);\n        continue;\n      }\n    }\n\n    var newCacheNode = {\n      status: _appRouterContext.CacheStates.LAZY_INITIALIZED,\n      data: null,\n      subTreeData: null,\n      parallelRoutes: new Map()\n    };\n    newCache.parallelRoutes.set(key, new Map([[cacheKey, newCacheNode]]));\n    fillLazyItemsTillLeafWithHead(newCacheNode, undefined, parallelRouteState, head);\n  }\n}\n/**\n * Fill cache with subTreeData based on flightDataPath\n */\n\n\nfunction fillCacheWithNewSubTreeData(newCache, existingCache, flightDataPath) {\n  var isLastEntry = flightDataPath.length <= 5;\n\n  var _flightDataPath = _slicedToArray(flightDataPath, 2),\n      parallelRouteKey = _flightDataPath[0],\n      segment = _flightDataPath[1];\n\n  var segmentForCache = Array.isArray(segment) ? segment[1] : segment;\n  var existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n\n  if (!existingChildSegmentMap) {\n    // Bailout because the existing cache does not have the path to the leaf node\n    // Will trigger lazy fetch in layout-router because of missing segment\n    return;\n  }\n\n  var childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);\n\n  if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n    childSegmentMap = new Map(existingChildSegmentMap);\n    newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n  }\n\n  var existingChildCacheNode = existingChildSegmentMap.get(segmentForCache);\n  var childCacheNode = childSegmentMap.get(segmentForCache);\n\n  if (isLastEntry) {\n    if (!childCacheNode || !childCacheNode.data || childCacheNode === existingChildCacheNode) {\n      childCacheNode = {\n        status: _appRouterContext.CacheStates.READY,\n        data: null,\n        subTreeData: flightDataPath[3],\n        // Ensure segments other than the one we got data for are preserved.\n        parallelRoutes: existingChildCacheNode ? new Map(existingChildCacheNode.parallelRoutes) : new Map()\n      };\n\n      if (existingChildCacheNode) {\n        invalidateCacheByRouterState(childCacheNode, existingChildCacheNode, flightDataPath[2]);\n      }\n\n      fillLazyItemsTillLeafWithHead(childCacheNode, existingChildCacheNode, flightDataPath[2], flightDataPath[4]);\n      childSegmentMap.set(segmentForCache, childCacheNode);\n    }\n\n    return;\n  }\n\n  if (!childCacheNode || !existingChildCacheNode) {\n    // Bailout because the existing cache does not have the path to the leaf node\n    // Will trigger lazy fetch in layout-router because of missing segment\n    return;\n  }\n\n  if (childCacheNode === existingChildCacheNode) {\n    childCacheNode = {\n      status: childCacheNode.status,\n      data: childCacheNode.data,\n      subTreeData: childCacheNode.subTreeData,\n      parallelRoutes: new Map(childCacheNode.parallelRoutes)\n    };\n    childSegmentMap.set(segmentForCache, childCacheNode);\n  }\n\n  fillCacheWithNewSubTreeData(childCacheNode, existingChildCacheNode, flightDataPath.slice(2));\n}\n/**\n * Fill cache up to the end of the flightSegmentPath, invalidating anything below it.\n */\n\n\nfunction invalidateCacheBelowFlightSegmentPath(newCache, existingCache, flightSegmentPath) {\n  var isLastEntry = flightSegmentPath.length <= 2;\n\n  var _flightSegmentPath = _slicedToArray(flightSegmentPath, 2),\n      parallelRouteKey = _flightSegmentPath[0],\n      segment = _flightSegmentPath[1];\n\n  var segmentForCache = Array.isArray(segment) ? segment[1] : segment;\n  var existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n\n  if (!existingChildSegmentMap) {\n    // Bailout because the existing cache does not have the path to the leaf node\n    // Will trigger lazy fetch in layout-router because of missing segment\n    return;\n  }\n\n  var childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);\n\n  if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n    childSegmentMap = new Map(existingChildSegmentMap);\n    newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n  } // In case of last entry don't copy further down.\n\n\n  if (isLastEntry) {\n    childSegmentMap[\"delete\"](segmentForCache);\n    return;\n  }\n\n  var existingChildCacheNode = existingChildSegmentMap.get(segmentForCache);\n  var childCacheNode = childSegmentMap.get(segmentForCache);\n\n  if (!childCacheNode || !existingChildCacheNode) {\n    // Bailout because the existing cache does not have the path to the leaf node\n    // Will trigger lazy fetch in layout-router because of missing segment\n    return;\n  }\n\n  if (childCacheNode === existingChildCacheNode) {\n    childCacheNode = {\n      status: childCacheNode.status,\n      data: childCacheNode.data,\n      subTreeData: childCacheNode.subTreeData,\n      parallelRoutes: new Map(childCacheNode.parallelRoutes)\n    };\n    childSegmentMap.set(segmentForCache, childCacheNode);\n  }\n\n  invalidateCacheBelowFlightSegmentPath(childCacheNode, existingChildCacheNode, flightSegmentPath.slice(2));\n}\n/**\n * Fill cache with subTreeData based on flightDataPath that was prefetched\n * This operation is append-only to the existing cache.\n */\n\n\nfunction fillCacheWithPrefetchedSubTreeData(existingCache, flightDataPath) {\n  var isLastEntry = flightDataPath.length <= 5;\n\n  var _flightDataPath2 = _slicedToArray(flightDataPath, 2),\n      parallelRouteKey = _flightDataPath2[0],\n      segment = _flightDataPath2[1];\n\n  var segmentForCache = Array.isArray(segment) ? segment[1] : segment;\n  var existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n\n  if (!existingChildSegmentMap) {\n    // Bailout because the existing cache does not have the path to the leaf node\n    return;\n  }\n\n  var existingChildCacheNode = existingChildSegmentMap.get(segmentForCache);\n\n  if (isLastEntry) {\n    if (!existingChildCacheNode) {\n      var childCacheNode = {\n        status: _appRouterContext.CacheStates.READY,\n        data: null,\n        subTreeData: flightDataPath[3],\n        parallelRoutes: new Map()\n      };\n      fillLazyItemsTillLeafWithHead(childCacheNode, existingChildCacheNode, flightDataPath[2], flightDataPath[4]);\n      existingChildSegmentMap.set(segmentForCache, childCacheNode);\n    }\n\n    return;\n  }\n\n  if (!existingChildCacheNode) {\n    // Bailout because the existing cache does not have the path to the leaf node\n    return;\n  }\n\n  fillCacheWithPrefetchedSubTreeData(existingChildCacheNode, flightDataPath.slice(2));\n}\n/**\n * Kick off fetch based on the common layout between two routes. Fill cache with data property holding the in-progress fetch.\n */\n\n\nfunction fillCacheWithDataProperty(newCache, existingCache, segments, fetchResponse) {\n  var isLastEntry = segments.length === 1;\n  var parallelRouteKey = 'children';\n\n  var _segments = _slicedToArray(segments, 1),\n      segment = _segments[0];\n\n  var existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n\n  if (!existingChildSegmentMap) {\n    // Bailout because the existing cache does not have the path to the leaf node\n    // Will trigger lazy fetch in layout-router because of missing segment\n    return {\n      bailOptimistic: true\n    };\n  }\n\n  var childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);\n\n  if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n    childSegmentMap = new Map(existingChildSegmentMap);\n    newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n  }\n\n  var existingChildCacheNode = existingChildSegmentMap.get(segment);\n  var childCacheNode = childSegmentMap.get(segment); // In case of last segment start off the fetch at this level and don't copy further down.\n\n  if (isLastEntry) {\n    if (!childCacheNode || !childCacheNode.data || childCacheNode === existingChildCacheNode) {\n      childSegmentMap.set(segment, {\n        status: _appRouterContext.CacheStates.DATA_FETCH,\n        data: fetchResponse(),\n        subTreeData: null,\n        parallelRoutes: new Map()\n      });\n    }\n\n    return;\n  }\n\n  if (!childCacheNode || !existingChildCacheNode) {\n    // Start fetch in the place where the existing cache doesn't have the data yet.\n    if (!childCacheNode) {\n      childSegmentMap.set(segment, {\n        status: _appRouterContext.CacheStates.DATA_FETCH,\n        data: fetchResponse(),\n        subTreeData: null,\n        parallelRoutes: new Map()\n      });\n    }\n\n    return;\n  }\n\n  if (childCacheNode === existingChildCacheNode) {\n    childCacheNode = {\n      status: childCacheNode.status,\n      data: childCacheNode.data,\n      subTreeData: childCacheNode.subTreeData,\n      parallelRoutes: new Map(childCacheNode.parallelRoutes)\n    };\n    childSegmentMap.set(segment, childCacheNode);\n  }\n\n  return fillCacheWithDataProperty(childCacheNode, existingChildCacheNode, segments.slice(1), fetchResponse);\n}\n/**\n * Create optimistic version of router state based on the existing router state and segments.\n * This is used to allow rendering layout-routers up till the point where data is missing.\n */\n\n\nfunction createOptimisticTree(segments, flightRouterState, _isFirstSegment, parentRefetch, _href) {\n  var _ref = flightRouterState || [null, {}],\n      _ref2 = _slicedToArray(_ref, 2),\n      existingSegment = _ref2[0],\n      existingParallelRoutes = _ref2[1];\n\n  var segment = segments[0];\n  var isLastSegment = segments.length === 1;\n  var segmentMatches = existingSegment !== null && (0, _matchSegments).matchSegment(existingSegment, segment);\n  var shouldRefetchThisLevel = !flightRouterState || !segmentMatches;\n  var parallelRoutes = {};\n\n  if (existingSegment !== null && segmentMatches) {\n    parallelRoutes = existingParallelRoutes;\n  }\n\n  var childTree;\n\n  if (!isLastSegment) {\n    var childItem = createOptimisticTree(segments.slice(1), parallelRoutes ? parallelRoutes.children : null, false, parentRefetch || shouldRefetchThisLevel);\n    childTree = childItem;\n  }\n\n  var result = [segment, _extends({}, parallelRoutes, childTree ? {\n    children: childTree\n  } : {})];\n\n  if (!parentRefetch && shouldRefetchThisLevel) {\n    result[3] = 'refetch';\n  }\n\n  return result;\n}\n/**\n * Apply the router state from the Flight response. Creates a new router state tree.\n */\n\n\nfunction applyRouterStatePatchToTree(flightSegmentPath, flightRouterState, treePatch) {\n  var _flightRouterState = _slicedToArray(flightRouterState, 5),\n      segment = _flightRouterState[0],\n      parallelRoutes = _flightRouterState[1],\n      isRootLayout = _flightRouterState[4]; // Root refresh\n\n\n  if (flightSegmentPath.length === 1) {\n    var _tree = _toConsumableArray(treePatch);\n\n    return _tree;\n  }\n\n  var _flightSegmentPath2 = _slicedToArray(flightSegmentPath, 2),\n      currentSegment = _flightSegmentPath2[0],\n      parallelRouteKey = _flightSegmentPath2[1]; // Tree path returned from the server should always match up with the current tree in the browser\n\n\n  if (!(0, _matchSegments).matchSegment(currentSegment, segment)) {\n    return null;\n  }\n\n  var lastSegment = flightSegmentPath.length === 2;\n  var parallelRoutePatch;\n\n  if (lastSegment) {\n    parallelRoutePatch = treePatch;\n  } else {\n    parallelRoutePatch = applyRouterStatePatchToTree(flightSegmentPath.slice(2), parallelRoutes[parallelRouteKey], treePatch);\n\n    if (parallelRoutePatch === null) {\n      return null;\n    }\n  }\n\n  var tree = [flightSegmentPath[0], _extends({}, parallelRoutes, _defineProperty({}, parallelRouteKey, parallelRoutePatch))]; // Current segment is the root layout\n\n  if (isRootLayout) {\n    tree[4] = true;\n  }\n\n  return tree;\n}\n\nfunction shouldHardNavigate(flightSegmentPath, flightRouterState, treePatch) {\n  var _flightRouterState2 = _slicedToArray(flightRouterState, 2),\n      segment = _flightRouterState2[0],\n      parallelRoutes = _flightRouterState2[1]; // TODO-APP: Check if `as` can be replaced.\n\n\n  var _flightSegmentPath3 = _slicedToArray(flightSegmentPath, 2),\n      currentSegment = _flightSegmentPath3[0],\n      parallelRouteKey = _flightSegmentPath3[1]; // Check if current segment matches the existing segment.\n\n\n  if (!(0, _matchSegments).matchSegment(currentSegment, segment)) {\n    // If dynamic parameter in tree doesn't match up with segment path a hard navigation is triggered.\n    if (Array.isArray(currentSegment)) {\n      return true;\n    } // If the existing segment did not match soft navigation is triggered.\n\n\n    return false;\n  }\n\n  var lastSegment = flightSegmentPath.length <= 2;\n\n  if (lastSegment) {\n    return false;\n  }\n\n  return shouldHardNavigate(flightSegmentPath.slice(2), parallelRoutes[parallelRouteKey], treePatch);\n}\n\nfunction isNavigatingToNewRootLayout(currentTree, nextTree) {\n  // Compare segments\n  var currentTreeSegment = currentTree[0];\n  var nextTreeSegment = nextTree[0]; // If any segment is different before we find the root layout, the root layout has changed.\n  // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js\n  // First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.\n\n  if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {\n    // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout\n    // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js\n    if (currentTreeSegment[0] !== nextTreeSegment[0] || currentTreeSegment[2] !== nextTreeSegment[2]) {\n      return true;\n    }\n  } else if (currentTreeSegment !== nextTreeSegment) {\n    return true;\n  } // Current tree root layout found\n\n\n  if (currentTree[4]) {\n    // If the next tree doesn't have the root layout flag, it must have changed.\n    return !nextTree[4];\n  } // Current tree  didn't have its root layout here, must have changed.\n\n\n  if (nextTree[4]) {\n    return true;\n  } // We can't assume it's `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`\n  // But it's not possible to be more than one parallelRoutes before the root layout is found\n  // TODO-APP: change to traverse all parallel routes\n\n\n  var currentTreeChild = Object.values(currentTree[1])[0];\n  var nextTreeChild = Object.values(nextTree[1])[0];\n  if (!currentTreeChild || !nextTreeChild) return true;\n  return isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild);\n}\n\nvar ACTION_REFRESH = 'refresh';\nexports.ACTION_REFRESH = ACTION_REFRESH;\nvar ACTION_NAVIGATE = 'navigate';\nexports.ACTION_NAVIGATE = ACTION_NAVIGATE;\nvar ACTION_RESTORE = 'restore';\nexports.ACTION_RESTORE = ACTION_RESTORE;\nvar ACTION_SERVER_PATCH = 'server-patch';\nexports.ACTION_SERVER_PATCH = ACTION_SERVER_PATCH;\nvar ACTION_PREFETCH = 'prefetch';\nexports.ACTION_PREFETCH = ACTION_PREFETCH;\n/**\n * Reducer that handles the app-router state updates.\n */\n\nfunction clientReducer(state, action) {\n  switch (action.type) {\n    case ACTION_NAVIGATE:\n      {\n        var url = action.url,\n            navigateType = action.navigateType,\n            cache = action.cache,\n            mutable = action.mutable,\n            forceOptimisticNavigation = action.forceOptimisticNavigation;\n        var pathname = url.pathname,\n            search = url.search;\n        var href = createHrefFromUrl(url);\n        var pendingPush = navigateType === 'push';\n        var isForCurrentTree = JSON.stringify(mutable.previousTree) === JSON.stringify(state.tree);\n\n        if (mutable.mpaNavigation && isForCurrentTree) {\n          return {\n            // Set href.\n            canonicalUrl: mutable.canonicalUrlOverride ? mutable.canonicalUrlOverride : href,\n            pushRef: {\n              pendingPush: pendingPush,\n              mpaNavigation: mutable.mpaNavigation\n            },\n            // All navigation requires scroll and focus management to trigger.\n            focusAndScrollRef: {\n              apply: false\n            },\n            // Apply cache.\n            cache: state.cache,\n            prefetchCache: state.prefetchCache,\n            // Apply patched router state.\n            tree: state.tree\n          };\n        } // Handle concurrent rendering / strict mode case where the cache and tree were already populated.\n\n\n        if (mutable.patchedTree && isForCurrentTree) {\n          return {\n            // Set href.\n            canonicalUrl: mutable.canonicalUrlOverride ? mutable.canonicalUrlOverride : href,\n            pushRef: {\n              pendingPush: pendingPush,\n              mpaNavigation: false\n            },\n            // All navigation requires scroll and focus management to trigger.\n            focusAndScrollRef: {\n              apply: true\n            },\n            // Apply cache.\n            cache: mutable.useExistingCache ? state.cache : cache,\n            prefetchCache: state.prefetchCache,\n            // Apply patched router state.\n            tree: mutable.patchedTree\n          };\n        }\n\n        var prefetchValues = state.prefetchCache.get(href);\n\n        if (prefetchValues) {\n          // The one before last item is the router state tree patch\n          var _flightSegmentPath4 = prefetchValues.flightSegmentPath,\n              _newTree = prefetchValues.tree,\n              _canonicalUrlOverride = prefetchValues.canonicalUrlOverride;\n\n          if (_newTree !== null) {\n            mutable.previousTree = state.tree;\n            mutable.patchedTree = _newTree;\n            mutable.mpaNavigation = isNavigatingToNewRootLayout(state.tree, _newTree);\n            var hardNavigate = // TODO-APP: Revisit if this is correct.\n            search !== location.search || shouldHardNavigate( // TODO-APP: remove ''\n            [''].concat(_toConsumableArray(_flightSegmentPath4)), state.tree, _newTree);\n\n            if (hardNavigate) {\n              // Copy subTreeData for the root node of the cache.\n              cache.subTreeData = state.cache.subTreeData;\n              invalidateCacheBelowFlightSegmentPath(cache, state.cache, _flightSegmentPath4);\n            } else {\n              mutable.useExistingCache = true;\n            }\n\n            var _canonicalUrlOverrideHref = _canonicalUrlOverride ? createHrefFromUrl(_canonicalUrlOverride) : undefined;\n\n            if (_canonicalUrlOverrideHref) {\n              mutable.canonicalUrlOverride = _canonicalUrlOverrideHref;\n            }\n\n            return {\n              // Set href.\n              canonicalUrl: _canonicalUrlOverrideHref ? _canonicalUrlOverrideHref : href,\n              // Set pendingPush.\n              pushRef: {\n                pendingPush: pendingPush,\n                mpaNavigation: false\n              },\n              // All navigation requires scroll and focus management to trigger.\n              focusAndScrollRef: {\n                apply: true\n              },\n              // Apply patched cache.\n              cache: mutable.useExistingCache ? state.cache : cache,\n              prefetchCache: state.prefetchCache,\n              // Apply patched tree.\n              tree: _newTree\n            };\n          }\n        } // When doing a hard push there can be two cases: with optimistic tree and without\n        // The with optimistic tree case only happens when the layouts have a loading state (loading.js)\n        // The without optimistic tree case happens when there is no loading state, in that case we suspend in this reducer\n        // forceOptimisticNavigation is used for links that have `prefetch={false}`.\n\n\n        if (forceOptimisticNavigation) {\n          var segments = pathname.split('/'); // TODO-APP: figure out something better for index pages\n\n          segments.push(''); // Optimistic tree case.\n          // If the optimistic tree is deeper than the current state leave that deeper part out of the fetch\n\n          var optimisticTree = createOptimisticTree(segments, state.tree, true, false, href); // Copy subTreeData for the root node of the cache.\n\n          cache.subTreeData = state.cache.subTreeData; // Copy existing cache nodes as far as possible and fill in `data` property with the started data fetch.\n          // The `data` property is used to suspend in layout-router during render if it hasn't resolved yet by the time it renders.\n\n          var res = fillCacheWithDataProperty(cache, state.cache, // TODO-APP: segments.slice(1) strips '', we can get rid of '' altogether.\n          segments.slice(1), function () {\n            return (0, _appRouter).fetchServerResponse(url, optimisticTree);\n          }); // If optimistic fetch couldn't happen it falls back to the non-optimistic case.\n\n          if (!(res == null ? void 0 : res.bailOptimistic)) {\n            mutable.previousTree = state.tree;\n            mutable.patchedTree = optimisticTree;\n            mutable.mpaNavigation = isNavigatingToNewRootLayout(state.tree, optimisticTree);\n            return {\n              // Set href.\n              canonicalUrl: href,\n              // Set pendingPush.\n              pushRef: {\n                pendingPush: pendingPush,\n                mpaNavigation: false\n              },\n              // All navigation requires scroll and focus management to trigger.\n              focusAndScrollRef: {\n                apply: true\n              },\n              // Apply patched cache.\n              cache: cache,\n              prefetchCache: state.prefetchCache,\n              // Apply optimistic tree.\n              tree: optimisticTree\n            };\n          }\n        } // Below is the not-optimistic case. Data is fetched at the root and suspended there without a suspense boundary.\n        // If no in-flight fetch at the top, start it.\n\n\n        if (!cache.data) {\n          cache.data = createRecordFromThenable((0, _appRouter).fetchServerResponse(url, state.tree));\n        } // Unwrap cache data with `use` to suspend here (in the reducer) until the fetch resolves.\n\n\n        var _readRecordValue = readRecordValue(cache.data),\n            _readRecordValue2 = _slicedToArray(_readRecordValue, 2),\n            flightData = _readRecordValue2[0],\n            canonicalUrlOverride = _readRecordValue2[1]; // Handle case when navigating to page in `pages` from `app`\n\n\n        if (typeof flightData === 'string') {\n          return {\n            canonicalUrl: flightData,\n            // Enable mpaNavigation\n            pushRef: {\n              pendingPush: true,\n              mpaNavigation: true\n            },\n            // Don't apply scroll and focus management.\n            focusAndScrollRef: {\n              apply: false\n            },\n            cache: state.cache,\n            prefetchCache: state.prefetchCache,\n            tree: state.tree\n          };\n        } // Remove cache.data as it has been resolved at this point.\n\n\n        cache.data = null; // TODO-APP: Currently the Flight data can only have one item but in the future it can have multiple paths.\n\n        var flightDataPath = flightData[0]; // The one before last item is the router state tree patch\n\n        var _flightDataPath$slice = flightDataPath.slice(-3),\n            _flightDataPath$slice2 = _slicedToArray(_flightDataPath$slice, 3),\n            treePatch = _flightDataPath$slice2[0],\n            subTreeData = _flightDataPath$slice2[1],\n            head = _flightDataPath$slice2[2]; // Path without the last segment, router state, and the subTreeData\n\n\n        var flightSegmentPath = flightDataPath.slice(0, -4); // Create new tree based on the flightSegmentPath and router state patch\n\n        var newTree = applyRouterStatePatchToTree( // TODO-APP: remove ''\n        [''].concat(_toConsumableArray(flightSegmentPath)), state.tree, treePatch);\n\n        if (newTree === null) {\n          throw new Error('SEGMENT MISMATCH');\n        }\n\n        var canonicalUrlOverrideHref = canonicalUrlOverride ? createHrefFromUrl(canonicalUrlOverride) : undefined;\n\n        if (canonicalUrlOverrideHref) {\n          mutable.canonicalUrlOverride = canonicalUrlOverrideHref;\n        }\n\n        mutable.previousTree = state.tree;\n        mutable.patchedTree = newTree;\n        mutable.mpaNavigation = isNavigatingToNewRootLayout(state.tree, newTree);\n\n        if (flightDataPath.length === 3) {\n          cache.subTreeData = subTreeData;\n          fillLazyItemsTillLeafWithHead(cache, state.cache, treePatch, head);\n        } else {\n          // Copy subTreeData for the root node of the cache.\n          cache.subTreeData = state.cache.subTreeData; // Create a copy of the existing cache with the subTreeData applied.\n\n          fillCacheWithNewSubTreeData(cache, state.cache, flightDataPath);\n        }\n\n        return {\n          // Set href.\n          canonicalUrl: canonicalUrlOverrideHref ? canonicalUrlOverrideHref : href,\n          // Set pendingPush.\n          pushRef: {\n            pendingPush: pendingPush,\n            mpaNavigation: false\n          },\n          // All navigation requires scroll and focus management to trigger.\n          focusAndScrollRef: {\n            apply: true\n          },\n          // Apply patched cache.\n          cache: cache,\n          prefetchCache: state.prefetchCache,\n          // Apply patched tree.\n          tree: newTree\n        };\n      }\n\n    case ACTION_SERVER_PATCH:\n      {\n        var _flightData = action.flightData,\n            previousTree = action.previousTree,\n            overrideCanonicalUrl = action.overrideCanonicalUrl,\n            _cache = action.cache,\n            _mutable = action.mutable; // When a fetch is slow to resolve it could be that you navigated away while the request was happening or before the reducer runs.\n        // In that case opt-out of applying the patch given that the data could be stale.\n\n        if (JSON.stringify(previousTree) !== JSON.stringify(state.tree)) {\n          // TODO-APP: Handle tree mismatch\n          console.log('TREE MISMATCH'); // Keep everything as-is.\n\n          return state;\n        }\n\n        if (_mutable.mpaNavigation) {\n          return {\n            // Set href.\n            canonicalUrl: _mutable.canonicalUrlOverride ? _mutable.canonicalUrlOverride : state.canonicalUrl,\n            // TODO-APP: verify mpaNavigation not being set is correct here.\n            pushRef: {\n              pendingPush: true,\n              mpaNavigation: _mutable.mpaNavigation\n            },\n            // All navigation requires scroll and focus management to trigger.\n            focusAndScrollRef: {\n              apply: false\n            },\n            // Apply cache.\n            cache: state.cache,\n            prefetchCache: state.prefetchCache,\n            // Apply patched router state.\n            tree: state.tree\n          };\n        } // Handle concurrent rendering / strict mode case where the cache and tree were already populated.\n\n\n        if (_mutable.patchedTree) {\n          return {\n            // Keep href as it was set during navigate / restore\n            canonicalUrl: _mutable.canonicalUrlOverride ? _mutable.canonicalUrlOverride : state.canonicalUrl,\n            // Keep pushRef as server-patch only causes cache/tree update.\n            pushRef: state.pushRef,\n            // Keep focusAndScrollRef as server-patch only causes cache/tree update.\n            focusAndScrollRef: state.focusAndScrollRef,\n            // Apply patched router state\n            tree: _mutable.patchedTree,\n            prefetchCache: state.prefetchCache,\n            // Apply patched cache\n            cache: _cache\n          };\n        } // Handle case when navigating to page in `pages` from `app`\n\n\n        if (typeof _flightData === 'string') {\n          return {\n            // Set href.\n            canonicalUrl: _flightData,\n            // Enable mpaNavigation as this is a navigation that the app-router shouldn't handle.\n            pushRef: {\n              pendingPush: true,\n              mpaNavigation: true\n            },\n            // Don't apply scroll and focus management.\n            focusAndScrollRef: {\n              apply: false\n            },\n            // Other state is kept as-is.\n            cache: state.cache,\n            prefetchCache: state.prefetchCache,\n            tree: state.tree\n          };\n        } // TODO-APP: Currently the Flight data can only have one item but in the future it can have multiple paths.\n\n\n        var _flightDataPath3 = _flightData[0]; // Slices off the last segment (which is at -4) as it doesn't exist in the tree yet\n\n        var _flightSegmentPath5 = _flightDataPath3.slice(0, -4);\n\n        var _flightDataPath3$slic = _flightDataPath3.slice(-3),\n            _flightDataPath3$slic2 = _slicedToArray(_flightDataPath3$slic, 3),\n            _treePatch = _flightDataPath3$slic2[0],\n            _subTreeData = _flightDataPath3$slic2[1],\n            _head = _flightDataPath3$slic2[2];\n\n        var _newTree2 = applyRouterStatePatchToTree( // TODO-APP: remove ''\n        [''].concat(_toConsumableArray(_flightSegmentPath5)), state.tree, _treePatch);\n\n        if (_newTree2 === null) {\n          throw new Error('SEGMENT MISMATCH');\n        }\n\n        var _canonicalUrlOverrideHref2 = overrideCanonicalUrl ? createHrefFromUrl(overrideCanonicalUrl) : undefined;\n\n        if (_canonicalUrlOverrideHref2) {\n          _mutable.canonicalUrlOverride = _canonicalUrlOverrideHref2;\n        }\n\n        _mutable.patchedTree = _newTree2;\n        _mutable.mpaNavigation = isNavigatingToNewRootLayout(state.tree, _newTree2); // Root refresh\n\n        if (_flightDataPath3.length === 3) {\n          _cache.subTreeData = _subTreeData;\n          fillLazyItemsTillLeafWithHead(_cache, state.cache, _treePatch, _head);\n        } else {\n          // Copy subTreeData for the root node of the cache.\n          _cache.subTreeData = state.cache.subTreeData;\n          fillCacheWithNewSubTreeData(_cache, state.cache, _flightDataPath3);\n        }\n\n        return {\n          // Keep href as it was set during navigate / restore\n          canonicalUrl: _canonicalUrlOverrideHref2 ? _canonicalUrlOverrideHref2 : state.canonicalUrl,\n          // Keep pushRef as server-patch only causes cache/tree update.\n          pushRef: state.pushRef,\n          // Keep focusAndScrollRef as server-patch only causes cache/tree update.\n          focusAndScrollRef: state.focusAndScrollRef,\n          // Apply patched router state\n          tree: _newTree2,\n          prefetchCache: state.prefetchCache,\n          // Apply patched cache\n          cache: _cache\n        };\n      }\n\n    case ACTION_RESTORE:\n      {\n        var _url = action.url,\n            tree = action.tree;\n\n        var _href2 = createHrefFromUrl(_url);\n\n        return {\n          // Set canonical url\n          canonicalUrl: _href2,\n          pushRef: state.pushRef,\n          focusAndScrollRef: state.focusAndScrollRef,\n          cache: state.cache,\n          prefetchCache: state.prefetchCache,\n          // Restore provided tree\n          tree: tree\n        };\n      }\n    // TODO-APP: Add test for not scrolling to nearest layout when calling refresh.\n    // TODO-APP: Add test for startTransition(() => {router.push('/'); router.refresh();}), that case should scroll.\n\n    case ACTION_REFRESH:\n      {\n        var _cache2 = action.cache,\n            _mutable2 = action.mutable;\n        var _href3 = state.canonicalUrl;\n\n        var _isForCurrentTree = JSON.stringify(_mutable2.previousTree) === JSON.stringify(state.tree);\n\n        if (_mutable2.mpaNavigation && _isForCurrentTree) {\n          return {\n            // Set href.\n            canonicalUrl: _mutable2.canonicalUrlOverride ? _mutable2.canonicalUrlOverride : state.canonicalUrl,\n            // TODO-APP: verify mpaNavigation not being set is correct here.\n            pushRef: {\n              pendingPush: true,\n              mpaNavigation: _mutable2.mpaNavigation\n            },\n            // All navigation requires scroll and focus management to trigger.\n            focusAndScrollRef: {\n              apply: false\n            },\n            // Apply cache.\n            cache: state.cache,\n            prefetchCache: state.prefetchCache,\n            // Apply patched router state.\n            tree: state.tree\n          };\n        } // Handle concurrent rendering / strict mode case where the cache and tree were already populated.\n\n\n        if (_mutable2.patchedTree && _isForCurrentTree) {\n          return {\n            // Set href.\n            canonicalUrl: _mutable2.canonicalUrlOverride ? _mutable2.canonicalUrlOverride : _href3,\n            // set pendingPush (always false in this case).\n            pushRef: state.pushRef,\n            // Apply focus and scroll.\n            // TODO-APP: might need to disable this for Fast Refresh.\n            focusAndScrollRef: {\n              apply: false\n            },\n            cache: _cache2,\n            prefetchCache: state.prefetchCache,\n            tree: _mutable2.patchedTree\n          };\n        }\n\n        if (!_cache2.data) {\n          // Fetch data from the root of the tree.\n          _cache2.data = createRecordFromThenable((0, _appRouter).fetchServerResponse(new URL(_href3, location.origin), [state.tree[0], state.tree[1], state.tree[2], 'refetch']));\n        }\n\n        var _readRecordValue3 = readRecordValue(_cache2.data),\n            _readRecordValue4 = _slicedToArray(_readRecordValue3, 2),\n            _flightData2 = _readRecordValue4[0],\n            _canonicalUrlOverride2 = _readRecordValue4[1]; // Handle case when navigating to page in `pages` from `app`\n\n\n        if (typeof _flightData2 === 'string') {\n          return {\n            canonicalUrl: _flightData2,\n            pushRef: {\n              pendingPush: true,\n              mpaNavigation: true\n            },\n            focusAndScrollRef: {\n              apply: false\n            },\n            cache: state.cache,\n            prefetchCache: state.prefetchCache,\n            tree: state.tree\n          };\n        } // Remove cache.data as it has been resolved at this point.\n\n\n        _cache2.data = null; // TODO-APP: Currently the Flight data can only have one item but in the future it can have multiple paths.\n\n        var _flightDataPath4 = _flightData2[0]; // FlightDataPath with more than two items means unexpected Flight data was returned\n\n        if (_flightDataPath4.length !== 3) {\n          // TODO-APP: handle this case better\n          console.log('REFRESH FAILED');\n          return state;\n        } // Given the path can only have two items the items are only the router state and subTreeData for the root.\n\n\n        var _flightDataPath5 = _slicedToArray(_flightDataPath4, 3),\n            _treePatch2 = _flightDataPath5[0],\n            _subTreeData2 = _flightDataPath5[1],\n            _head2 = _flightDataPath5[2];\n\n        var _newTree3 = applyRouterStatePatchToTree( // TODO-APP: remove ''\n        [''], state.tree, _treePatch2);\n\n        if (_newTree3 === null) {\n          throw new Error('SEGMENT MISMATCH');\n        }\n\n        var _canonicalUrlOverrideHref3 = _canonicalUrlOverride2 ? createHrefFromUrl(_canonicalUrlOverride2) : undefined;\n\n        if (_canonicalUrlOverride2) {\n          _mutable2.canonicalUrlOverride = _canonicalUrlOverrideHref3;\n        }\n\n        _mutable2.previousTree = state.tree;\n        _mutable2.patchedTree = _newTree3;\n        _mutable2.mpaNavigation = isNavigatingToNewRootLayout(state.tree, _newTree3); // Set subTreeData for the root node of the cache.\n\n        _cache2.subTreeData = _subTreeData2;\n        fillLazyItemsTillLeafWithHead(_cache2, state.cache, _treePatch2, _head2);\n        return {\n          // Set href, this doesn't reuse the state.canonicalUrl as because of concurrent rendering the href might change between dispatching and applying.\n          canonicalUrl: _canonicalUrlOverrideHref3 ? _canonicalUrlOverrideHref3 : _href3,\n          // set pendingPush (always false in this case).\n          pushRef: state.pushRef,\n          // TODO-APP: might need to disable this for Fast Refresh.\n          focusAndScrollRef: {\n            apply: false\n          },\n          // Apply patched cache.\n          cache: _cache2,\n          prefetchCache: state.prefetchCache,\n          // Apply patched router state.\n          tree: _newTree3\n        };\n      }\n\n    case ACTION_PREFETCH:\n      {\n        var _url2 = action.url,\n            serverResponse = action.serverResponse;\n\n        var _serverResponse = _slicedToArray(serverResponse, 2),\n            _flightData3 = _serverResponse[0],\n            _canonicalUrlOverride3 = _serverResponse[1];\n\n        if (typeof _flightData3 === 'string') {\n          return state;\n        }\n\n        var _href4 = createHrefFromUrl(_url2); // TODO-APP: Currently the Flight data can only have one item but in the future it can have multiple paths.\n\n\n        var _flightDataPath6 = _flightData3[0]; // The one before last item is the router state tree patch\n\n        var _flightDataPath6$slic = _flightDataPath6.slice(-3),\n            _flightDataPath6$slic2 = _slicedToArray(_flightDataPath6$slic, 2),\n            _treePatch3 = _flightDataPath6$slic2[0],\n            _subTreeData3 = _flightDataPath6$slic2[1]; // TODO-APP: Verify if `null` can't be returned from user code.\n        // If subTreeData is null the prefetch did not provide a component tree.\n\n\n        if (_subTreeData3 !== null) {\n          fillCacheWithPrefetchedSubTreeData(state.cache, _flightDataPath6);\n        }\n\n        var _flightSegmentPath6 = _flightDataPath6.slice(0, -3);\n\n        var _newTree4 = applyRouterStatePatchToTree( // TODO-APP: remove ''\n        [''].concat(_toConsumableArray(_flightSegmentPath6)), state.tree, _treePatch3); // Patch did not apply correctly\n\n\n        if (_newTree4 === null) {\n          return state;\n        } // Create new tree based on the flightSegmentPath and router state patch\n\n\n        state.prefetchCache.set(_href4, {\n          // Path without the last segment, router state, and the subTreeData\n          flightSegmentPath: _flightSegmentPath6,\n          // Create new tree based on the flightSegmentPath and router state patch\n          tree: _newTree4,\n          canonicalUrlOverride: _canonicalUrlOverride3\n        });\n        return state;\n      }\n    // This case should never be hit as dispatch is strongly typed.\n\n    default:\n      throw new Error('Unknown action');\n  }\n}\n\nfunction serverReducer(state, _action) {\n  return state;\n}\n\nvar reducer =  false ? 0 : clientReducer;\nexports.reducer = reducer;\n\nif ((typeof exports[\"default\"] === 'function' || typeof exports[\"default\"] === 'object' && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === 'undefined') {\n  Object.defineProperty(exports[\"default\"], '__esModule', {\n    value: true\n  });\n  Object.assign(exports[\"default\"], exports);\n  module.exports = exports[\"default\"];\n}\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWR1Y2VyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOzs7Ozs7OztBQUNiQSw4Q0FBNkM7RUFDekNHLEtBQUssRUFBRTtBQURrQyxDQUE3QztBQUdBRCx5QkFBQSxHQUE0QkUsaUJBQTVCO0FBQ0FGLGVBQUEsR0FBa0JBLHVCQUFBLEdBQTBCQSwyQkFBQSxHQUE4QkEsc0JBQUEsR0FBeUJBLHVCQUFBLEdBQTBCQSxzQkFBQSxHQUF5QixLQUFLLENBQTNKOztBQUNBLElBQUlTLFFBQVEsR0FBR0MsZ0lBQWY7O0FBQ0EsSUFBSUMsaUJBQWlCLEdBQUdELG1CQUFPLENBQUMsbUhBQUQsQ0FBL0I7O0FBQ0EsSUFBSUUsY0FBYyxHQUFHRixtQkFBTyxDQUFDLG1HQUFELENBQTVCOztBQUNBLElBQUlHLFVBQVUsR0FBR0gsbUJBQU8sQ0FBQywyRkFBRCxDQUF4QjtBQUNBO0FBQ0E7QUFDQTtBQUFJOzs7QUFDSixTQUFTSSx3QkFBVCxDQUFrQ0MsUUFBbEMsRUFBNEM7RUFDeENBLFFBQVEsQ0FBQ0MsTUFBVCxHQUFrQixTQUFsQjtFQUNBRCxRQUFRLENBQUNFLElBQVQsQ0FBYyxVQUFDaEIsS0FBRCxFQUFTO0lBQ25CLElBQUljLFFBQVEsQ0FBQ0MsTUFBVCxLQUFvQixTQUF4QixFQUFtQztNQUMvQkQsUUFBUSxDQUFDQyxNQUFULEdBQWtCLFdBQWxCO01BQ0FELFFBQVEsQ0FBQ2QsS0FBVCxHQUFpQkEsS0FBakI7SUFDSDtFQUNKLENBTEQsRUFLRyxVQUFDaUIsR0FBRCxFQUFPO0lBQ04sSUFBSUgsUUFBUSxDQUFDQyxNQUFULEtBQW9CLFNBQXhCLEVBQW1DO01BQy9CRCxRQUFRLENBQUNDLE1BQVQsR0FBa0IsVUFBbEI7TUFDQUQsUUFBUSxDQUFDZCxLQUFULEdBQWlCaUIsR0FBakI7SUFDSDtFQUNKLENBVkQ7RUFXQSxPQUFPSCxRQUFQO0FBQ0g7QUFDRDtBQUNBO0FB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QyxPQUFPekMsS0FBUDtBQUNIOztBQUNELElBQU1uRyxPQUFPLEdBQUcsU0FBZ0MySSxDQUFoQyxHQUFnRHpDLGFBQWhFO0FBQ0FyRyxlQUFBLEdBQWtCRyxPQUFsQjs7QUFFQSxJQUFJLENBQUMsT0FBT0gsT0FBTyxXQUFkLEtBQTJCLFVBQTNCLElBQTBDLE9BQU9BLE9BQU8sV0FBZCxLQUEyQixRQUEzQixJQUF1Q0EsT0FBTyxXQUFQLEtBQW9CLElBQXRHLEtBQWdILE9BQU9BLE9BQU8sV0FBUCxDQUFnQmdKLFVBQXZCLEtBQXNDLFdBQTFKLEVBQXVLO0VBQ3JLbEosTUFBTSxDQUFDQyxjQUFQLENBQXNCQyxPQUFPLFdBQTdCLEVBQXVDLFlBQXZDLEVBQXFEO0lBQUVDLEtBQUssRUFBRTtFQUFULENBQXJEO0VBQ0FILE1BQU0sQ0FBQ21KLE1BQVAsQ0FBY2pKLE9BQU8sV0FBckIsRUFBK0JBLE9BQS9CO0VBQ0FrSixNQUFNLENBQUNsSixPQUFQLEdBQWlCQSxPQUFPLFdBQXhCO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWR1Y2VyLmpzPzczYjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNyZWF0ZUhyZWZGcm9tVXJsID0gY3JlYXRlSHJlZkZyb21Vcmw7XG5leHBvcnRzLnJlZHVjZXIgPSBleHBvcnRzLkFDVElPTl9QUkVGRVRDSCA9IGV4cG9ydHMuQUNUSU9OX1NFUlZFUl9QQVRDSCA9IGV4cG9ydHMuQUNUSU9OX1JFU1RPUkUgPSBleHBvcnRzLkFDVElPTl9OQVZJR0FURSA9IGV4cG9ydHMuQUNUSU9OX1JFRlJFU0ggPSB2b2lkIDA7XG52YXIgX2V4dGVuZHMgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9fZXh0ZW5kcy5qc1wiKS5kZWZhdWx0O1xudmFyIF9hcHBSb3V0ZXJDb250ZXh0ID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0XCIpO1xudmFyIF9tYXRjaFNlZ21lbnRzID0gcmVxdWlyZShcIi4vbWF0Y2gtc2VnbWVudHNcIik7XG52YXIgX2FwcFJvdXRlciA9IHJlcXVpcmUoXCIuL2FwcC1yb3V0ZXJcIik7XG4vKipcbiAqIENyZWF0ZSBkYXRhIGZldGNoaW5nIHJlY29yZCBmb3IgUHJvbWlzZS5cbiAqLyAvLyBUT0RPLUFQUDogY2hhbmdlIGBhbnlgIHRvIHR5cGUgaW5mZXJlbmNlLlxuZnVuY3Rpb24gY3JlYXRlUmVjb3JkRnJvbVRoZW5hYmxlKHRoZW5hYmxlKSB7XG4gICAgdGhlbmFibGUuc3RhdHVzID0gJ3BlbmRpbmcnO1xuICAgIHRoZW5hYmxlLnRoZW4oKHZhbHVlKT0+e1xuICAgICAgICBpZiAodGhlbmFibGUuc3RhdHVzID09PSAncGVuZGluZycpIHtcbiAgICAgICAgICAgIHRoZW5hYmxlLnN0YXR1cyA9ICdmdWxmaWxsZWQnO1xuICAgICAgICAgICAgdGhlbmFibGUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sIChlcnIpPT57XG4gICAgICAgIGlmICh0aGVuYWJsZS5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xuICAgICAgICAgICAgdGhlbmFibGUuc3RhdHVzID0gJ3JlamVjdGVkJztcbiAgICAgICAgICAgIHRoZW5hYmxlLnZhbHVlID0gZXJyO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoZW5hYmxlO1xufVxuLyoqXG4gKiBSZWFkIHJlY29yZCB2YWx1ZSBvciB0aHJvdyBQcm9taXNlIGlmIGl0J3Mgbm90IHJlc29sdmVkIHlldC5cbiAqLyBmdW5jdGlvbiByZWFkUmVjb3JkVmFsdWUodGhlbmFibGUpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE86IGZpeCB0eXBlXG4gICAgaWYgKHRoZW5hYmxlLnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcpIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPOiBmaXggdHlwZVxuICAgICAgICByZXR1cm4gdGhlbmFibGUudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgdGhlbmFibGU7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlSHJlZkZyb21VcmwodXJsKSB7XG4gICAgcmV0dXJuIHVybC5wYXRobmFtZSArIHVybC5zZWFyY2ggKyB1cmwuaGFzaDtcbn1cbi8qKlxuICogSW52YWxpZGF0ZSBjYWNoZSBvbmUgbGV2ZWwgZG93biBmcm9tIHRoZSByb3V0ZXIgc3RhdGUuXG4gKi8gZnVuY3Rpb24gaW52YWxpZGF0ZUNhY2hlQnlSb3V0ZXJTdGF0ZShuZXdDYWNoZSwgZXhpc3RpbmdDYWNoZSwgcm91dGVyU3RhdGUpIHtcbiAgICAvLyBSZW1vdmUgc2VnbWVudCB0aGF0IHdlIGdvdCBkYXRhIGZvciBzbyB0aGF0IGl0IGlzIGZpbGxlZCBpbiBkdXJpbmcgcmVuZGVyaW5nIG9mIHN1YlRyZWVEYXRhLlxuICAgIGZvcihjb25zdCBrZXkgaW4gcm91dGVyU3RhdGVbMV0pe1xuICAgICAgICBjb25zdCBzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZSA9IHJvdXRlclN0YXRlWzFdW2tleV1bMF07XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gQXJyYXkuaXNBcnJheShzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZSkgPyBzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZVsxXSA6IHNlZ21lbnRGb3JQYXJhbGxlbFJvdXRlO1xuICAgICAgICBjb25zdCBleGlzdGluZ1BhcmFsbGVsUm91dGVzQ2FjaGVOb2RlID0gZXhpc3RpbmdDYWNoZS5wYXJhbGxlbFJvdXRlcy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGV4aXN0aW5nUGFyYWxsZWxSb3V0ZXNDYWNoZU5vZGUpIHtcbiAgICAgICAgICAgIGxldCBwYXJhbGxlbFJvdXRlQ2FjaGVOb2RlID0gbmV3IE1hcChleGlzdGluZ1BhcmFsbGVsUm91dGVzQ2FjaGVOb2RlKTtcbiAgICAgICAgICAgIHBhcmFsbGVsUm91dGVDYWNoZU5vZGUuZGVsZXRlKGNhY2hlS2V5KTtcbiAgICAgICAgICAgIG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLnNldChrZXksIHBhcmFsbGVsUm91dGVDYWNoZU5vZGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQobmV3Q2FjaGUsIGV4aXN0aW5nQ2FjaGUsIHJvdXRlclN0YXRlLCBoZWFkKSB7XG4gICAgY29uc3QgaXNMYXN0U2VnbWVudCA9IE9iamVjdC5rZXlzKHJvdXRlclN0YXRlWzFdKS5sZW5ndGggPT09IDA7XG4gICAgaWYgKGlzTGFzdFNlZ21lbnQpIHtcbiAgICAgICAgbmV3Q2FjaGUuaGVhZCA9IGhlYWQ7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIHNlZ21lbnQgdGhhdCB3ZSBnb3QgZGF0YSBmb3Igc28gdGhhdCBpdCBpcyBmaWxsZWQgaW4gZHVyaW5nIHJlbmRlcmluZyBvZiBzdWJUcmVlRGF0YS5cbiAgICBmb3IoY29uc3Qga2V5IGluIHJvdXRlclN0YXRlWzFdKXtcbiAgICAgICAgY29uc3QgcGFyYWxsZWxSb3V0ZVN0YXRlID0gcm91dGVyU3RhdGVbMV1ba2V5XTtcbiAgICAgICAgY29uc3Qgc2VnbWVudEZvclBhcmFsbGVsUm91dGUgPSBwYXJhbGxlbFJvdXRlU3RhdGVbMF07XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gQXJyYXkuaXNBcnJheShzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZSkgPyBzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZVsxXSA6IHNlZ21lbnRGb3JQYXJhbGxlbFJvdXRlO1xuICAgICAgICBpZiAoZXhpc3RpbmdDYWNoZSkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdQYXJhbGxlbFJvdXRlc0NhY2hlTm9kZSA9IGV4aXN0aW5nQ2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdQYXJhbGxlbFJvdXRlc0NhY2hlTm9kZSkge1xuICAgICAgICAgICAgICAgIGxldCBwYXJhbGxlbFJvdXRlQ2FjaGVOb2RlID0gbmV3IE1hcChleGlzdGluZ1BhcmFsbGVsUm91dGVzQ2FjaGVOb2RlKTtcbiAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlQ2FjaGVOb2RlLmRlbGV0ZShjYWNoZUtleSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Q2FjaGVOb2RlID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLkxBWllfSU5JVElBTElaRUQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHN1YlRyZWVEYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlQ2FjaGVOb2RlLnNldChjYWNoZUtleSwgbmV3Q2FjaGVOb2RlKTtcbiAgICAgICAgICAgICAgICBmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZChuZXdDYWNoZU5vZGUsIHVuZGVmaW5lZCwgcGFyYWxsZWxSb3V0ZVN0YXRlLCBoZWFkKTtcbiAgICAgICAgICAgICAgICBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5zZXQoa2V5LCBwYXJhbGxlbFJvdXRlQ2FjaGVOb2RlKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdDYWNoZU5vZGUgPSB7XG4gICAgICAgICAgICBzdGF0dXM6IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLkxBWllfSU5JVElBTElaRUQsXG4gICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgc3ViVHJlZURhdGE6IG51bGwsXG4gICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpXG4gICAgICAgIH07XG4gICAgICAgIG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLnNldChrZXksIG5ldyBNYXAoW1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIGNhY2hlS2V5LFxuICAgICAgICAgICAgICAgIG5ld0NhY2hlTm9kZVxuICAgICAgICAgICAgXVxuICAgICAgICBdKSk7XG4gICAgICAgIGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKG5ld0NhY2hlTm9kZSwgdW5kZWZpbmVkLCBwYXJhbGxlbFJvdXRlU3RhdGUsIGhlYWQpO1xuICAgIH1cbn1cbi8qKlxuICogRmlsbCBjYWNoZSB3aXRoIHN1YlRyZWVEYXRhIGJhc2VkIG9uIGZsaWdodERhdGFQYXRoXG4gKi8gZnVuY3Rpb24gZmlsbENhY2hlV2l0aE5ld1N1YlRyZWVEYXRhKG5ld0NhY2hlLCBleGlzdGluZ0NhY2hlLCBmbGlnaHREYXRhUGF0aCkge1xuICAgIGNvbnN0IGlzTGFzdEVudHJ5ID0gZmxpZ2h0RGF0YVBhdGgubGVuZ3RoIDw9IDU7XG4gICAgY29uc3QgW3BhcmFsbGVsUm91dGVLZXksIHNlZ21lbnRdID0gZmxpZ2h0RGF0YVBhdGg7XG4gICAgY29uc3Qgc2VnbWVudEZvckNhY2hlID0gQXJyYXkuaXNBcnJheShzZWdtZW50KSA/IHNlZ21lbnRbMV0gOiBzZWdtZW50O1xuICAgIGNvbnN0IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwID0gZXhpc3RpbmdDYWNoZS5wYXJhbGxlbFJvdXRlcy5nZXQocGFyYWxsZWxSb3V0ZUtleSk7XG4gICAgaWYgKCFleGlzdGluZ0NoaWxkU2VnbWVudE1hcCkge1xuICAgICAgICAvLyBCYWlsb3V0IGJlY2F1c2UgdGhlIGV4aXN0aW5nIGNhY2hlIGRvZXMgbm90IGhhdmUgdGhlIHBhdGggdG8gdGhlIGxlYWYgbm9kZVxuICAgICAgICAvLyBXaWxsIHRyaWdnZXIgbGF6eSBmZXRjaCBpbiBsYXlvdXQtcm91dGVyIGJlY2F1c2Ugb2YgbWlzc2luZyBzZWdtZW50XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGNoaWxkU2VnbWVudE1hcCA9IG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlS2V5KTtcbiAgICBpZiAoIWNoaWxkU2VnbWVudE1hcCB8fCBjaGlsZFNlZ21lbnRNYXAgPT09IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKSB7XG4gICAgICAgIGNoaWxkU2VnbWVudE1hcCA9IG5ldyBNYXAoZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXApO1xuICAgICAgICBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5zZXQocGFyYWxsZWxSb3V0ZUtleSwgY2hpbGRTZWdtZW50TWFwKTtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdDaGlsZENhY2hlTm9kZSA9IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwLmdldChzZWdtZW50Rm9yQ2FjaGUpO1xuICAgIGxldCBjaGlsZENhY2hlTm9kZSA9IGNoaWxkU2VnbWVudE1hcC5nZXQoc2VnbWVudEZvckNhY2hlKTtcbiAgICBpZiAoaXNMYXN0RW50cnkpIHtcbiAgICAgICAgaWYgKCFjaGlsZENhY2hlTm9kZSB8fCAhY2hpbGRDYWNoZU5vZGUuZGF0YSB8fCBjaGlsZENhY2hlTm9kZSA9PT0gZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgICAgICAgICAgY2hpbGRDYWNoZU5vZGUgPSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5SRUFEWSxcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIHN1YlRyZWVEYXRhOiBmbGlnaHREYXRhUGF0aFszXSxcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgc2VnbWVudHMgb3RoZXIgdGhhbiB0aGUgb25lIHdlIGdvdCBkYXRhIGZvciBhcmUgcHJlc2VydmVkLlxuICAgICAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlID8gbmV3IE1hcChleGlzdGluZ0NoaWxkQ2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzKSA6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ0NoaWxkQ2FjaGVOb2RlKSB7XG4gICAgICAgICAgICAgICAgaW52YWxpZGF0ZUNhY2hlQnlSb3V0ZXJTdGF0ZShjaGlsZENhY2hlTm9kZSwgZXhpc3RpbmdDaGlsZENhY2hlTm9kZSwgZmxpZ2h0RGF0YVBhdGhbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQoY2hpbGRDYWNoZU5vZGUsIGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUsIGZsaWdodERhdGFQYXRoWzJdLCBmbGlnaHREYXRhUGF0aFs0XSk7XG4gICAgICAgICAgICBjaGlsZFNlZ21lbnRNYXAuc2V0KHNlZ21lbnRGb3JDYWNoZSwgY2hpbGRDYWNoZU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjaGlsZENhY2hlTm9kZSB8fCAhZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgICAgICAvLyBCYWlsb3V0IGJlY2F1c2UgdGhlIGV4aXN0aW5nIGNhY2hlIGRvZXMgbm90IGhhdmUgdGhlIHBhdGggdG8gdGhlIGxlYWYgbm9kZVxuICAgICAgICAvLyBXaWxsIHRyaWdnZXIgbGF6eSBmZXRjaCBpbiBsYXlvdXQtcm91dGVyIGJlY2F1c2Ugb2YgbWlzc2luZyBzZWdtZW50XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNoaWxkQ2FjaGVOb2RlID09PSBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlKSB7XG4gICAgICAgIGNoaWxkQ2FjaGVOb2RlID0ge1xuICAgICAgICAgICAgc3RhdHVzOiBjaGlsZENhY2hlTm9kZS5zdGF0dXMsXG4gICAgICAgICAgICBkYXRhOiBjaGlsZENhY2hlTm9kZS5kYXRhLFxuICAgICAgICAgICAgc3ViVHJlZURhdGE6IGNoaWxkQ2FjaGVOb2RlLnN1YlRyZWVEYXRhLFxuICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoY2hpbGRDYWNoZU5vZGUucGFyYWxsZWxSb3V0ZXMpXG4gICAgICAgIH07XG4gICAgICAgIGNoaWxkU2VnbWVudE1hcC5zZXQoc2VnbWVudEZvckNhY2hlLCBjaGlsZENhY2hlTm9kZSk7XG4gICAgfVxuICAgIGZpbGxDYWNoZVdpdGhOZXdTdWJUcmVlRGF0YShjaGlsZENhY2hlTm9kZSwgZXhpc3RpbmdDaGlsZENhY2hlTm9kZSwgZmxpZ2h0RGF0YVBhdGguc2xpY2UoMikpO1xufVxuLyoqXG4gKiBGaWxsIGNhY2hlIHVwIHRvIHRoZSBlbmQgb2YgdGhlIGZsaWdodFNlZ21lbnRQYXRoLCBpbnZhbGlkYXRpbmcgYW55dGhpbmcgYmVsb3cgaXQuXG4gKi8gZnVuY3Rpb24gaW52YWxpZGF0ZUNhY2hlQmVsb3dGbGlnaHRTZWdtZW50UGF0aChuZXdDYWNoZSwgZXhpc3RpbmdDYWNoZSwgZmxpZ2h0U2VnbWVudFBhdGgpIHtcbiAgICBjb25zdCBpc0xhc3RFbnRyeSA9IGZsaWdodFNlZ21lbnRQYXRoLmxlbmd0aCA8PSAyO1xuICAgIGNvbnN0IFtwYXJhbGxlbFJvdXRlS2V5LCBzZWdtZW50XSA9IGZsaWdodFNlZ21lbnRQYXRoO1xuICAgIGNvbnN0IHNlZ21lbnRGb3JDYWNoZSA9IEFycmF5LmlzQXJyYXkoc2VnbWVudCkgPyBzZWdtZW50WzFdIDogc2VnbWVudDtcbiAgICBjb25zdCBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCA9IGV4aXN0aW5nQ2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpO1xuICAgIGlmICghZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXApIHtcbiAgICAgICAgLy8gQmFpbG91dCBiZWNhdXNlIHRoZSBleGlzdGluZyBjYWNoZSBkb2VzIG5vdCBoYXZlIHRoZSBwYXRoIHRvIHRoZSBsZWFmIG5vZGVcbiAgICAgICAgLy8gV2lsbCB0cmlnZ2VyIGxhenkgZmV0Y2ggaW4gbGF5b3V0LXJvdXRlciBiZWNhdXNlIG9mIG1pc3Npbmcgc2VnbWVudFxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjaGlsZFNlZ21lbnRNYXAgPSBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5nZXQocGFyYWxsZWxSb3V0ZUtleSk7XG4gICAgaWYgKCFjaGlsZFNlZ21lbnRNYXAgfHwgY2hpbGRTZWdtZW50TWFwID09PSBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCkge1xuICAgICAgICBjaGlsZFNlZ21lbnRNYXAgPSBuZXcgTWFwKGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKTtcbiAgICAgICAgbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMuc2V0KHBhcmFsbGVsUm91dGVLZXksIGNoaWxkU2VnbWVudE1hcCk7XG4gICAgfVxuICAgIC8vIEluIGNhc2Ugb2YgbGFzdCBlbnRyeSBkb24ndCBjb3B5IGZ1cnRoZXIgZG93bi5cbiAgICBpZiAoaXNMYXN0RW50cnkpIHtcbiAgICAgICAgY2hpbGRTZWdtZW50TWFwLmRlbGV0ZShzZWdtZW50Rm9yQ2FjaGUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUgPSBleGlzdGluZ0NoaWxkU2VnbWVudE1hcC5nZXQoc2VnbWVudEZvckNhY2hlKTtcbiAgICBsZXQgY2hpbGRDYWNoZU5vZGUgPSBjaGlsZFNlZ21lbnRNYXAuZ2V0KHNlZ21lbnRGb3JDYWNoZSk7XG4gICAgaWYgKCFjaGlsZENhY2hlTm9kZSB8fCAhZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgICAgICAvLyBCYWlsb3V0IGJlY2F1c2UgdGhlIGV4aXN0aW5nIGNhY2hlIGRvZXMgbm90IGhhdmUgdGhlIHBhdGggdG8gdGhlIGxlYWYgbm9kZVxuICAgICAgICAvLyBXaWxsIHRyaWdnZXIgbGF6eSBmZXRjaCBpbiBsYXlvdXQtcm91dGVyIGJlY2F1c2Ugb2YgbWlzc2luZyBzZWdtZW50XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNoaWxkQ2FjaGVOb2RlID09PSBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlKSB7XG4gICAgICAgIGNoaWxkQ2FjaGVOb2RlID0ge1xuICAgICAgICAgICAgc3RhdHVzOiBjaGlsZENhY2hlTm9kZS5zdGF0dXMsXG4gICAgICAgICAgICBkYXRhOiBjaGlsZENhY2hlTm9kZS5kYXRhLFxuICAgICAgICAgICAgc3ViVHJlZURhdGE6IGNoaWxkQ2FjaGVOb2RlLnN1YlRyZWVEYXRhLFxuICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoY2hpbGRDYWNoZU5vZGUucGFyYWxsZWxSb3V0ZXMpXG4gICAgICAgIH07XG4gICAgICAgIGNoaWxkU2VnbWVudE1hcC5zZXQoc2VnbWVudEZvckNhY2hlLCBjaGlsZENhY2hlTm9kZSk7XG4gICAgfVxuICAgIGludmFsaWRhdGVDYWNoZUJlbG93RmxpZ2h0U2VnbWVudFBhdGgoY2hpbGRDYWNoZU5vZGUsIGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUsIGZsaWdodFNlZ21lbnRQYXRoLnNsaWNlKDIpKTtcbn1cbi8qKlxuICogRmlsbCBjYWNoZSB3aXRoIHN1YlRyZWVEYXRhIGJhc2VkIG9uIGZsaWdodERhdGFQYXRoIHRoYXQgd2FzIHByZWZldGNoZWRcbiAqIFRoaXMgb3BlcmF0aW9uIGlzIGFwcGVuZC1vbmx5IHRvIHRoZSBleGlzdGluZyBjYWNoZS5cbiAqLyBmdW5jdGlvbiBmaWxsQ2FjaGVXaXRoUHJlZmV0Y2hlZFN1YlRyZWVEYXRhKGV4aXN0aW5nQ2FjaGUsIGZsaWdodERhdGFQYXRoKSB7XG4gICAgY29uc3QgaXNMYXN0RW50cnkgPSBmbGlnaHREYXRhUGF0aC5sZW5ndGggPD0gNTtcbiAgICBjb25zdCBbcGFyYWxsZWxSb3V0ZUtleSwgc2VnbWVudF0gPSBmbGlnaHREYXRhUGF0aDtcbiAgICBjb25zdCBzZWdtZW50Rm9yQ2FjaGUgPSBBcnJheS5pc0FycmF5KHNlZ21lbnQpID8gc2VnbWVudFsxXSA6IHNlZ21lbnQ7XG4gICAgY29uc3QgZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXAgPSBleGlzdGluZ0NhY2hlLnBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlS2V5KTtcbiAgICBpZiAoIWV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKSB7XG4gICAgICAgIC8vIEJhaWxvdXQgYmVjYXVzZSB0aGUgZXhpc3RpbmcgY2FjaGUgZG9lcyBub3QgaGF2ZSB0aGUgcGF0aCB0byB0aGUgbGVhZiBub2RlXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdDaGlsZENhY2hlTm9kZSA9IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwLmdldChzZWdtZW50Rm9yQ2FjaGUpO1xuICAgIGlmIChpc0xhc3RFbnRyeSkge1xuICAgICAgICBpZiAoIWV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkQ2FjaGVOb2RlID0ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogX2FwcFJvdXRlckNvbnRleHQuQ2FjaGVTdGF0ZXMuUkVBRFksXG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBzdWJUcmVlRGF0YTogZmxpZ2h0RGF0YVBhdGhbM10sXG4gICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKGNoaWxkQ2FjaGVOb2RlLCBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlLCBmbGlnaHREYXRhUGF0aFsyXSwgZmxpZ2h0RGF0YVBhdGhbNF0pO1xuICAgICAgICAgICAgZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXAuc2V0KHNlZ21lbnRGb3JDYWNoZSwgY2hpbGRDYWNoZU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFleGlzdGluZ0NoaWxkQ2FjaGVOb2RlKSB7XG4gICAgICAgIC8vIEJhaWxvdXQgYmVjYXVzZSB0aGUgZXhpc3RpbmcgY2FjaGUgZG9lcyBub3QgaGF2ZSB0aGUgcGF0aCB0byB0aGUgbGVhZiBub2RlXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmlsbENhY2hlV2l0aFByZWZldGNoZWRTdWJUcmVlRGF0YShleGlzdGluZ0NoaWxkQ2FjaGVOb2RlLCBmbGlnaHREYXRhUGF0aC5zbGljZSgyKSk7XG59XG4vKipcbiAqIEtpY2sgb2ZmIGZldGNoIGJhc2VkIG9uIHRoZSBjb21tb24gbGF5b3V0IGJldHdlZW4gdHdvIHJvdXRlcy4gRmlsbCBjYWNoZSB3aXRoIGRhdGEgcHJvcGVydHkgaG9sZGluZyB0aGUgaW4tcHJvZ3Jlc3MgZmV0Y2guXG4gKi8gZnVuY3Rpb24gZmlsbENhY2hlV2l0aERhdGFQcm9wZXJ0eShuZXdDYWNoZSwgZXhpc3RpbmdDYWNoZSwgc2VnbWVudHMsIGZldGNoUmVzcG9uc2UpIHtcbiAgICBjb25zdCBpc0xhc3RFbnRyeSA9IHNlZ21lbnRzLmxlbmd0aCA9PT0gMTtcbiAgICBjb25zdCBwYXJhbGxlbFJvdXRlS2V5ID0gJ2NoaWxkcmVuJztcbiAgICBjb25zdCBbc2VnbWVudF0gPSBzZWdtZW50cztcbiAgICBjb25zdCBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCA9IGV4aXN0aW5nQ2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpO1xuICAgIGlmICghZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXApIHtcbiAgICAgICAgLy8gQmFpbG91dCBiZWNhdXNlIHRoZSBleGlzdGluZyBjYWNoZSBkb2VzIG5vdCBoYXZlIHRoZSBwYXRoIHRvIHRoZSBsZWFmIG5vZGVcbiAgICAgICAgLy8gV2lsbCB0cmlnZ2VyIGxhenkgZmV0Y2ggaW4gbGF5b3V0LXJvdXRlciBiZWNhdXNlIG9mIG1pc3Npbmcgc2VnbWVudFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmFpbE9wdGltaXN0aWM6IHRydWVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbGV0IGNoaWxkU2VnbWVudE1hcCA9IG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlS2V5KTtcbiAgICBpZiAoIWNoaWxkU2VnbWVudE1hcCB8fCBjaGlsZFNlZ21lbnRNYXAgPT09IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKSB7XG4gICAgICAgIGNoaWxkU2VnbWVudE1hcCA9IG5ldyBNYXAoZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXApO1xuICAgICAgICBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5zZXQocGFyYWxsZWxSb3V0ZUtleSwgY2hpbGRTZWdtZW50TWFwKTtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdDaGlsZENhY2hlTm9kZSA9IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwLmdldChzZWdtZW50KTtcbiAgICBsZXQgY2hpbGRDYWNoZU5vZGUgPSBjaGlsZFNlZ21lbnRNYXAuZ2V0KHNlZ21lbnQpO1xuICAgIC8vIEluIGNhc2Ugb2YgbGFzdCBzZWdtZW50IHN0YXJ0IG9mZiB0aGUgZmV0Y2ggYXQgdGhpcyBsZXZlbCBhbmQgZG9uJ3QgY29weSBmdXJ0aGVyIGRvd24uXG4gICAgaWYgKGlzTGFzdEVudHJ5KSB7XG4gICAgICAgIGlmICghY2hpbGRDYWNoZU5vZGUgfHwgIWNoaWxkQ2FjaGVOb2RlLmRhdGEgfHwgY2hpbGRDYWNoZU5vZGUgPT09IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUpIHtcbiAgICAgICAgICAgIGNoaWxkU2VnbWVudE1hcC5zZXQoc2VnbWVudCwge1xuICAgICAgICAgICAgICAgIHN0YXR1czogX2FwcFJvdXRlckNvbnRleHQuQ2FjaGVTdGF0ZXMuREFUQV9GRVRDSCxcbiAgICAgICAgICAgICAgICBkYXRhOiBmZXRjaFJlc3BvbnNlKCksXG4gICAgICAgICAgICAgICAgc3ViVHJlZURhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNoaWxkQ2FjaGVOb2RlIHx8ICFleGlzdGluZ0NoaWxkQ2FjaGVOb2RlKSB7XG4gICAgICAgIC8vIFN0YXJ0IGZldGNoIGluIHRoZSBwbGFjZSB3aGVyZSB0aGUgZXhpc3RpbmcgY2FjaGUgZG9lc24ndCBoYXZlIHRoZSBkYXRhIHlldC5cbiAgICAgICAgaWYgKCFjaGlsZENhY2hlTm9kZSkge1xuICAgICAgICAgICAgY2hpbGRTZWdtZW50TWFwLnNldChzZWdtZW50LCB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5EQVRBX0ZFVENILFxuICAgICAgICAgICAgICAgIGRhdGE6IGZldGNoUmVzcG9uc2UoKSxcbiAgICAgICAgICAgICAgICBzdWJUcmVlRGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjaGlsZENhY2hlTm9kZSA9PT0gZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgICAgICBjaGlsZENhY2hlTm9kZSA9IHtcbiAgICAgICAgICAgIHN0YXR1czogY2hpbGRDYWNoZU5vZGUuc3RhdHVzLFxuICAgICAgICAgICAgZGF0YTogY2hpbGRDYWNoZU5vZGUuZGF0YSxcbiAgICAgICAgICAgIHN1YlRyZWVEYXRhOiBjaGlsZENhY2hlTm9kZS5zdWJUcmVlRGF0YSxcbiAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKGNoaWxkQ2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzKVxuICAgICAgICB9O1xuICAgICAgICBjaGlsZFNlZ21lbnRNYXAuc2V0KHNlZ21lbnQsIGNoaWxkQ2FjaGVOb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbGxDYWNoZVdpdGhEYXRhUHJvcGVydHkoY2hpbGRDYWNoZU5vZGUsIGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUsIHNlZ21lbnRzLnNsaWNlKDEpLCBmZXRjaFJlc3BvbnNlKTtcbn1cbi8qKlxuICogQ3JlYXRlIG9wdGltaXN0aWMgdmVyc2lvbiBvZiByb3V0ZXIgc3RhdGUgYmFzZWQgb24gdGhlIGV4aXN0aW5nIHJvdXRlciBzdGF0ZSBhbmQgc2VnbWVudHMuXG4gKiBUaGlzIGlzIHVzZWQgdG8gYWxsb3cgcmVuZGVyaW5nIGxheW91dC1yb3V0ZXJzIHVwIHRpbGwgdGhlIHBvaW50IHdoZXJlIGRhdGEgaXMgbWlzc2luZy5cbiAqLyBmdW5jdGlvbiBjcmVhdGVPcHRpbWlzdGljVHJlZShzZWdtZW50cywgZmxpZ2h0Um91dGVyU3RhdGUsIF9pc0ZpcnN0U2VnbWVudCwgcGFyZW50UmVmZXRjaCwgX2hyZWYpIHtcbiAgICBjb25zdCBbZXhpc3RpbmdTZWdtZW50LCBleGlzdGluZ1BhcmFsbGVsUm91dGVzXSA9IGZsaWdodFJvdXRlclN0YXRlIHx8IFtcbiAgICAgICAgbnVsbCxcbiAgICAgICAge30sIFxuICAgIF07XG4gICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzWzBdO1xuICAgIGNvbnN0IGlzTGFzdFNlZ21lbnQgPSBzZWdtZW50cy5sZW5ndGggPT09IDE7XG4gICAgY29uc3Qgc2VnbWVudE1hdGNoZXMgPSBleGlzdGluZ1NlZ21lbnQgIT09IG51bGwgJiYgKDAsIF9tYXRjaFNlZ21lbnRzKS5tYXRjaFNlZ21lbnQoZXhpc3RpbmdTZWdtZW50LCBzZWdtZW50KTtcbiAgICBjb25zdCBzaG91bGRSZWZldGNoVGhpc0xldmVsID0gIWZsaWdodFJvdXRlclN0YXRlIHx8ICFzZWdtZW50TWF0Y2hlcztcbiAgICBsZXQgcGFyYWxsZWxSb3V0ZXMgPSB7fTtcbiAgICBpZiAoZXhpc3RpbmdTZWdtZW50ICE9PSBudWxsICYmIHNlZ21lbnRNYXRjaGVzKSB7XG4gICAgICAgIHBhcmFsbGVsUm91dGVzID0gZXhpc3RpbmdQYXJhbGxlbFJvdXRlcztcbiAgICB9XG4gICAgbGV0IGNoaWxkVHJlZTtcbiAgICBpZiAoIWlzTGFzdFNlZ21lbnQpIHtcbiAgICAgICAgY29uc3QgY2hpbGRJdGVtID0gY3JlYXRlT3B0aW1pc3RpY1RyZWUoc2VnbWVudHMuc2xpY2UoMSksIHBhcmFsbGVsUm91dGVzID8gcGFyYWxsZWxSb3V0ZXMuY2hpbGRyZW4gOiBudWxsLCBmYWxzZSwgcGFyZW50UmVmZXRjaCB8fCBzaG91bGRSZWZldGNoVGhpc0xldmVsKTtcbiAgICAgICAgY2hpbGRUcmVlID0gY2hpbGRJdGVtO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXG4gICAgICAgIHNlZ21lbnQsXG4gICAgICAgIF9leHRlbmRzKHt9LCBwYXJhbGxlbFJvdXRlcywgY2hpbGRUcmVlID8ge1xuICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkVHJlZVxuICAgICAgICB9IDoge30pLCBcbiAgICBdO1xuICAgIGlmICghcGFyZW50UmVmZXRjaCAmJiBzaG91bGRSZWZldGNoVGhpc0xldmVsKSB7XG4gICAgICAgIHJlc3VsdFszXSA9ICdyZWZldGNoJztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQXBwbHkgdGhlIHJvdXRlciBzdGF0ZSBmcm9tIHRoZSBGbGlnaHQgcmVzcG9uc2UuIENyZWF0ZXMgYSBuZXcgcm91dGVyIHN0YXRlIHRyZWUuXG4gKi8gZnVuY3Rpb24gYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKGZsaWdodFNlZ21lbnRQYXRoLCBmbGlnaHRSb3V0ZXJTdGF0ZSwgdHJlZVBhdGNoKSB7XG4gICAgY29uc3QgW3NlZ21lbnQsIHBhcmFsbGVsUm91dGVzLCAsICwgaXNSb290TGF5b3V0XSA9IGZsaWdodFJvdXRlclN0YXRlO1xuICAgIC8vIFJvb3QgcmVmcmVzaFxuICAgIGlmIChmbGlnaHRTZWdtZW50UGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29uc3QgdHJlZSA9IFtcbiAgICAgICAgICAgIC4uLnRyZWVQYXRjaFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICB9XG4gICAgY29uc3QgW2N1cnJlbnRTZWdtZW50LCBwYXJhbGxlbFJvdXRlS2V5XSA9IGZsaWdodFNlZ21lbnRQYXRoO1xuICAgIC8vIFRyZWUgcGF0aCByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXIgc2hvdWxkIGFsd2F5cyBtYXRjaCB1cCB3aXRoIHRoZSBjdXJyZW50IHRyZWUgaW4gdGhlIGJyb3dzZXJcbiAgICBpZiAoISgwLCBfbWF0Y2hTZWdtZW50cykubWF0Y2hTZWdtZW50KGN1cnJlbnRTZWdtZW50LCBzZWdtZW50KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbGFzdFNlZ21lbnQgPSBmbGlnaHRTZWdtZW50UGF0aC5sZW5ndGggPT09IDI7XG4gICAgbGV0IHBhcmFsbGVsUm91dGVQYXRjaDtcbiAgICBpZiAobGFzdFNlZ21lbnQpIHtcbiAgICAgICAgcGFyYWxsZWxSb3V0ZVBhdGNoID0gdHJlZVBhdGNoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFsbGVsUm91dGVQYXRjaCA9IGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZShmbGlnaHRTZWdtZW50UGF0aC5zbGljZSgyKSwgcGFyYWxsZWxSb3V0ZXNbcGFyYWxsZWxSb3V0ZUtleV0sIHRyZWVQYXRjaCk7XG4gICAgICAgIGlmIChwYXJhbGxlbFJvdXRlUGF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRyZWUgPSBbXG4gICAgICAgIGZsaWdodFNlZ21lbnRQYXRoWzBdLFxuICAgICAgICBfZXh0ZW5kcyh7fSwgcGFyYWxsZWxSb3V0ZXMsIHtcbiAgICAgICAgICAgIFtwYXJhbGxlbFJvdXRlS2V5XTogcGFyYWxsZWxSb3V0ZVBhdGNoXG4gICAgICAgIH0pLCBcbiAgICBdO1xuICAgIC8vIEN1cnJlbnQgc2VnbWVudCBpcyB0aGUgcm9vdCBsYXlvdXRcbiAgICBpZiAoaXNSb290TGF5b3V0KSB7XG4gICAgICAgIHRyZWVbNF0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdHJlZTtcbn1cbmZ1bmN0aW9uIHNob3VsZEhhcmROYXZpZ2F0ZShmbGlnaHRTZWdtZW50UGF0aCwgZmxpZ2h0Um91dGVyU3RhdGUsIHRyZWVQYXRjaCkge1xuICAgIGNvbnN0IFtzZWdtZW50LCBwYXJhbGxlbFJvdXRlc10gPSBmbGlnaHRSb3V0ZXJTdGF0ZTtcbiAgICAvLyBUT0RPLUFQUDogQ2hlY2sgaWYgYGFzYCBjYW4gYmUgcmVwbGFjZWQuXG4gICAgY29uc3QgW2N1cnJlbnRTZWdtZW50LCBwYXJhbGxlbFJvdXRlS2V5XSA9IGZsaWdodFNlZ21lbnRQYXRoO1xuICAgIC8vIENoZWNrIGlmIGN1cnJlbnQgc2VnbWVudCBtYXRjaGVzIHRoZSBleGlzdGluZyBzZWdtZW50LlxuICAgIGlmICghKDAsIF9tYXRjaFNlZ21lbnRzKS5tYXRjaFNlZ21lbnQoY3VycmVudFNlZ21lbnQsIHNlZ21lbnQpKSB7XG4gICAgICAgIC8vIElmIGR5bmFtaWMgcGFyYW1ldGVyIGluIHRyZWUgZG9lc24ndCBtYXRjaCB1cCB3aXRoIHNlZ21lbnQgcGF0aCBhIGhhcmQgbmF2aWdhdGlvbiBpcyB0cmlnZ2VyZWQuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRTZWdtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGV4aXN0aW5nIHNlZ21lbnQgZGlkIG5vdCBtYXRjaCBzb2Z0IG5hdmlnYXRpb24gaXMgdHJpZ2dlcmVkLlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGxhc3RTZWdtZW50ID0gZmxpZ2h0U2VnbWVudFBhdGgubGVuZ3RoIDw9IDI7XG4gICAgaWYgKGxhc3RTZWdtZW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHNob3VsZEhhcmROYXZpZ2F0ZShmbGlnaHRTZWdtZW50UGF0aC5zbGljZSgyKSwgcGFyYWxsZWxSb3V0ZXNbcGFyYWxsZWxSb3V0ZUtleV0sIHRyZWVQYXRjaCk7XG59XG5mdW5jdGlvbiBpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQoY3VycmVudFRyZWUsIG5leHRUcmVlKSB7XG4gICAgLy8gQ29tcGFyZSBzZWdtZW50c1xuICAgIGNvbnN0IGN1cnJlbnRUcmVlU2VnbWVudCA9IGN1cnJlbnRUcmVlWzBdO1xuICAgIGNvbnN0IG5leHRUcmVlU2VnbWVudCA9IG5leHRUcmVlWzBdO1xuICAgIC8vIElmIGFueSBzZWdtZW50IGlzIGRpZmZlcmVudCBiZWZvcmUgd2UgZmluZCB0aGUgcm9vdCBsYXlvdXQsIHRoZSByb290IGxheW91dCBoYXMgY2hhbmdlZC5cbiAgICAvLyBFLmcuIC9zYW1lLyhncm91cDEpL2xheW91dC5qcyAtPiAvc2FtZS8oZ3JvdXAyKS9sYXlvdXQuanNcbiAgICAvLyBGaXJzdCBzZWdtZW50IGlzICdzYW1lJyBmb3IgYm90aCwga2VlcCBsb29raW5nLiAoZ3JvdXAxKSBjaGFuZ2VkIHRvIChncm91cDIpIGJlZm9yZSB0aGUgcm9vdCBsYXlvdXQgd2FzIGZvdW5kLCBpdCBtdXN0IGhhdmUgY2hhbmdlZC5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50VHJlZVNlZ21lbnQpICYmIEFycmF5LmlzQXJyYXkobmV4dFRyZWVTZWdtZW50KSkge1xuICAgICAgICAvLyBDb21wYXJlIGR5bmFtaWMgcGFyYW0gbmFtZSBhbmQgdHlwZSBidXQgaWdub3JlIHRoZSB2YWx1ZSwgZGlmZmVyZW50IHZhbHVlcyB3b3VsZCBub3QgYWZmZWN0IHRoZSBjdXJyZW50IHJvb3QgbGF5b3V0XG4gICAgICAgIC8vIC9bbmFtZV0gLSAvc2x1ZzEgYW5kIC9zbHVnMiwgYm90aCB2YWx1ZXMgKHNsdWcxICYgc2x1ZzIpIHN0aWxsIGhhcyB0aGUgc2FtZSBsYXlvdXQgL1tuYW1lXS9sYXlvdXQuanNcbiAgICAgICAgaWYgKGN1cnJlbnRUcmVlU2VnbWVudFswXSAhPT0gbmV4dFRyZWVTZWdtZW50WzBdIHx8IGN1cnJlbnRUcmVlU2VnbWVudFsyXSAhPT0gbmV4dFRyZWVTZWdtZW50WzJdKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY3VycmVudFRyZWVTZWdtZW50ICE9PSBuZXh0VHJlZVNlZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIEN1cnJlbnQgdHJlZSByb290IGxheW91dCBmb3VuZFxuICAgIGlmIChjdXJyZW50VHJlZVs0XSkge1xuICAgICAgICAvLyBJZiB0aGUgbmV4dCB0cmVlIGRvZXNuJ3QgaGF2ZSB0aGUgcm9vdCBsYXlvdXQgZmxhZywgaXQgbXVzdCBoYXZlIGNoYW5nZWQuXG4gICAgICAgIHJldHVybiAhbmV4dFRyZWVbNF07XG4gICAgfVxuICAgIC8vIEN1cnJlbnQgdHJlZSAgZGlkbid0IGhhdmUgaXRzIHJvb3QgbGF5b3V0IGhlcmUsIG11c3QgaGF2ZSBjaGFuZ2VkLlxuICAgIGlmIChuZXh0VHJlZVs0XSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gV2UgY2FuJ3QgYXNzdW1lIGl0J3MgYHBhcmFsbGVsUm91dGVzLmNoaWxkcmVuYCBoZXJlIGluIGNhc2UgdGhlIHJvb3QgbGF5b3V0IGlzIGBhcHAvQHNvbWV0aGluZy9sYXlvdXQuanNgXG4gICAgLy8gQnV0IGl0J3Mgbm90IHBvc3NpYmxlIHRvIGJlIG1vcmUgdGhhbiBvbmUgcGFyYWxsZWxSb3V0ZXMgYmVmb3JlIHRoZSByb290IGxheW91dCBpcyBmb3VuZFxuICAgIC8vIFRPRE8tQVBQOiBjaGFuZ2UgdG8gdHJhdmVyc2UgYWxsIHBhcmFsbGVsIHJvdXRlc1xuICAgIGNvbnN0IGN1cnJlbnRUcmVlQ2hpbGQgPSBPYmplY3QudmFsdWVzKGN1cnJlbnRUcmVlWzFdKVswXTtcbiAgICBjb25zdCBuZXh0VHJlZUNoaWxkID0gT2JqZWN0LnZhbHVlcyhuZXh0VHJlZVsxXSlbMF07XG4gICAgaWYgKCFjdXJyZW50VHJlZUNoaWxkIHx8ICFuZXh0VHJlZUNoaWxkKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KGN1cnJlbnRUcmVlQ2hpbGQsIG5leHRUcmVlQ2hpbGQpO1xufVxuY29uc3QgQUNUSU9OX1JFRlJFU0ggPSAncmVmcmVzaCc7XG5leHBvcnRzLkFDVElPTl9SRUZSRVNIID0gQUNUSU9OX1JFRlJFU0g7XG5jb25zdCBBQ1RJT05fTkFWSUdBVEUgPSAnbmF2aWdhdGUnO1xuZXhwb3J0cy5BQ1RJT05fTkFWSUdBVEUgPSBBQ1RJT05fTkFWSUdBVEU7XG5jb25zdCBBQ1RJT05fUkVTVE9SRSA9ICdyZXN0b3JlJztcbmV4cG9ydHMuQUNUSU9OX1JFU1RPUkUgPSBBQ1RJT05fUkVTVE9SRTtcbmNvbnN0IEFDVElPTl9TRVJWRVJfUEFUQ0ggPSAnc2VydmVyLXBhdGNoJztcbmV4cG9ydHMuQUNUSU9OX1NFUlZFUl9QQVRDSCA9IEFDVElPTl9TRVJWRVJfUEFUQ0g7XG5jb25zdCBBQ1RJT05fUFJFRkVUQ0ggPSAncHJlZmV0Y2gnO1xuZXhwb3J0cy5BQ1RJT05fUFJFRkVUQ0ggPSBBQ1RJT05fUFJFRkVUQ0g7XG4vKipcbiAqIFJlZHVjZXIgdGhhdCBoYW5kbGVzIHRoZSBhcHAtcm91dGVyIHN0YXRlIHVwZGF0ZXMuXG4gKi8gZnVuY3Rpb24gY2xpZW50UmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgc3dpdGNoKGFjdGlvbi50eXBlKXtcbiAgICAgICAgY2FzZSBBQ1RJT05fTkFWSUdBVEU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB1cmwgLCBuYXZpZ2F0ZVR5cGUgLCBjYWNoZSAsIG11dGFibGUgLCBmb3JjZU9wdGltaXN0aWNOYXZpZ2F0aW9uICB9ID0gYWN0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGF0aG5hbWUgLCBzZWFyY2ggIH0gPSB1cmw7XG4gICAgICAgICAgICAgICAgY29uc3QgaHJlZiA9IGNyZWF0ZUhyZWZGcm9tVXJsKHVybCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGVuZGluZ1B1c2ggPSBuYXZpZ2F0ZVR5cGUgPT09ICdwdXNoJztcbiAgICAgICAgICAgICAgICBjb25zdCBpc0ZvckN1cnJlbnRUcmVlID0gSlNPTi5zdHJpbmdpZnkobXV0YWJsZS5wcmV2aW91c1RyZWUpID09PSBKU09OLnN0cmluZ2lmeShzdGF0ZS50cmVlKTtcbiAgICAgICAgICAgICAgICBpZiAobXV0YWJsZS5tcGFOYXZpZ2F0aW9uICYmIGlzRm9yQ3VycmVudFRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBocmVmLlxuICAgICAgICAgICAgICAgICAgICAgICAgY2Fub25pY2FsVXJsOiBtdXRhYmxlLmNhbm9uaWNhbFVybE92ZXJyaWRlID8gbXV0YWJsZS5jYW5vbmljYWxVcmxPdmVycmlkZSA6IGhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1B1c2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXBhTmF2aWdhdGlvbjogbXV0YWJsZS5tcGFOYXZpZ2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsIG5hdmlnYXRpb24gcmVxdWlyZXMgc2Nyb2xsIGFuZCBmb2N1cyBtYW5hZ2VtZW50IHRvIHRyaWdnZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IGNhY2hlLlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IHN0YXRlLmNhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmV0Y2hDYWNoZTogc3RhdGUucHJlZmV0Y2hDYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHBhdGNoZWQgcm91dGVyIHN0YXRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZTogc3RhdGUudHJlZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgY29uY3VycmVudCByZW5kZXJpbmcgLyBzdHJpY3QgbW9kZSBjYXNlIHdoZXJlIHRoZSBjYWNoZSBhbmQgdHJlZSB3ZXJlIGFscmVhZHkgcG9wdWxhdGVkLlxuICAgICAgICAgICAgICAgIGlmIChtdXRhYmxlLnBhdGNoZWRUcmVlICYmIGlzRm9yQ3VycmVudFRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBocmVmLlxuICAgICAgICAgICAgICAgICAgICAgICAgY2Fub25pY2FsVXJsOiBtdXRhYmxlLmNhbm9uaWNhbFVybE92ZXJyaWRlID8gbXV0YWJsZS5jYW5vbmljYWxVcmxPdmVycmlkZSA6IGhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1B1c2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXBhTmF2aWdhdGlvbjogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgbmF2aWdhdGlvbiByZXF1aXJlcyBzY3JvbGwgYW5kIGZvY3VzIG1hbmFnZW1lbnQgdG8gdHJpZ2dlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHk6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlOiBtdXRhYmxlLnVzZUV4aXN0aW5nQ2FjaGUgPyBzdGF0ZS5jYWNoZSA6IGNhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmV0Y2hDYWNoZTogc3RhdGUucHJlZmV0Y2hDYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHBhdGNoZWQgcm91dGVyIHN0YXRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZTogbXV0YWJsZS5wYXRjaGVkVHJlZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwcmVmZXRjaFZhbHVlcyA9IHN0YXRlLnByZWZldGNoQ2FjaGUuZ2V0KGhyZWYpO1xuICAgICAgICAgICAgICAgIGlmIChwcmVmZXRjaFZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgb25lIGJlZm9yZSBsYXN0IGl0ZW0gaXMgdGhlIHJvdXRlciBzdGF0ZSB0cmVlIHBhdGNoXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZmxpZ2h0U2VnbWVudFBhdGggLCB0cmVlOiBuZXdUcmVlICwgY2Fub25pY2FsVXJsT3ZlcnJpZGUgLCAgfSA9IHByZWZldGNoVmFsdWVzO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3VHJlZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5wcmV2aW91c1RyZWUgPSBzdGF0ZS50cmVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5wYXRjaGVkVHJlZSA9IG5ld1RyZWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRhYmxlLm1wYU5hdmlnYXRpb24gPSBpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQoc3RhdGUudHJlZSwgbmV3VHJlZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXJkTmF2aWdhdGUgPSAvLyBUT0RPLUFQUDogUmV2aXNpdCBpZiB0aGlzIGlzIGNvcnJlY3QuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2ggIT09IGxvY2F0aW9uLnNlYXJjaCB8fCBzaG91bGRIYXJkTmF2aWdhdGUoLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmZsaWdodFNlZ21lbnRQYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICBdLCBzdGF0ZS50cmVlLCBuZXdUcmVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXJkTmF2aWdhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IHN1YlRyZWVEYXRhIGZvciB0aGUgcm9vdCBub2RlIG9mIHRoZSBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zdWJUcmVlRGF0YSA9IHN0YXRlLmNhY2hlLnN1YlRyZWVEYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludmFsaWRhdGVDYWNoZUJlbG93RmxpZ2h0U2VnbWVudFBhdGgoY2FjaGUsIHN0YXRlLmNhY2hlLCBmbGlnaHRTZWdtZW50UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGFibGUudXNlRXhpc3RpbmdDYWNoZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYgPSBjYW5vbmljYWxVcmxPdmVycmlkZSA/IGNyZWF0ZUhyZWZGcm9tVXJsKGNhbm9uaWNhbFVybE92ZXJyaWRlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybE92ZXJyaWRlID0gY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgaHJlZi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5vbmljYWxVcmw6IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA/IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA6IGhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHBlbmRpbmdQdXNoLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hSZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1B1c2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1wYU5hdmlnYXRpb246IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgbmF2aWdhdGlvbiByZXF1aXJlcyBzY3JvbGwgYW5kIGZvY3VzIG1hbmFnZW1lbnQgdG8gdHJpZ2dlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgcGF0Y2hlZCBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogbXV0YWJsZS51c2VFeGlzdGluZ0NhY2hlID8gc3RhdGUuY2FjaGUgOiBjYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHBhdGNoZWQgdHJlZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlOiBuZXdUcmVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdoZW4gZG9pbmcgYSBoYXJkIHB1c2ggdGhlcmUgY2FuIGJlIHR3byBjYXNlczogd2l0aCBvcHRpbWlzdGljIHRyZWUgYW5kIHdpdGhvdXRcbiAgICAgICAgICAgICAgICAvLyBUaGUgd2l0aCBvcHRpbWlzdGljIHRyZWUgY2FzZSBvbmx5IGhhcHBlbnMgd2hlbiB0aGUgbGF5b3V0cyBoYXZlIGEgbG9hZGluZyBzdGF0ZSAobG9hZGluZy5qcylcbiAgICAgICAgICAgICAgICAvLyBUaGUgd2l0aG91dCBvcHRpbWlzdGljIHRyZWUgY2FzZSBoYXBwZW5zIHdoZW4gdGhlcmUgaXMgbm8gbG9hZGluZyBzdGF0ZSwgaW4gdGhhdCBjYXNlIHdlIHN1c3BlbmQgaW4gdGhpcyByZWR1Y2VyXG4gICAgICAgICAgICAgICAgLy8gZm9yY2VPcHRpbWlzdGljTmF2aWdhdGlvbiBpcyB1c2VkIGZvciBsaW5rcyB0aGF0IGhhdmUgYHByZWZldGNoPXtmYWxzZX1gLlxuICAgICAgICAgICAgICAgIGlmIChmb3JjZU9wdGltaXN0aWNOYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlZ21lbnRzID0gcGF0aG5hbWUuc3BsaXQoJy8nKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IGZpZ3VyZSBvdXQgc29tZXRoaW5nIGJldHRlciBmb3IgaW5kZXggcGFnZXNcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXN0aWMgdHJlZSBjYXNlLlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb3B0aW1pc3RpYyB0cmVlIGlzIGRlZXBlciB0aGFuIHRoZSBjdXJyZW50IHN0YXRlIGxlYXZlIHRoYXQgZGVlcGVyIHBhcnQgb3V0IG9mIHRoZSBmZXRjaFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRpbWlzdGljVHJlZSA9IGNyZWF0ZU9wdGltaXN0aWNUcmVlKHNlZ21lbnRzLCBzdGF0ZS50cmVlLCB0cnVlLCBmYWxzZSwgaHJlZik7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvcHkgc3ViVHJlZURhdGEgZm9yIHRoZSByb290IG5vZGUgb2YgdGhlIGNhY2hlLlxuICAgICAgICAgICAgICAgICAgICBjYWNoZS5zdWJUcmVlRGF0YSA9IHN0YXRlLmNhY2hlLnN1YlRyZWVEYXRhO1xuICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IGV4aXN0aW5nIGNhY2hlIG5vZGVzIGFzIGZhciBhcyBwb3NzaWJsZSBhbmQgZmlsbCBpbiBgZGF0YWAgcHJvcGVydHkgd2l0aCB0aGUgc3RhcnRlZCBkYXRhIGZldGNoLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYGRhdGFgIHByb3BlcnR5IGlzIHVzZWQgdG8gc3VzcGVuZCBpbiBsYXlvdXQtcm91dGVyIGR1cmluZyByZW5kZXIgaWYgaXQgaGFzbid0IHJlc29sdmVkIHlldCBieSB0aGUgdGltZSBpdCByZW5kZXJzLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBmaWxsQ2FjaGVXaXRoRGF0YVByb3BlcnR5KGNhY2hlLCBzdGF0ZS5jYWNoZSwgLy8gVE9ETy1BUFA6IHNlZ21lbnRzLnNsaWNlKDEpIHN0cmlwcyAnJywgd2UgY2FuIGdldCByaWQgb2YgJycgYWx0b2dldGhlci5cbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMuc2xpY2UoMSksICgpPT4oMCwgX2FwcFJvdXRlcikuZmV0Y2hTZXJ2ZXJSZXNwb25zZSh1cmwsIG9wdGltaXN0aWNUcmVlKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG9wdGltaXN0aWMgZmV0Y2ggY291bGRuJ3QgaGFwcGVuIGl0IGZhbGxzIGJhY2sgdG8gdGhlIG5vbi1vcHRpbWlzdGljIGNhc2UuXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHJlcyA9PSBudWxsID8gdm9pZCAwIDogcmVzLmJhaWxPcHRpbWlzdGljKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5wcmV2aW91c1RyZWUgPSBzdGF0ZS50cmVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5wYXRjaGVkVHJlZSA9IG9wdGltaXN0aWNUcmVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5tcGFOYXZpZ2F0aW9uID0gaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KHN0YXRlLnRyZWUsIG9wdGltaXN0aWNUcmVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGhyZWYuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2Fub25pY2FsVXJsOiBocmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBwZW5kaW5nUHVzaC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdQdXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtcGFOYXZpZ2F0aW9uOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsIG5hdmlnYXRpb24gcmVxdWlyZXMgc2Nyb2xsIGFuZCBmb2N1cyBtYW5hZ2VtZW50IHRvIHRyaWdnZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHk6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHBhdGNoZWQgY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IGNhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgb3B0aW1pc3RpYyB0cmVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWU6IG9wdGltaXN0aWNUcmVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEJlbG93IGlzIHRoZSBub3Qtb3B0aW1pc3RpYyBjYXNlLiBEYXRhIGlzIGZldGNoZWQgYXQgdGhlIHJvb3QgYW5kIHN1c3BlbmRlZCB0aGVyZSB3aXRob3V0IGEgc3VzcGVuc2UgYm91bmRhcnkuXG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gaW4tZmxpZ2h0IGZldGNoIGF0IHRoZSB0b3AsIHN0YXJ0IGl0LlxuICAgICAgICAgICAgICAgIGlmICghY2FjaGUuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZS5kYXRhID0gY3JlYXRlUmVjb3JkRnJvbVRoZW5hYmxlKCgwLCBfYXBwUm91dGVyKS5mZXRjaFNlcnZlclJlc3BvbnNlKHVybCwgc3RhdGUudHJlZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbndyYXAgY2FjaGUgZGF0YSB3aXRoIGB1c2VgIHRvIHN1c3BlbmQgaGVyZSAoaW4gdGhlIHJlZHVjZXIpIHVudGlsIHRoZSBmZXRjaCByZXNvbHZlcy5cbiAgICAgICAgICAgICAgICBjb25zdCBbZmxpZ2h0RGF0YSwgY2Fub25pY2FsVXJsT3ZlcnJpZGVdID0gcmVhZFJlY29yZFZhbHVlKGNhY2hlLmRhdGEpO1xuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gbmF2aWdhdGluZyB0byBwYWdlIGluIGBwYWdlc2AgZnJvbSBgYXBwYFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbm9uaWNhbFVybDogZmxpZ2h0RGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuYWJsZSBtcGFOYXZpZ2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1B1c2g6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXBhTmF2aWdhdGlvbjogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGFwcGx5IHNjcm9sbCBhbmQgZm9jdXMgbWFuYWdlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHk6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IHN0YXRlLmNhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmV0Y2hDYWNoZTogc3RhdGUucHJlZmV0Y2hDYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWU6IHN0YXRlLnRyZWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGNhY2hlLmRhdGEgYXMgaXQgaGFzIGJlZW4gcmVzb2x2ZWQgYXQgdGhpcyBwb2ludC5cbiAgICAgICAgICAgICAgICBjYWNoZS5kYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBUT0RPLUFQUDogQ3VycmVudGx5IHRoZSBGbGlnaHQgZGF0YSBjYW4gb25seSBoYXZlIG9uZSBpdGVtIGJ1dCBpbiB0aGUgZnV0dXJlIGl0IGNhbiBoYXZlIG11bHRpcGxlIHBhdGhzLlxuICAgICAgICAgICAgICAgIGNvbnN0IGZsaWdodERhdGFQYXRoID0gZmxpZ2h0RGF0YVswXTtcbiAgICAgICAgICAgICAgICAvLyBUaGUgb25lIGJlZm9yZSBsYXN0IGl0ZW0gaXMgdGhlIHJvdXRlciBzdGF0ZSB0cmVlIHBhdGNoXG4gICAgICAgICAgICAgICAgY29uc3QgW3RyZWVQYXRjaCwgc3ViVHJlZURhdGEsIGhlYWRdID0gZmxpZ2h0RGF0YVBhdGguc2xpY2UoLTMpO1xuICAgICAgICAgICAgICAgIC8vIFBhdGggd2l0aG91dCB0aGUgbGFzdCBzZWdtZW50LCByb3V0ZXIgc3RhdGUsIGFuZCB0aGUgc3ViVHJlZURhdGFcbiAgICAgICAgICAgICAgICBjb25zdCBmbGlnaHRTZWdtZW50UGF0aCA9IGZsaWdodERhdGFQYXRoLnNsaWNlKDAsIC00KTtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgbmV3IHRyZWUgYmFzZWQgb24gdGhlIGZsaWdodFNlZ21lbnRQYXRoIGFuZCByb3V0ZXIgc3RhdGUgcGF0Y2hcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdUcmVlID0gYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgICAgICAgICAuLi5mbGlnaHRTZWdtZW50UGF0aFxuICAgICAgICAgICAgICAgIF0sIHN0YXRlLnRyZWUsIHRyZWVQYXRjaCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1RyZWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTRUdNRU5UIE1JU01BVENIJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA9IGNhbm9uaWNhbFVybE92ZXJyaWRlID8gY3JlYXRlSHJlZkZyb21VcmwoY2Fub25pY2FsVXJsT3ZlcnJpZGUpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmIChjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmxPdmVycmlkZSA9IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbXV0YWJsZS5wcmV2aW91c1RyZWUgPSBzdGF0ZS50cmVlO1xuICAgICAgICAgICAgICAgIG11dGFibGUucGF0Y2hlZFRyZWUgPSBuZXdUcmVlO1xuICAgICAgICAgICAgICAgIG11dGFibGUubXBhTmF2aWdhdGlvbiA9IGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dChzdGF0ZS50cmVlLCBuZXdUcmVlKTtcbiAgICAgICAgICAgICAgICBpZiAoZmxpZ2h0RGF0YVBhdGgubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLnN1YlRyZWVEYXRhID0gc3ViVHJlZURhdGE7XG4gICAgICAgICAgICAgICAgICAgIGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKGNhY2hlLCBzdGF0ZS5jYWNoZSwgdHJlZVBhdGNoLCBoZWFkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IHN1YlRyZWVEYXRhIGZvciB0aGUgcm9vdCBub2RlIG9mIHRoZSBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuc3ViVHJlZURhdGEgPSBzdGF0ZS5jYWNoZS5zdWJUcmVlRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGUgZXhpc3RpbmcgY2FjaGUgd2l0aCB0aGUgc3ViVHJlZURhdGEgYXBwbGllZC5cbiAgICAgICAgICAgICAgICAgICAgZmlsbENhY2hlV2l0aE5ld1N1YlRyZWVEYXRhKGNhY2hlLCBzdGF0ZS5jYWNoZSwgZmxpZ2h0RGF0YVBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgaHJlZi5cbiAgICAgICAgICAgICAgICAgICAgY2Fub25pY2FsVXJsOiBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYgPyBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYgOiBocmVmLFxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgcGVuZGluZ1B1c2guXG4gICAgICAgICAgICAgICAgICAgIHB1c2hSZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdQdXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXBhTmF2aWdhdGlvbjogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgLy8gQWxsIG5hdmlnYXRpb24gcmVxdWlyZXMgc2Nyb2xsIGFuZCBmb2N1cyBtYW5hZ2VtZW50IHRvIHRyaWdnZXIuXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBseTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwYXRjaGVkIGNhY2hlLlxuICAgICAgICAgICAgICAgICAgICBjYWNoZTogY2FjaGUsXG4gICAgICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHBhdGNoZWQgdHJlZS5cbiAgICAgICAgICAgICAgICAgICAgdHJlZTogbmV3VHJlZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgQUNUSU9OX1NFUlZFUl9QQVRDSDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGZsaWdodERhdGEgLCBwcmV2aW91c1RyZWUgLCBvdmVycmlkZUNhbm9uaWNhbFVybCAsIGNhY2hlICwgbXV0YWJsZSAgfSA9IGFjdGlvbjtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIGEgZmV0Y2ggaXMgc2xvdyB0byByZXNvbHZlIGl0IGNvdWxkIGJlIHRoYXQgeW91IG5hdmlnYXRlZCBhd2F5IHdoaWxlIHRoZSByZXF1ZXN0IHdhcyBoYXBwZW5pbmcgb3IgYmVmb3JlIHRoZSByZWR1Y2VyIHJ1bnMuXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhhdCBjYXNlIG9wdC1vdXQgb2YgYXBwbHlpbmcgdGhlIHBhdGNoIGdpdmVuIHRoYXQgdGhlIGRhdGEgY291bGQgYmUgc3RhbGUuXG4gICAgICAgICAgICAgICAgaWYgKEpTT04uc3RyaW5naWZ5KHByZXZpb3VzVHJlZSkgIT09IEpTT04uc3RyaW5naWZ5KHN0YXRlLnRyZWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBIYW5kbGUgdHJlZSBtaXNtYXRjaFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVFJFRSBNSVNNQVRDSCcpO1xuICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIGV2ZXJ5dGhpbmcgYXMtaXMuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG11dGFibGUubXBhTmF2aWdhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGhyZWYuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5vbmljYWxVcmw6IG11dGFibGUuY2Fub25pY2FsVXJsT3ZlcnJpZGUgPyBtdXRhYmxlLmNhbm9uaWNhbFVybE92ZXJyaWRlIDogc3RhdGUuY2Fub25pY2FsVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IHZlcmlmeSBtcGFOYXZpZ2F0aW9uIG5vdCBiZWluZyBzZXQgaXMgY29ycmVjdCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdQdXNoOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1wYU5hdmlnYXRpb246IG11dGFibGUubXBhTmF2aWdhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBuYXZpZ2F0aW9uIHJlcXVpcmVzIHNjcm9sbCBhbmQgZm9jdXMgbWFuYWdlbWVudCB0byB0cmlnZ2VyLlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlOiBzdGF0ZS5jYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwYXRjaGVkIHJvdXRlciBzdGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWU6IHN0YXRlLnRyZWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGNvbmN1cnJlbnQgcmVuZGVyaW5nIC8gc3RyaWN0IG1vZGUgY2FzZSB3aGVyZSB0aGUgY2FjaGUgYW5kIHRyZWUgd2VyZSBhbHJlYWR5IHBvcHVsYXRlZC5cbiAgICAgICAgICAgICAgICBpZiAobXV0YWJsZS5wYXRjaGVkVHJlZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCBocmVmIGFzIGl0IHdhcyBzZXQgZHVyaW5nIG5hdmlnYXRlIC8gcmVzdG9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgY2Fub25pY2FsVXJsOiBtdXRhYmxlLmNhbm9uaWNhbFVybE92ZXJyaWRlID8gbXV0YWJsZS5jYW5vbmljYWxVcmxPdmVycmlkZSA6IHN0YXRlLmNhbm9uaWNhbFVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgcHVzaFJlZiBhcyBzZXJ2ZXItcGF0Y2ggb25seSBjYXVzZXMgY2FjaGUvdHJlZSB1cGRhdGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoUmVmOiBzdGF0ZS5wdXNoUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCBmb2N1c0FuZFNjcm9sbFJlZiBhcyBzZXJ2ZXItcGF0Y2ggb25seSBjYXVzZXMgY2FjaGUvdHJlZSB1cGRhdGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZjogc3RhdGUuZm9jdXNBbmRTY3JvbGxSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwYXRjaGVkIHJvdXRlciBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZTogbXV0YWJsZS5wYXRjaGVkVHJlZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwYXRjaGVkIGNhY2hlXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBuYXZpZ2F0aW5nIHRvIHBhZ2UgaW4gYHBhZ2VzYCBmcm9tIGBhcHBgXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbGlnaHREYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGhyZWYuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5vbmljYWxVcmw6IGZsaWdodERhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbmFibGUgbXBhTmF2aWdhdGlvbiBhcyB0aGlzIGlzIGEgbmF2aWdhdGlvbiB0aGF0IHRoZSBhcHAtcm91dGVyIHNob3VsZG4ndCBoYW5kbGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1B1c2g6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXBhTmF2aWdhdGlvbjogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGFwcGx5IHNjcm9sbCBhbmQgZm9jdXMgbWFuYWdlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHk6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXIgc3RhdGUgaXMga2VwdCBhcy1pcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlOiBzdGF0ZS5jYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmVlOiBzdGF0ZS50cmVlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBDdXJyZW50bHkgdGhlIEZsaWdodCBkYXRhIGNhbiBvbmx5IGhhdmUgb25lIGl0ZW0gYnV0IGluIHRoZSBmdXR1cmUgaXQgY2FuIGhhdmUgbXVsdGlwbGUgcGF0aHMuXG4gICAgICAgICAgICAgICAgY29uc3QgZmxpZ2h0RGF0YVBhdGggPSBmbGlnaHREYXRhWzBdO1xuICAgICAgICAgICAgICAgIC8vIFNsaWNlcyBvZmYgdGhlIGxhc3Qgc2VnbWVudCAod2hpY2ggaXMgYXQgLTQpIGFzIGl0IGRvZXNuJ3QgZXhpc3QgaW4gdGhlIHRyZWUgeWV0XG4gICAgICAgICAgICAgICAgY29uc3QgZmxpZ2h0U2VnbWVudFBhdGggPSBmbGlnaHREYXRhUGF0aC5zbGljZSgwLCAtNCk7XG4gICAgICAgICAgICAgICAgY29uc3QgW3RyZWVQYXRjaCwgc3ViVHJlZURhdGEsIGhlYWRdID0gZmxpZ2h0RGF0YVBhdGguc2xpY2UoLTMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1RyZWUgPSBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUoLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAgICAgICAgIC4uLmZsaWdodFNlZ21lbnRQYXRoXG4gICAgICAgICAgICAgICAgXSwgc3RhdGUudHJlZSwgdHJlZVBhdGNoKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3VHJlZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NFR01FTlQgTUlTTUFUQ0gnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmID0gb3ZlcnJpZGVDYW5vbmljYWxVcmwgPyBjcmVhdGVIcmVmRnJvbVVybChvdmVycmlkZUNhbm9uaWNhbFVybCkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZikge1xuICAgICAgICAgICAgICAgICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybE92ZXJyaWRlID0gY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtdXRhYmxlLnBhdGNoZWRUcmVlID0gbmV3VHJlZTtcbiAgICAgICAgICAgICAgICBtdXRhYmxlLm1wYU5hdmlnYXRpb24gPSBpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQoc3RhdGUudHJlZSwgbmV3VHJlZSk7XG4gICAgICAgICAgICAgICAgLy8gUm9vdCByZWZyZXNoXG4gICAgICAgICAgICAgICAgaWYgKGZsaWdodERhdGFQYXRoLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZS5zdWJUcmVlRGF0YSA9IHN1YlRyZWVEYXRhO1xuICAgICAgICAgICAgICAgICAgICBmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZChjYWNoZSwgc3RhdGUuY2FjaGUsIHRyZWVQYXRjaCwgaGVhZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29weSBzdWJUcmVlRGF0YSBmb3IgdGhlIHJvb3Qgbm9kZSBvZiB0aGUgY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLnN1YlRyZWVEYXRhID0gc3RhdGUuY2FjaGUuc3ViVHJlZURhdGE7XG4gICAgICAgICAgICAgICAgICAgIGZpbGxDYWNoZVdpdGhOZXdTdWJUcmVlRGF0YShjYWNoZSwgc3RhdGUuY2FjaGUsIGZsaWdodERhdGFQYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCBocmVmIGFzIGl0IHdhcyBzZXQgZHVyaW5nIG5hdmlnYXRlIC8gcmVzdG9yZVxuICAgICAgICAgICAgICAgICAgICBjYW5vbmljYWxVcmw6IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA/IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA6IHN0YXRlLmNhbm9uaWNhbFVybCxcbiAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCBwdXNoUmVmIGFzIHNlcnZlci1wYXRjaCBvbmx5IGNhdXNlcyBjYWNoZS90cmVlIHVwZGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgcHVzaFJlZjogc3RhdGUucHVzaFJlZixcbiAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCBmb2N1c0FuZFNjcm9sbFJlZiBhcyBzZXJ2ZXItcGF0Y2ggb25seSBjYXVzZXMgY2FjaGUvdHJlZSB1cGRhdGUuXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiBzdGF0ZS5mb2N1c0FuZFNjcm9sbFJlZixcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgcGF0Y2hlZCByb3V0ZXIgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgdHJlZTogbmV3VHJlZSxcbiAgICAgICAgICAgICAgICAgICAgcHJlZmV0Y2hDYWNoZTogc3RhdGUucHJlZmV0Y2hDYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgcGF0Y2hlZCBjYWNoZVxuICAgICAgICAgICAgICAgICAgICBjYWNoZTogY2FjaGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIEFDVElPTl9SRVNUT1JFOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdXJsICwgdHJlZSAgfSA9IGFjdGlvbjtcbiAgICAgICAgICAgICAgICBjb25zdCBocmVmID0gY3JlYXRlSHJlZkZyb21VcmwodXJsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgY2Fub25pY2FsIHVybFxuICAgICAgICAgICAgICAgICAgICBjYW5vbmljYWxVcmw6IGhyZWYsXG4gICAgICAgICAgICAgICAgICAgIHB1c2hSZWY6IHN0YXRlLnB1c2hSZWYsXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiBzdGF0ZS5mb2N1c0FuZFNjcm9sbFJlZixcbiAgICAgICAgICAgICAgICAgICAgY2FjaGU6IHN0YXRlLmNhY2hlLFxuICAgICAgICAgICAgICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIHByb3ZpZGVkIHRyZWVcbiAgICAgICAgICAgICAgICAgICAgdHJlZTogdHJlZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8tQVBQOiBBZGQgdGVzdCBmb3Igbm90IHNjcm9sbGluZyB0byBuZWFyZXN0IGxheW91dCB3aGVuIGNhbGxpbmcgcmVmcmVzaC5cbiAgICAgICAgLy8gVE9ETy1BUFA6IEFkZCB0ZXN0IGZvciBzdGFydFRyYW5zaXRpb24oKCkgPT4ge3JvdXRlci5wdXNoKCcvJyk7IHJvdXRlci5yZWZyZXNoKCk7fSksIHRoYXQgY2FzZSBzaG91bGQgc2Nyb2xsLlxuICAgICAgICBjYXNlIEFDVElPTl9SRUZSRVNIOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY2FjaGUgLCBtdXRhYmxlICB9ID0gYWN0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhyZWYgPSBzdGF0ZS5jYW5vbmljYWxVcmw7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNGb3JDdXJyZW50VHJlZSA9IEpTT04uc3RyaW5naWZ5KG11dGFibGUucHJldmlvdXNUcmVlKSA9PT0gSlNPTi5zdHJpbmdpZnkoc3RhdGUudHJlZSk7XG4gICAgICAgICAgICAgICAgaWYgKG11dGFibGUubXBhTmF2aWdhdGlvbiAmJiBpc0ZvckN1cnJlbnRUcmVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgaHJlZi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbm9uaWNhbFVybDogbXV0YWJsZS5jYW5vbmljYWxVcmxPdmVycmlkZSA/IG11dGFibGUuY2Fub25pY2FsVXJsT3ZlcnJpZGUgOiBzdGF0ZS5jYW5vbmljYWxVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPLUFQUDogdmVyaWZ5IG1wYU5hdmlnYXRpb24gbm90IGJlaW5nIHNldCBpcyBjb3JyZWN0IGhlcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1B1c2g6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXBhTmF2aWdhdGlvbjogbXV0YWJsZS5tcGFOYXZpZ2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsIG5hdmlnYXRpb24gcmVxdWlyZXMgc2Nyb2xsIGFuZCBmb2N1cyBtYW5hZ2VtZW50IHRvIHRyaWdnZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IGNhY2hlLlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IHN0YXRlLmNhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmV0Y2hDYWNoZTogc3RhdGUucHJlZmV0Y2hDYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHBhdGNoZWQgcm91dGVyIHN0YXRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZTogc3RhdGUudHJlZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgY29uY3VycmVudCByZW5kZXJpbmcgLyBzdHJpY3QgbW9kZSBjYXNlIHdoZXJlIHRoZSBjYWNoZSBhbmQgdHJlZSB3ZXJlIGFscmVhZHkgcG9wdWxhdGVkLlxuICAgICAgICAgICAgICAgIGlmIChtdXRhYmxlLnBhdGNoZWRUcmVlICYmIGlzRm9yQ3VycmVudFRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBocmVmLlxuICAgICAgICAgICAgICAgICAgICAgICAgY2Fub25pY2FsVXJsOiBtdXRhYmxlLmNhbm9uaWNhbFVybE92ZXJyaWRlID8gbXV0YWJsZS5jYW5vbmljYWxVcmxPdmVycmlkZSA6IGhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgcGVuZGluZ1B1c2ggKGFsd2F5cyBmYWxzZSBpbiB0aGlzIGNhc2UpLlxuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaFJlZjogc3RhdGUucHVzaFJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IGZvY3VzIGFuZCBzY3JvbGwuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPLUFQUDogbWlnaHQgbmVlZCB0byBkaXNhYmxlIHRoaXMgZm9yIEZhc3QgUmVmcmVzaC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHk6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IGNhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmV0Y2hDYWNoZTogc3RhdGUucHJlZmV0Y2hDYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWU6IG11dGFibGUucGF0Y2hlZFRyZWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoZS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZldGNoIGRhdGEgZnJvbSB0aGUgcm9vdCBvZiB0aGUgdHJlZS5cbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuZGF0YSA9IGNyZWF0ZVJlY29yZEZyb21UaGVuYWJsZSgoMCwgX2FwcFJvdXRlcikuZmV0Y2hTZXJ2ZXJSZXNwb25zZShuZXcgVVJMKGhyZWYsIGxvY2F0aW9uLm9yaWdpbiksIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnRyZWVbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS50cmVlWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudHJlZVsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZWZldGNoJywgXG4gICAgICAgICAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgW2ZsaWdodERhdGEsIGNhbm9uaWNhbFVybE92ZXJyaWRlXSA9IHJlYWRSZWNvcmRWYWx1ZShjYWNoZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIG5hdmlnYXRpbmcgdG8gcGFnZSBpbiBgcGFnZXNgIGZyb20gYGFwcGBcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZsaWdodERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5vbmljYWxVcmw6IGZsaWdodERhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1B1c2g6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXBhTmF2aWdhdGlvbjogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHk6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IHN0YXRlLmNhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmV0Y2hDYWNoZTogc3RhdGUucHJlZmV0Y2hDYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWU6IHN0YXRlLnRyZWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGNhY2hlLmRhdGEgYXMgaXQgaGFzIGJlZW4gcmVzb2x2ZWQgYXQgdGhpcyBwb2ludC5cbiAgICAgICAgICAgICAgICBjYWNoZS5kYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBUT0RPLUFQUDogQ3VycmVudGx5IHRoZSBGbGlnaHQgZGF0YSBjYW4gb25seSBoYXZlIG9uZSBpdGVtIGJ1dCBpbiB0aGUgZnV0dXJlIGl0IGNhbiBoYXZlIG11bHRpcGxlIHBhdGhzLlxuICAgICAgICAgICAgICAgIGNvbnN0IGZsaWdodERhdGFQYXRoID0gZmxpZ2h0RGF0YVswXTtcbiAgICAgICAgICAgICAgICAvLyBGbGlnaHREYXRhUGF0aCB3aXRoIG1vcmUgdGhhbiB0d28gaXRlbXMgbWVhbnMgdW5leHBlY3RlZCBGbGlnaHQgZGF0YSB3YXMgcmV0dXJuZWRcbiAgICAgICAgICAgICAgICBpZiAoZmxpZ2h0RGF0YVBhdGgubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBoYW5kbGUgdGhpcyBjYXNlIGJldHRlclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUkVGUkVTSCBGQUlMRUQnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBHaXZlbiB0aGUgcGF0aCBjYW4gb25seSBoYXZlIHR3byBpdGVtcyB0aGUgaXRlbXMgYXJlIG9ubHkgdGhlIHJvdXRlciBzdGF0ZSBhbmQgc3ViVHJlZURhdGEgZm9yIHRoZSByb290LlxuICAgICAgICAgICAgICAgIGNvbnN0IFt0cmVlUGF0Y2gsIHN1YlRyZWVEYXRhLCBoZWFkXSA9IGZsaWdodERhdGFQYXRoO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1RyZWUgPSBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUoLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICAgICBdLCBzdGF0ZS50cmVlLCB0cmVlUGF0Y2gpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdUcmVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU0VHTUVOVCBNSVNNQVRDSCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYgPSBjYW5vbmljYWxVcmxPdmVycmlkZSA/IGNyZWF0ZUhyZWZGcm9tVXJsKGNhbm9uaWNhbFVybE92ZXJyaWRlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAoY2Fub25pY2FsVXJsT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmxPdmVycmlkZSA9IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbXV0YWJsZS5wcmV2aW91c1RyZWUgPSBzdGF0ZS50cmVlO1xuICAgICAgICAgICAgICAgIG11dGFibGUucGF0Y2hlZFRyZWUgPSBuZXdUcmVlO1xuICAgICAgICAgICAgICAgIG11dGFibGUubXBhTmF2aWdhdGlvbiA9IGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dChzdGF0ZS50cmVlLCBuZXdUcmVlKTtcbiAgICAgICAgICAgICAgICAvLyBTZXQgc3ViVHJlZURhdGEgZm9yIHRoZSByb290IG5vZGUgb2YgdGhlIGNhY2hlLlxuICAgICAgICAgICAgICAgIGNhY2hlLnN1YlRyZWVEYXRhID0gc3ViVHJlZURhdGE7XG4gICAgICAgICAgICAgICAgZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQoY2FjaGUsIHN0YXRlLmNhY2hlLCB0cmVlUGF0Y2gsIGhlYWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBocmVmLCB0aGlzIGRvZXNuJ3QgcmV1c2UgdGhlIHN0YXRlLmNhbm9uaWNhbFVybCBhcyBiZWNhdXNlIG9mIGNvbmN1cnJlbnQgcmVuZGVyaW5nIHRoZSBocmVmIG1pZ2h0IGNoYW5nZSBiZXR3ZWVuIGRpc3BhdGNoaW5nIGFuZCBhcHBseWluZy5cbiAgICAgICAgICAgICAgICAgICAgY2Fub25pY2FsVXJsOiBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYgPyBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYgOiBocmVmLFxuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgcGVuZGluZ1B1c2ggKGFsd2F5cyBmYWxzZSBpbiB0aGlzIGNhc2UpLlxuICAgICAgICAgICAgICAgICAgICBwdXNoUmVmOiBzdGF0ZS5wdXNoUmVmLFxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPLUFQUDogbWlnaHQgbmVlZCB0byBkaXNhYmxlIHRoaXMgZm9yIEZhc3QgUmVmcmVzaC5cbiAgICAgICAgICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwYXRjaGVkIGNhY2hlLlxuICAgICAgICAgICAgICAgICAgICBjYWNoZTogY2FjaGUsXG4gICAgICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHBhdGNoZWQgcm91dGVyIHN0YXRlLlxuICAgICAgICAgICAgICAgICAgICB0cmVlOiBuZXdUcmVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBBQ1RJT05fUFJFRkVUQ0g6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB1cmwgLCBzZXJ2ZXJSZXNwb25zZSAgfSA9IGFjdGlvbjtcbiAgICAgICAgICAgICAgICBjb25zdCBbZmxpZ2h0RGF0YSwgY2Fub25pY2FsVXJsT3ZlcnJpZGVdID0gc2VydmVyUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbGlnaHREYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGhyZWYgPSBjcmVhdGVIcmVmRnJvbVVybCh1cmwpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBDdXJyZW50bHkgdGhlIEZsaWdodCBkYXRhIGNhbiBvbmx5IGhhdmUgb25lIGl0ZW0gYnV0IGluIHRoZSBmdXR1cmUgaXQgY2FuIGhhdmUgbXVsdGlwbGUgcGF0aHMuXG4gICAgICAgICAgICAgICAgY29uc3QgZmxpZ2h0RGF0YVBhdGggPSBmbGlnaHREYXRhWzBdO1xuICAgICAgICAgICAgICAgIC8vIFRoZSBvbmUgYmVmb3JlIGxhc3QgaXRlbSBpcyB0aGUgcm91dGVyIHN0YXRlIHRyZWUgcGF0Y2hcbiAgICAgICAgICAgICAgICBjb25zdCBbdHJlZVBhdGNoLCBzdWJUcmVlRGF0YV0gPSBmbGlnaHREYXRhUGF0aC5zbGljZSgtMyk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IFZlcmlmeSBpZiBgbnVsbGAgY2FuJ3QgYmUgcmV0dXJuZWQgZnJvbSB1c2VyIGNvZGUuXG4gICAgICAgICAgICAgICAgLy8gSWYgc3ViVHJlZURhdGEgaXMgbnVsbCB0aGUgcHJlZmV0Y2ggZGlkIG5vdCBwcm92aWRlIGEgY29tcG9uZW50IHRyZWUuXG4gICAgICAgICAgICAgICAgaWYgKHN1YlRyZWVEYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGxDYWNoZVdpdGhQcmVmZXRjaGVkU3ViVHJlZURhdGEoc3RhdGUuY2FjaGUsIGZsaWdodERhdGFQYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZmxpZ2h0U2VnbWVudFBhdGggPSBmbGlnaHREYXRhUGF0aC5zbGljZSgwLCAtMyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VHJlZSA9IGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSgvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICAgICAgICAgLi4uZmxpZ2h0U2VnbWVudFBhdGhcbiAgICAgICAgICAgICAgICBdLCBzdGF0ZS50cmVlLCB0cmVlUGF0Y2gpO1xuICAgICAgICAgICAgICAgIC8vIFBhdGNoIGRpZCBub3QgYXBwbHkgY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgaWYgKG5ld1RyZWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgbmV3IHRyZWUgYmFzZWQgb24gdGhlIGZsaWdodFNlZ21lbnRQYXRoIGFuZCByb3V0ZXIgc3RhdGUgcGF0Y2hcbiAgICAgICAgICAgICAgICBzdGF0ZS5wcmVmZXRjaENhY2hlLnNldChocmVmLCB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhdGggd2l0aG91dCB0aGUgbGFzdCBzZWdtZW50LCByb3V0ZXIgc3RhdGUsIGFuZCB0aGUgc3ViVHJlZURhdGFcbiAgICAgICAgICAgICAgICAgICAgZmxpZ2h0U2VnbWVudFBhdGgsXG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBuZXcgdHJlZSBiYXNlZCBvbiB0aGUgZmxpZ2h0U2VnbWVudFBhdGggYW5kIHJvdXRlciBzdGF0ZSBwYXRjaFxuICAgICAgICAgICAgICAgICAgICB0cmVlOiBuZXdUcmVlLFxuICAgICAgICAgICAgICAgICAgICBjYW5vbmljYWxVcmxPdmVycmlkZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyBjYXNlIHNob3VsZCBuZXZlciBiZSBoaXQgYXMgZGlzcGF0Y2ggaXMgc3Ryb25nbHkgdHlwZWQuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gYWN0aW9uJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2VydmVyUmVkdWNlcihzdGF0ZSwgX2FjdGlvbikge1xuICAgIHJldHVybiBzdGF0ZTtcbn1cbmNvbnN0IHJlZHVjZXIgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IHNlcnZlclJlZHVjZXIgOiBjbGllbnRSZWR1Y2VyO1xuZXhwb3J0cy5yZWR1Y2VyID0gcmVkdWNlcjtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVkdWNlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjcmVhdGVIcmVmRnJvbVVybCIsInJlZHVjZXIiLCJBQ1RJT05fUFJFRkVUQ0giLCJBQ1RJT05fU0VSVkVSX1BBVENIIiwiQUNUSU9OX1JFU1RPUkUiLCJBQ1RJT05fTkFWSUdBVEUiLCJBQ1RJT05fUkVGUkVTSCIsIl9leHRlbmRzIiwicmVxdWlyZSIsIl9hcHBSb3V0ZXJDb250ZXh0IiwiX21hdGNoU2VnbWVudHMiLCJfYXBwUm91dGVyIiwiY3JlYXRlUmVjb3JkRnJvbVRoZW5hYmxlIiwidGhlbmFibGUiLCJzdGF0dXMiLCJ0aGVuIiwiZXJyIiwicmVhZFJlY29yZFZhbHVlIiwidXJsIiwicGF0aG5hbWUiLCJzZWFyY2giLCJoYXNoIiwiaW52YWxpZGF0ZUNhY2hlQnlSb3V0ZXJTdGF0ZSIsIm5ld0NhY2hlIiwiZXhpc3RpbmdDYWNoZSIsInJvdXRlclN0YXRlIiwia2V5Iiwic2VnbWVudEZvclBhcmFsbGVsUm91dGUiLCJjYWNoZUtleSIsIkFycmF5IiwiaXNBcnJheSIsImV4aXN0aW5nUGFyYWxsZWxSb3V0ZXNDYWNoZU5vZGUiLCJwYXJhbGxlbFJvdXRlcyIsImdldCIsInBhcmFsbGVsUm91dGVDYWNoZU5vZGUiLCJNYXAiLCJzZXQiLCJmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCIsImhlYWQiLCJpc0xhc3RTZWdtZW50Iiwia2V5cyIsImxlbmd0aCIsInBhcmFsbGVsUm91dGVTdGF0ZSIsIm5ld0NhY2hlTm9kZSIsIkNhY2hlU3RhdGVzIiwiTEFaWV9JTklUSUFMSVpFRCIsImRhdGEiLCJzdWJUcmVlRGF0YSIsInVuZGVmaW5lZCIsImZpbGxDYWNoZVdpdGhOZXdTdWJUcmVlRGF0YSIsImZsaWdodERhdGFQYXRoIiwiaXNMYXN0RW50cnkiLCJwYXJhbGxlbFJvdXRlS2V5Iiwic2VnbWVudCIsInNlZ21lbnRGb3JDYWNoZSIsImV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwIiwiY2hpbGRTZWdtZW50TWFwIiwiZXhpc3RpbmdDaGlsZENhY2hlTm9kZSIsImNoaWxkQ2FjaGVOb2RlIiwiUkVBRFkiLCJzbGljZSIsImludmFsaWRhdGVDYWNoZUJlbG93RmxpZ2h0U2VnbWVudFBhdGgiLCJmbGlnaHRTZWdtZW50UGF0aCIsImZpbGxDYWNoZVdpdGhQcmVmZXRjaGVkU3ViVHJlZURhdGEiLCJmaWxsQ2FjaGVXaXRoRGF0YVByb3BlcnR5Iiwic2VnbWVudHMiLCJmZXRjaFJlc3BvbnNlIiwiYmFpbE9wdGltaXN0aWMiLCJEQVRBX0ZFVENIIiwiY3JlYXRlT3B0aW1pc3RpY1RyZWUiLCJmbGlnaHRSb3V0ZXJTdGF0ZSIsIl9pc0ZpcnN0U2VnbWVudCIsInBhcmVudFJlZmV0Y2giLCJfaHJlZiIsImV4aXN0aW5nU2VnbWVudCIsImV4aXN0aW5nUGFyYWxsZWxSb3V0ZXMiLCJzZWdtZW50TWF0Y2hlcyIsIm1hdGNoU2VnbWVudCIsInNob3VsZFJlZmV0Y2hUaGlzTGV2ZWwiLCJjaGlsZFRyZWUiLCJjaGlsZEl0ZW0iLCJjaGlsZHJlbiIsInJlc3VsdCIsImFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSIsInRyZWVQYXRjaCIsImlzUm9vdExheW91dCIsInRyZWUiLCJjdXJyZW50U2VnbWVudCIsImxhc3RTZWdtZW50IiwicGFyYWxsZWxSb3V0ZVBhdGNoIiwic2hvdWxkSGFyZE5hdmlnYXRlIiwiaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IiwiY3VycmVudFRyZWUiLCJuZXh0VHJlZSIsImN1cnJlbnRUcmVlU2VnbWVudCIsIm5leHRUcmVlU2VnbWVudCIsImN1cnJlbnRUcmVlQ2hpbGQiLCJ2YWx1ZXMiLCJuZXh0VHJlZUNoaWxkIiwiY2xpZW50UmVkdWNlciIsInN0YXRlIiwiYWN0aW9uIiwidHlwZSIsIm5hdmlnYXRlVHlwZSIsImNhY2hlIiwibXV0YWJsZSIsImZvcmNlT3B0aW1pc3RpY05hdmlnYXRpb24iLCJocmVmIiwicGVuZGluZ1B1c2giLCJpc0ZvckN1cnJlbnRUcmVlIiwiSlNPTiIsInN0cmluZ2lmeSIsInByZXZpb3VzVHJlZSIsIm1wYU5hdmlnYXRpb24iLCJjYW5vbmljYWxVcmwiLCJjYW5vbmljYWxVcmxPdmVycmlkZSIsInB1c2hSZWYiLCJmb2N1c0FuZFNjcm9sbFJlZiIsImFwcGx5IiwicHJlZmV0Y2hDYWNoZSIsInBhdGNoZWRUcmVlIiwidXNlRXhpc3RpbmdDYWNoZSIsInByZWZldGNoVmFsdWVzIiwibmV3VHJlZSIsImhhcmROYXZpZ2F0ZSIsImxvY2F0aW9uIiwiY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmIiwic3BsaXQiLCJwdXNoIiwib3B0aW1pc3RpY1RyZWUiLCJyZXMiLCJmZXRjaFNlcnZlclJlc3BvbnNlIiwiZmxpZ2h0RGF0YSIsIkVycm9yIiwib3ZlcnJpZGVDYW5vbmljYWxVcmwiLCJjb25zb2xlIiwibG9nIiwiVVJMIiwib3JpZ2luIiwic2VydmVyUmVzcG9uc2UiLCJzZXJ2ZXJSZWR1Y2VyIiwiX2FjdGlvbiIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/reducer.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/render-from-template-context.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/render-from-template-context.js ***!
  \**********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\"use client\";\n\"use strict\";\n\nvar _s = $RefreshSig$();\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = RenderFromTemplateContext;\n\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(app-client)/./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\n\nvar _react = _interop_require_wildcard(__webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\"));\n\nvar _appRouterContext = __webpack_require__(/*! ../../shared/lib/app-router-context */ \"(app-client)/./node_modules/next/dist/shared/lib/app-router-context.js\");\n\nfunction RenderFromTemplateContext() {\n  _s();\n\n  var children = (0, _react).useContext(_appRouterContext.TemplateContext);\n  return /*#__PURE__*/_react[\"default\"].createElement(_react[\"default\"].Fragment, null, children);\n}\n\n_s(RenderFromTemplateContext, \"Fd1ieM0FAzMq7OA5+LlfYPV5S7Y=\");\n\n_c = RenderFromTemplateContext;\n\nif ((typeof exports[\"default\"] === 'function' || typeof exports[\"default\"] === 'object' && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === 'undefined') {\n  Object.defineProperty(exports[\"default\"], '__esModule', {\n    value: true\n  });\n  Object.assign(exports[\"default\"], exports);\n  module.exports = exports[\"default\"];\n}\n\nvar _c;\n\n$RefreshReg$(_c, \"RenderFromTemplateContext\");\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZW5kZXItZnJvbS10ZW1wbGF0ZS1jb250ZXh0LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Ozs7QUFDQUEsOENBQTZDO0VBQ3pDRyxLQUFLLEVBQUU7QUFEa0MsQ0FBN0M7QUFHQUQsa0JBQUEsR0FBa0JFLHlCQUFsQjs7QUFDQSxJQUFJQyx5QkFBeUIsR0FBR0Msa0tBQWhDOztBQUNBLElBQUlDLE1BQU0sR0FBR0YseUJBQXlCLENBQUNDLG1CQUFPLENBQUMsNEVBQUQsQ0FBUixDQUF0Qzs7QUFDQSxJQUFJRSxpQkFBaUIsR0FBR0YsbUJBQU8sQ0FBQyxtSEFBRCxDQUEvQjs7QUFDQSxTQUFTRix5QkFBVCxHQUFxQztFQUFBOztFQUNqQyxJQUFNSyxRQUFRLEdBQUcsQ0FBQyxHQUFHRixNQUFKLEVBQVlHLFVBQVosQ0FBdUJGLGlCQUFpQixDQUFDRyxlQUF6QyxDQUFqQjtFQUNBLE9BQU8sYUFBY0osTUFBTSxXQUFOLENBQWVLLGFBQWYsQ0FBNkJMLE1BQU0sV0FBTixDQUFlTSxRQUE1QyxFQUFzRCxJQUF0RCxFQUE0REosUUFBNUQsQ0FBckI7QUFDSDs7R0FIUUwseUI7O0tBQUFBLHlCOztBQU1ULElBQUksQ0FBQyxPQUFPRixPQUFPLFdBQWQsS0FBMkIsVUFBM0IsSUFBMEMsT0FBT0EsT0FBTyxXQUFkLEtBQTJCLFFBQTNCLElBQXVDQSxPQUFPLFdBQVAsS0FBb0IsSUFBdEcsS0FBZ0gsT0FBT0EsT0FBTyxXQUFQLENBQWdCWSxVQUF2QixLQUFzQyxXQUExSixFQUF1SztFQUNyS2QsTUFBTSxDQUFDQyxjQUFQLENBQXNCQyxPQUFPLFdBQTdCLEVBQXVDLFlBQXZDLEVBQXFEO0lBQUVDLEtBQUssRUFBRTtFQUFULENBQXJEO0VBQ0FILE1BQU0sQ0FBQ2UsTUFBUCxDQUFjYixPQUFPLFdBQXJCLEVBQStCQSxPQUEvQjtFQUNBYyxNQUFNLENBQUNkLE9BQVAsR0FBaUJBLE9BQU8sV0FBeEI7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlbmRlci1mcm9tLXRlbXBsYXRlLWNvbnRleHQuanM/OGVlNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gUmVuZGVyRnJvbVRlbXBsYXRlQ29udGV4dDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5qc1wiKS5kZWZhdWx0O1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfYXBwUm91dGVyQ29udGV4dCA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dFwiKTtcbmZ1bmN0aW9uIFJlbmRlckZyb21UZW1wbGF0ZUNvbnRleHQoKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSAoMCwgX3JlYWN0KS51c2VDb250ZXh0KF9hcHBSb3V0ZXJDb250ZXh0LlRlbXBsYXRlQ29udGV4dCk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pO1xufVxuXG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbmRlci1mcm9tLXRlbXBsYXRlLWNvbnRleHQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUmVuZGVyRnJvbVRlbXBsYXRlQ29udGV4dCIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJyZXF1aXJlIiwiX3JlYWN0IiwiX2FwcFJvdXRlckNvbnRleHQiLCJjaGlsZHJlbiIsInVzZUNvbnRleHQiLCJUZW1wbGF0ZUNvbnRleHQiLCJjcmVhdGVFbGVtZW50IiwiRnJhZ21lbnQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/render-from-template-context.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/use-reducer-with-devtools.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/use-reducer-with-devtools.js ***!
  \*******************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar _slicedToArray = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/slicedToArray.js */ \"(app-client)/./node_modules/next/dist/compiled/@babel/runtime/helpers/slicedToArray.js\");\n\nvar _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.useReducerWithReduxDevtools = void 0;\n\nvar _react = __webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\");\n\nfunction normalizeRouterState(val) {\n  if (val instanceof Map) {\n    var obj = {};\n\n    var _iterator = _createForOfIteratorHelper(val.entries()),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _step$value = _slicedToArray(_step.value, 2),\n            key = _step$value[0],\n            value = _step$value[1];\n\n        if (typeof value === 'function') {\n          obj[key] = 'fn()';\n          continue;\n        }\n\n        if (typeof value === 'object' && value !== null) {\n          if (value.$$typeof) {\n            obj[key] = value.$$typeof.toString();\n            continue;\n          }\n\n          if (value._bundlerConfig) {\n            obj[key] = 'FlightData';\n            continue;\n          }\n        }\n\n        obj[key] = normalizeRouterState(value);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return obj;\n  }\n\n  if (typeof val === 'object' && val !== null) {\n    var _obj = {};\n\n    for (var _key in val) {\n      var _value = val[_key];\n\n      if (typeof _value === 'function') {\n        _obj[_key] = 'fn()';\n        continue;\n      }\n\n      if (typeof _value === 'object' && _value !== null) {\n        if (_value.$$typeof) {\n          _obj[_key] = _value.$$typeof.toString();\n          continue;\n        }\n\n        if (_value.hasOwnProperty('_bundlerConfig')) {\n          _obj[_key] = 'FlightData';\n          continue;\n        }\n      }\n\n      _obj[_key] = normalizeRouterState(_value);\n    }\n\n    return _obj;\n  }\n\n  if (Array.isArray(val)) {\n    return val.map(normalizeRouterState);\n  }\n\n  return val;\n}\n\nfunction devToolReducer(fn, ref) {\n  return function (state, action) {\n    var res = fn(state, action);\n\n    if (ref.current) {\n      ref.current.send(action, normalizeRouterState(res));\n    }\n\n    return res;\n  };\n}\n\nfunction useReducerWithReduxDevtoolsNoop(fn, initialState) {\n  _s();\n\n  var _useReducer = (0, _react).useReducer(fn, initialState),\n      _useReducer2 = _slicedToArray(_useReducer, 2),\n      state = _useReducer2[0],\n      dispatch = _useReducer2[1];\n\n  return [state, dispatch, function () {}];\n}\n\n_s(useReducerWithReduxDevtoolsNoop, \"6JWkGZ32UPfojeNx+xqn8ZU8A0Q=\");\n\nfunction useReducerWithReduxDevtoolsImpl(fn, initialState) {\n  _s2();\n\n  var devtoolsConnectionRef = (0, _react).useRef();\n  var enabledRef = (0, _react).useRef();\n  (0, _react).useEffect(function () {\n    if (devtoolsConnectionRef.current || enabledRef.current === false) {\n      return;\n    }\n\n    if (enabledRef.current === undefined && typeof window.__REDUX_DEVTOOLS_EXTENSION__ === 'undefined') {\n      enabledRef.current = false;\n      return;\n    }\n\n    devtoolsConnectionRef.current = window.__REDUX_DEVTOOLS_EXTENSION__.connect({\n      instanceId: 1,\n      name: 'next-router'\n    });\n\n    if (devtoolsConnectionRef.current) {\n      devtoolsConnectionRef.current.init(normalizeRouterState(initialState));\n    }\n\n    return function () {\n      devtoolsConnectionRef.current = undefined;\n    };\n  }, [initialState]);\n\n  var _useReducer3 = (0, _react).useReducer(devToolReducer(\n  /* logReducer( */\n  fn\n  /*)*/\n  , devtoolsConnectionRef), initialState),\n      _useReducer4 = _slicedToArray(_useReducer3, 2),\n      state = _useReducer4[0],\n      dispatch = _useReducer4[1];\n\n  var sync = (0, _react).useCallback(function () {\n    if (devtoolsConnectionRef.current) {\n      devtoolsConnectionRef.current.send({\n        type: 'RENDER_SYNC'\n      }, normalizeRouterState(state));\n    }\n  }, [state]);\n  return [state, dispatch, sync];\n}\n\n_s2(useReducerWithReduxDevtoolsImpl, \"pLR6zS9fUqATAvEc1j249W8BDm8=\");\n\nvar useReducerWithReduxDevtools =  true ? useReducerWithReduxDevtoolsImpl : 0;\nexports.useReducerWithReduxDevtools = useReducerWithReduxDevtools;\n\nif ((typeof exports[\"default\"] === 'function' || typeof exports[\"default\"] === 'object' && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === 'undefined') {\n  Object.defineProperty(exports[\"default\"], '__esModule', {\n    value: true\n  });\n  Object.assign(exports[\"default\"], exports);\n  module.exports = exports[\"default\"];\n}\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy91c2UtcmVkdWNlci13aXRoLWRldnRvb2xzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOzs7Ozs7Ozs7Ozs7O0FBQ2JBLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBRGtDLENBQTdDO0FBR0FELG1DQUFBLEdBQXNDLEtBQUssQ0FBM0M7O0FBQ0EsSUFBSUcsTUFBTSxHQUFHQyxtQkFBTyxDQUFDLDRFQUFELENBQXBCOztBQUNBLFNBQVNDLG9CQUFULENBQThCQyxHQUE5QixFQUFtQztFQUMvQixJQUFJQSxHQUFHLFlBQVlDLEdBQW5CLEVBQXdCO0lBQ3BCLElBQU1DLEdBQUcsR0FBRyxFQUFaOztJQURvQiwyQ0FFT0YsR0FBRyxDQUFDRyxPQUFKLEVBRlA7SUFBQTs7SUFBQTtNQUVwQixvREFBeUM7UUFBQTtRQUFBLElBQTdCQyxHQUE2QjtRQUFBLElBQXhCVCxLQUF3Qjs7UUFDckMsSUFBSSxPQUFPQSxLQUFQLEtBQWlCLFVBQXJCLEVBQWlDO1VBQzdCTyxHQUFHLENBQUNFLEdBQUQsQ0FBSCxHQUFXLE1BQVg7VUFDQTtRQUNIOztRQUNELElBQUksT0FBT1QsS0FBUCxLQUFpQixRQUFqQixJQUE2QkEsS0FBSyxLQUFLLElBQTNDLEVBQWlEO1VBQzdDLElBQUlBLEtBQUssQ0FBQ1UsUUFBVixFQUFvQjtZQUNoQkgsR0FBRyxDQUFDRSxHQUFELENBQUgsR0FBV1QsS0FBSyxDQUFDVSxRQUFOLENBQWVDLFFBQWYsRUFBWDtZQUNBO1VBQ0g7O1VBQ0QsSUFBSVgsS0FBSyxDQUFDWSxjQUFWLEVBQTBCO1lBQ3RCTCxHQUFHLENBQUNFLEdBQUQsQ0FBSCxHQUFXLFlBQVg7WUFDQTtVQUNIO1FBQ0o7O1FBQ0RGLEdBQUcsQ0FBQ0UsR0FBRCxDQUFILEdBQVdMLG9CQUFvQixDQUFDSixLQUFELENBQS9CO01BQ0g7SUFsQm1CO01BQUE7SUFBQTtNQUFBO0lBQUE7O0lBbUJw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LE9BQU8sV0FBUCxLQUFvQixJQUF0RyxLQUFnSCxPQUFPQSxPQUFPLFdBQVAsQ0FBZ0I2QyxVQUF2QixLQUFzQyxXQUExSixFQUF1SztFQUNySy9DLE1BQU0sQ0FBQ0MsY0FBUCxDQUFzQkMsT0FBTyxXQUE3QixFQUF1QyxZQUF2QyxFQUFxRDtJQUFFQyxLQUFLLEVBQUU7RUFBVCxDQUFyRDtFQUNBSCxNQUFNLENBQUNnRCxNQUFQLENBQWM5QyxPQUFPLFdBQXJCLEVBQStCQSxPQUEvQjtFQUNBK0MsTUFBTSxDQUFDL0MsT0FBUCxHQUFpQkEsT0FBTyxXQUF4QjtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvdXNlLXJlZHVjZXItd2l0aC1kZXZ0b29scy5qcz80NTAwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy51c2VSZWR1Y2VyV2l0aFJlZHV4RGV2dG9vbHMgPSB2b2lkIDA7XG52YXIgX3JlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuZnVuY3Rpb24gbm9ybWFsaXplUm91dGVyU3RhdGUodmFsKSB7XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdmFsLmVudHJpZXMoKSl7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb2JqW2tleV0gPSAnZm4oKSc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS4kJHR5cGVvZikge1xuICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlLiQkdHlwZW9mLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuX2J1bmRsZXJDb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSAnRmxpZ2h0RGF0YSc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9ialtrZXldID0gbm9ybWFsaXplUm91dGVyU3RhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGZvcihjb25zdCBrZXkgaW4gdmFsKXtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb2JqW2tleV0gPSAnZm4oKSc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS4kJHR5cGVvZikge1xuICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlLiQkdHlwZW9mLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoJ19idW5kbGVyQ29uZmlnJykpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSAnRmxpZ2h0RGF0YSc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9ialtrZXldID0gbm9ybWFsaXplUm91dGVyU3RhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIHZhbC5tYXAobm9ybWFsaXplUm91dGVyU3RhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuZnVuY3Rpb24gZGV2VG9vbFJlZHVjZXIoZm4sIHJlZikge1xuICAgIHJldHVybiAoc3RhdGUsIGFjdGlvbik9PntcbiAgICAgICAgY29uc3QgcmVzID0gZm4oc3RhdGUsIGFjdGlvbik7XG4gICAgICAgIGlmIChyZWYuY3VycmVudCkge1xuICAgICAgICAgICAgcmVmLmN1cnJlbnQuc2VuZChhY3Rpb24sIG5vcm1hbGl6ZVJvdXRlclN0YXRlKHJlcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHVzZVJlZHVjZXJXaXRoUmVkdXhEZXZ0b29sc05vb3AoZm4sIGluaXRpYWxTdGF0ZSkge1xuICAgIGNvbnN0IFtzdGF0ZSwgZGlzcGF0Y2hdID0gKDAsIF9yZWFjdCkudXNlUmVkdWNlcihmbiwgaW5pdGlhbFN0YXRlKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBzdGF0ZSxcbiAgICAgICAgZGlzcGF0Y2gsXG4gICAgICAgICgpPT57fVxuICAgIF07XG59XG5mdW5jdGlvbiB1c2VSZWR1Y2VyV2l0aFJlZHV4RGV2dG9vbHNJbXBsKGZuLCBpbml0aWFsU3RhdGUpIHtcbiAgICBjb25zdCBkZXZ0b29sc0Nvbm5lY3Rpb25SZWYgPSAoMCwgX3JlYWN0KS51c2VSZWYoKTtcbiAgICBjb25zdCBlbmFibGVkUmVmID0gKDAsIF9yZWFjdCkudXNlUmVmKCk7XG4gICAgKDAsIF9yZWFjdCkudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGlmIChkZXZ0b29sc0Nvbm5lY3Rpb25SZWYuY3VycmVudCB8fCBlbmFibGVkUmVmLmN1cnJlbnQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuYWJsZWRSZWYuY3VycmVudCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGVuYWJsZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRldnRvb2xzQ29ubmVjdGlvblJlZi5jdXJyZW50ID0gd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18uY29ubmVjdCh7XG4gICAgICAgICAgICBpbnN0YW5jZUlkOiAxLFxuICAgICAgICAgICAgbmFtZTogJ25leHQtcm91dGVyJ1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRldnRvb2xzQ29ubmVjdGlvblJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBkZXZ0b29sc0Nvbm5lY3Rpb25SZWYuY3VycmVudC5pbml0KG5vcm1hbGl6ZVJvdXRlclN0YXRlKGluaXRpYWxTdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgZGV2dG9vbHNDb25uZWN0aW9uUmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBpbml0aWFsU3RhdGVcbiAgICBdKTtcbiAgICBjb25zdCBbc3RhdGUsIGRpc3BhdGNoXSA9ICgwLCBfcmVhY3QpLnVzZVJlZHVjZXIoZGV2VG9vbFJlZHVjZXIoLyogbG9nUmVkdWNlciggKi8gZm4gLyopKi8gLCBkZXZ0b29sc0Nvbm5lY3Rpb25SZWYpLCBpbml0aWFsU3RhdGUpO1xuICAgIGNvbnN0IHN5bmMgPSAoMCwgX3JlYWN0KS51c2VDYWxsYmFjaygoKT0+e1xuICAgICAgICBpZiAoZGV2dG9vbHNDb25uZWN0aW9uUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGRldnRvb2xzQ29ubmVjdGlvblJlZi5jdXJyZW50LnNlbmQoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdSRU5ERVJfU1lOQydcbiAgICAgICAgICAgIH0sIG5vcm1hbGl6ZVJvdXRlclN0YXRlKHN0YXRlKSk7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIHN0YXRlXG4gICAgXSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGRpc3BhdGNoLFxuICAgICAgICBzeW5jXG4gICAgXTtcbn1cbmNvbnN0IHVzZVJlZHVjZXJXaXRoUmVkdXhEZXZ0b29scyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gdXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzSW1wbCA6IHVzZVJlZHVjZXJXaXRoUmVkdXhEZXZ0b29sc05vb3A7XG5leHBvcnRzLnVzZVJlZHVjZXJXaXRoUmVkdXhEZXZ0b29scyA9IHVzZVJlZHVjZXJXaXRoUmVkdXhEZXZ0b29scztcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLXJlZHVjZXItd2l0aC1kZXZ0b29scy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ1c2VSZWR1Y2VyV2l0aFJlZHV4RGV2dG9vbHMiLCJfcmVhY3QiLCJyZXF1aXJlIiwibm9ybWFsaXplUm91dGVyU3RhdGUiLCJ2YWwiLCJNYXAiLCJvYmoiLCJlbnRyaWVzIiwia2V5IiwiJCR0eXBlb2YiLCJ0b1N0cmluZyIsIl9idW5kbGVyQ29uZmlnIiwiaGFzT3duUHJvcGVydHkiLCJBcnJheSIsImlzQXJyYXkiLCJtYXAiLCJkZXZUb29sUmVkdWNlciIsImZuIiwicmVmIiwic3RhdGUiLCJhY3Rpb24iLCJyZXMiLCJjdXJyZW50Iiwic2VuZCIsInVzZVJlZHVjZXJXaXRoUmVkdXhEZXZ0b29sc05vb3AiLCJpbml0aWFsU3RhdGUiLCJ1c2VSZWR1Y2VyIiwiZGlzcGF0Y2giLCJ1c2VSZWR1Y2VyV2l0aFJlZHV4RGV2dG9vbHNJbXBsIiwiZGV2dG9vbHNDb25uZWN0aW9uUmVmIiwidXNlUmVmIiwiZW5hYmxlZFJlZiIsInVzZUVmZmVjdCIsInVuZGVmaW5lZCIsIndpbmRvdyIsIl9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18iLCJjb25uZWN0IiwiaW5zdGFuY2VJZCIsIm5hbWUiLCJpbml0Iiwic3luYyIsInVzZUNhbGxiYWNrIiwidHlwZSIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/use-reducer-with-devtools.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-client)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fandrew%2FDesktop%2Fdevelopment%2Fbucketlist%2Ffrontend%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fapp-router.js&modules=%2FUsers%2Fandrew%2FDesktop%2Fdevelopment%2Fbucketlist%2Ffrontend%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Flayout-router.js&modules=%2FUsers%2Fandrew%2FDesktop%2Fdevelopment%2Fbucketlist%2Ffrontend%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context.js&modules=%2FUsers%2Fandrew%2FDesktop%2Fdevelopment%2Fbucketlist%2Ffrontend%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Ferror-boundary.js&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);